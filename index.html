<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; margin-bottom: 10px; display: block; }
  button, label { margin: 5px; }
  .stats { margin-top: 10px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<!-- Pulse Waveform -->
<canvas id="pulseCanvas" width="800" height="200"></canvas>

<!-- Phase Histogram -->
<canvas id="phaseHistogramCanvas" width="400" height="200"></canvas>

<!-- Cross Correlation -->
<canvas id="crossCorrelationCanvas" width="400" height="200"></canvas>

<!-- Phase Scatter Plot -->
<canvas id="phaseScatterCanvas" width="400" height="200"></canvas>

<br>

<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<div class="controls">
  <button id="toggleAllBtn">Hide All Stats & Markings & Waveform</button>
</div>

<div class="stats" id="metricsDisplay"></div>

<script>
(() => {
  // Get elements and contexts
  const toggleAllBtn = document.getElementById("toggleAllBtn");
  const pulseCanvas = document.getElementById("pulseCanvas");
  const pulseCtx = pulseCanvas.getContext("2d");

  const phaseHistogramCanvas = document.getElementById("phaseHistogramCanvas");
  const phaseHistCtx = phaseHistogramCanvas.getContext("2d");

  const crossCorrelationCanvas = document.getElementById("crossCorrelationCanvas");
  const crossCorrCtx = crossCorrelationCanvas.getContext("2d");

  const phaseScatterCanvas = document.getElementById("phaseScatterCanvas");
  const phaseScatterCtx = phaseScatterCanvas.getContext("2d");

  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");

  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");

  // Variables
  let displayAll = true;  // Controls visibility of stats, markings & waveform
  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;

  // Constants for waveform simulation
  const DISPLAY_DURATION = 20000; // 20 seconds window on canvas
  const SAMPLE_INTERVAL = 20; // 20 ms per sample
  const BASELINE = 100;
  const AMPLITUDE = 50;
  const FREQ = 1.2; // frequency in Hz (approx 72 bpm)

  // Simulate waveform by generating sine wave samples
  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const noise = (Math.random() - 0.5) * 5;
      const value = BASELINE + AMPLITUDE * Math.sin(2 * Math.PI * FREQ * t) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    // Keep last 5 minutes data max
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  // Clear all canvases helper
  function clearAllCanvases() {
    pulseCtx.clearRect(0, 0, pulseCanvas.width, pulseCanvas.height);
    phaseHistCtx.clearRect(0, 0, phaseHistogramCanvas.width, phaseHistogramCanvas.height);
    crossCorrCtx.clearRect(0, 0, crossCorrelationCanvas.width, crossCorrelationCanvas.height);
    phaseScatterCtx.clearRect(0, 0, phaseScatterCanvas.width, phaseScatterCanvas.height);
  }

  // Draw waveform, throbs, peaks
  function draw() {
    if (!displayAll) {
      clearAllCanvases();
      return;
    }

    simulatePulse();
    pulseCtx.clearRect(0, 0, pulseCanvas.width, pulseCanvas.height);

    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    // Draw waveform line
    pulseCtx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * pulseCanvas.width;
      const y = pulseCanvas.height - p.value;
      if (i === 0) pulseCtx.moveTo(x, y);
      else pulseCtx.lineTo(x, y);
    });
    pulseCtx.strokeStyle = "blue";
    pulseCtx.lineWidth = 2;
    pulseCtx.stroke();

    if (displayAll) {
      // Draw throbs (red circles)
      throbs.forEach(throb => {
        if (throb.time < start || throb.time > now) return;
        const val = interpolatePulseValue(throb.time);
        if (val === null) return;
        const x = ((throb.time - start) / DISPLAY_DURATION) * pulseCanvas.width;
        const y = pulseCanvas.height - val;
        pulseCtx.beginPath();
        pulseCtx.arc(x, y, 5, 0, 2 * Math.PI);
        pulseCtx.fillStyle = "red";
        pulseCtx.fill();
      });

      // Draw peaks (green circles)
      const peaks = findPeaks();
      peaks.forEach(peakTime => {
        if (peakTime < start || peakTime > now) return;
        const val = interpolatePulseValue(peakTime);
        if (val === null) return;
        const x = ((peakTime - start) / DISPLAY_DURATION) * pulseCanvas.width;
        const y = pulseCanvas.height - val;
        pulseCtx.beginPath();
        pulseCtx.arc(x, y, 4, 0, 2 * Math.PI);
        pulseCtx.fillStyle = "green";
        pulseCtx.fill();
      });
    }

    if (isRecording && !isPaused) {
      animationId = requestAnimationFrame(draw);
    }
  }

  // Linear interpolate pulse value at time t
  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  // Detect peaks by local maxima
  function findPeaks() {
    const peaks = [];
    const values = pulseWave.map(p => p.value);
    for (let i = 1; i < values.length - 1; i++) {
      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {
        peaks.push(pulseWave[i].time);
      }
    }
    return peaks;
  }

  // Calculate phase of time t relative to surrounding peaks
  function calculatePhase(t) {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;

    // Find peaks surrounding time t
    let prevPeak = null, nextPeak = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prevPeak = peaks[i];
        nextPeak = peaks[i + 1];
        break;
      }
    }

    if (prevPeak === null || nextPeak === null) return null;

    const phase = 2 * Math.PI * (t - prevPeak) / (nextPeak - prevPeak);
    return normalizeAngle(phase);
  }

  // Normalize angle to [0, 2Ï€)
  function normalizeAngle(angle) {
    let a = angle % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  // Circular mean of angles (radians)
  function circularMean(angles) {
    if (angles.length === 0) return null;
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    let mean = Math.atan2(sumSin, sumCos);
    mean = normalizeAngle(mean);
    return mean;
  }

  // Mean resultant length (r)
  function resultantLength(angles) {
    if (angles.length === 0) return null;
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    return Math.sqrt(sumSin * sumSin + sumCos * sumCos) / angles.length;
  }

  // Rayleigh test p-value approximation
  function rayleighPValue(r, n) {
    if (n === 0) return null;
    const R = r * n;
    const p = Math.exp(-R * R / n) * (1 + (2 * R * R - R * R * R * R) / (4 * n) - (24 * R * R - 132 * R * R * R * R + 76 * R * R * R * R * R * R - 9 * R * R * R * R * R * R * R * R) / (288 * n * n));
    return p;
  }

  // Calculate Phase Locking Value (PLV) (same as resultant length)
  function calculatePLV(angles) {
    return resultantLength(angles);
  }

  // Calculate mean vector angle in degrees for display
  function meanVectorAngleDeg(angles) {
    const mean = circularMean(angles);
    if (mean === null) return null;
    return (mean * 180 / Math.PI).toFixed(2);
  }

  // Calculate circular variance (1 - r)
  function circularVariance(angles) {
    const r = resultantLength(angles);
    return r === null ? null : 1 - r;
  }

  // Compute cross-correlation between throb timings and pulse waveform (simple)
  function computeCrossCorrelation() {
    // For simplicity, cross-corr between throb signal (impulses) and pulse values
    if (throbs.length === 0 || pulseWave.length === 0) return null;

    // Build throb impulse train aligned with pulseWave times
    const impulses = pulseWave.map(p => {
      return throbs.some(throb => Math.abs(throb.time - p.time) < 50) ? 1 : 0;
    });

    const pulseVals = pulseWave.map(p => p.value);

    // Calculate normalized cross-correlation at zero lag
    const meanPulse = pulseVals.reduce((a, b) => a + b, 0) / pulseVals.length;
    const meanImp = impulses.reduce((a, b) => a + b, 0) / impulses.length;

    let numerator = 0;
    let denomPulse = 0;
    let denomImp = 0;

    for (let i = 0; i < pulseVals.length; i++) {
      numerator += (pulseVals[i] - meanPulse) * (impulses[i] - meanImp);
      denomPulse += (pulseVals[i] - meanPulse) ** 2;
      denomImp += (impulses[i] - meanImp) ** 2;
    }
    if (denomPulse === 0 || denomImp === 0) return null;

    return numerator / Math.sqrt(denomPulse * denomImp);
  }

  // Draw rose plot of phases
  function drawRosePlot() {
    phaseHistCtx.clearRect(0, 0, phaseHistogramCanvas.width, phaseHistogramCanvas.height);
    if (!displayAll) return;

    const phases = throbs
      .map(throb => calculatePhase(throb.time))
      .filter(p => p !== null);

    if (phases.length === 0) return;

    const bins = 12;
    const counts = new Array(bins).fill(0);
    phases.forEach(p => {
      let bin = Math.floor((p / (2 * Math.PI)) * bins);
      if (bin === bins) bin = 0;
      counts[bin]++;
    });

    const maxCount = Math.max(...counts);
    const centerX = phaseHistogramCanvas.width / 2;
    const centerY = phaseHistogramCanvas.height / 2;
    const radius = Math.min(centerX, centerY) - 10;

    // Draw rose plot sectors
    for (let i = 0; i < bins; i++) {
      const startAngle = (i * 2 * Math.PI) / bins;
      const endAngle = ((i + 1) * 2 * Math.PI) / bins;
      const r = (counts[i] / maxCount) * radius;

      phaseHistCtx.beginPath();
      phaseHistCtx.moveTo(centerX, centerY);
      phaseHistCtx.arc(centerX, centerY, r, startAngle, endAngle);
      phaseHistCtx.closePath();
      phaseHistCtx.fillStyle = "rgba(0, 0, 255, 0.5)";
      phaseHistCtx.fill();
      phaseHistCtx.strokeStyle = "blue";
      phaseHistCtx.stroke();
    }
  }

  // Draw cross correlation plot (simple bar)
  function drawCrossCorrelation() {
    crossCorrCtx.clearRect(0, 0, crossCorrelationCanvas.width, crossCorrelationCanvas.height);
    if (!displayAll) return;

    const corr = computeCrossCorrelation();
    if (corr === null) return;

    const width = crossCorrelationCanvas.width;
    const height = crossCorrelationCanvas.height;

    crossCorrCtx.fillStyle = "black";
    crossCorrCtx.font = "16px sans-serif";
    crossCorrCtx.fillText("Cross-Correlation (Throb vs Pulse) at lag=0", 10, 20);

    const barHeight = (corr + 1) / 2 * (height - 40); // normalize from [-1,1] to [0,height-40]

    crossCorrCtx.fillStyle = corr > 0 ? "green" : "red";
    crossCorrCtx.fillRect(width / 2 - 25, height - 20 - barHeight, 50, barHeight);

    crossCorrCtx.strokeRect(width / 2 - 25, height - 20 - (height - 40), 50, height - 40);

    crossCorrCtx.fillStyle = "black";
    crossCorrCtx.fillText(corr.toFixed(3), width / 2 - 15, height - 25 - barHeight);
  }

  // Draw phase scatter plot (throb phases)
  function drawPhaseScatter() {
    phaseScatterCtx.clearRect(0, 0, phaseScatterCanvas.width, phaseScatterCanvas.height);
    if (!displayAll) return;

    const phases = throbs
      .map(throb => calculatePhase(throb.time))
      .filter(p => p !== null);

    if (phases.length === 0) return;

    const width = phaseScatterCanvas.width;
    const height = phaseScatterCanvas.height;

    phaseScatterCtx.fillStyle = "black";
    phaseScatterCtx.font = "16px sans-serif";
    phaseScatterCtx.fillText("Phase Scatter Plot (Throb Phases)", 10, 20);

    phases.forEach(p => {
      const x = (p / (2 * Math.PI)) * width;
      const y = height / 2 + (Math.random() - 0.5) * 30; // jitter for clarity
      phaseScatterCtx.beginPath();
      phaseScatterCtx.arc(x, y, 5, 0, 2 * Math.PI);
      phaseScatterCtx.fillStyle = "purple";
      phaseScatterCtx.fill();
    });
  }

  // Update metrics display at bottom
  function updateMetrics() {
    if (!displayAll) {
      metricsDisplay.innerHTML = "";
      return;
    }

    const phases = throbs
      .map(throb => calculatePhase(throb.time))
      .filter(p => p !== null);

    const n = phases.length;
    if (n === 0) {
      metricsDisplay.innerHTML = "<b>No throbs recorded yet.</b>";
      return;
    }

    const r = resultantLength(phases);
    const meanAngleDeg = meanVectorAngleDeg(phases);
    const circVar = circularVariance(phases);
    const plv = calculatePLV(phases);
    const pValRaw = rayleighPValue(r, n);

    // Format Rayleigh p-value
    let rayleighPFormatted = "";
    if (pValRaw === null) rayleighPFormatted = "N/A";
    else if (pValRaw < 0.0001) rayleighPFormatted = "<0.0001";
    else rayleighPFormatted = pValRaw.toFixed(4);

    // Display stats nicely
    metricsDisplay.innerHTML = `
      <b>Throbs Recorded:</b> ${n} <br>
      <b>Phase Locking Value (PLV):</b> ${plv.toFixed(4)} <br>
      <b>Mean Phase Angle:</b> ${meanAngleDeg}Â° <br>
      <b>Circular Variance:</b> ${circVar.toFixed(4)} <br>
      <b>Rayleigh Test p-value:</b> ${rayleighPFormatted} <br>
      <b>Cross Correlation:</b> ${computeCrossCorrelation()?.toFixed(4) ?? "N/A"}
    `;
  }

  // Timer update
  function updateTimer() {
    if (!recordingStartTime) {
      timerDisplay.textContent = "00:00";
      return;
    }
    const diff = (performance.now() - recordingStartTime) / 1000;
    const minutes = Math.floor(diff / 60);
    const seconds = Math.floor(diff % 60);
    timerDisplay.textContent = `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;
  }

  // Button event handlers
  startBtn.onclick = () => {
    if (isRecording) return;
    isRecording = true;
    isPaused = false;
    recordingStartTime = performance.now();
    throbs = [];
    pulseWave = [];
    lastSampleTime = 0;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;

    updateMetrics();
    updateTimer();
    timerInterval = setInterval(updateTimer, 500);
    draw();
  };

  pauseBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    if (animationId) cancelAnimationFrame(animationId);
    if (timerInterval) clearInterval(timerInterval);
  };

  resumeBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    updateTimer();
    timerInterval = setInterval(updateTimer, 500);
    draw();
  };

  stopBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;

    if (animationId) cancelAnimationFrame(animationId);
    if (timerInterval) clearInterval(timerInterval);

    updateMetrics();
  };

  throbBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    throbs.push({ time: performance.now() });
    updateMetrics();
  };

  // Toggle button event
  toggleAllBtn.onclick = () => {
    displayAll = !displayAll;
    toggleAllBtn.textContent = displayAll
      ? "Hide All Stats & Markings & Waveform"
      : "Show All Stats & Markings & Waveform";

    if (displayAll) {
      updateMetrics();
      if (isRecording && !isPaused) {
        draw();
      }
    } else {
      clearAllCanvases();
      metricsDisplay.innerHTML = "";
      if (animationId) cancelAnimationFrame(animationId);
    }
  };

})();
</script>

</body>
</html>
