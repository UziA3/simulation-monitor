<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pulse Recorder</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }
    canvas {
      border: 1px solid black;
      display: block;
      margin-bottom: 20px;
    }
    #recordingsList button {
      margin-left: 5px;
    }
  </style>
</head>
<body>
  <h1>Pulse Recorder</h1>

  <canvas id="waveformCanvas" width="800" height="400"></canvas>

  <button id="startBtn">Start Recording</button>
  <button id="stopBtn" disabled>Stop Recording</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>

  <h2>Recordings</h2>
  <div id="recordingsList"></div>

  <h2>Metrics</h2>
  <pre id="metricsDisplay">No recording selected.</pre>

<script>
(() => {
  const canvas = document.getElementById('waveformCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const recordingsList = document.getElementById('recordingsList');
  const metricsDisplay = document.getElementById('metricsDisplay');

  let isRecording = false;
  let pulseWaveform = [];
  let throbs = [];
  let recordings = [];
  let selectedRecordingIndex = null;

  let animationFrameId = null;

  // Generate simulated pulse data (no circle visualization)
  function generatePulseValue(time) {
    // Simple sine wave plus noise
    return 0.5 + 0.5 * Math.sin(time * 2 * Math.PI * 1.5) + (Math.random() - 0.5) * 0.1;
  }

  // Clear all waveform and throbs data for new recording
  function resetRecordingData() {
    pulseWaveform = [];
    throbs = [];
    clearCanvas();
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Draw pulse waveform and throbs
  function draw() {
    clearCanvas();

    const w = canvas.width;
    const h = canvas.height;

    // Draw waveform line
    ctx.strokeStyle = 'blue';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < pulseWaveform.length; i++) {
      const x = (i / (pulseWaveform.length - 1)) * w;
      const y = h - pulseWaveform[i] * h;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw throbs as vertical red lines
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 1;
    throbs.forEach(idx => {
      if (idx >= 0 && idx < pulseWaveform.length) {
        const x = (idx / (pulseWaveform.length - 1)) * w;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
    });

    if (isRecording) {
      animationFrameId = requestAnimationFrame(draw);
    }
  }

  // Calculate metrics for a given recording object
  function calculateMetrics(recording) {
    if (!recording || recording.throbs.length < 2) return null;

    // Calculate intervals in seconds between throbs (assuming 60Hz sampling)
    const sampleRate = 60; // samples per second
    const intervals = [];
    for (let i = 1; i < recording.throbs.length; i++) {
      intervals.push((recording.throbs[i] - recording.throbs[i - 1]) / sampleRate);
    }
    const avgInterval = intervals.reduce((a,b) => a + b, 0) / intervals.length;
    const stdDev = Math.sqrt(intervals.reduce((a,b) => a + (b - avgInterval)**2, 0) / intervals.length);

    const avgPulseRate = 60 / avgInterval; // beats per minute

    return {
      avgPulseRate: avgPulseRate.toFixed(2),
      stdDev: stdDev.toFixed(3),
      throbsCount: recording.throbs.length,
      duration: (recording.pulseWaveform.length / sampleRate).toFixed(2)
    };
  }

  // Display metrics info
  function displayMetrics(recording) {
    if (!recording) {
      metricsDisplay.textContent = 'No recording selected.';
      return;
    }
    const m = calculateMetrics(recording);
    if (!m) {
      metricsDisplay.textContent = 'Not enough throbs marked to calculate metrics.';
      return;
    }
    metricsDisplay.textContent = 
      `Average Pulse Rate (bpm): ${m.avgPulseRate}\n` +
      `Interval Std Dev (s): ${m.stdDev}\n` +
      `Number of Throbs: ${m.throbsCount}\n` +
      `Duration (s): ${m.duration}`;
  }

  // Render recordings list with buttons
  function renderRecordingsList() {
    recordingsList.innerHTML = '';
    recordings.forEach((rec, i) => {
      const div = document.createElement('div');
      div.textContent = `Recording ${i + 1} (${rec.pulseWaveform.length} samples, ${rec.throbs.length} throbs)`;

      const viewBtn = document.createElement('button');
      viewBtn.textContent = 'View';
      viewBtn.onclick = () => {
        selectedRecordingIndex = i;
        pulseWaveform = [...rec.pulseWaveform];
        throbs = [...rec.throbs];
        isRecording = false;
        cancelAnimationFrame(animationFrameId);
        draw();
        displayMetrics(rec);
        startBtn.disabled = false;
        stopBtn.disabled = true;
        markThrobBtn.disabled = true;
      };

      const downloadBtn = document.createElement('button');
      downloadBtn.textContent = 'Download CSV';
      downloadBtn.onclick = () => {
        downloadCSV(rec);
      };

      div.appendChild(viewBtn);
      div.appendChild(downloadBtn);

      recordingsList.appendChild(div);
    });
  }

  // Download CSV of a recording
  function downloadCSV(recording) {
    const sampleRate = 60;
    const rows = [];
    rows.push('SampleIndex,Value,Throb');
    for (let i = 0; i < recording.pulseWaveform.length; i++) {
      const val = recording.pulseWaveform[i].toFixed(4);
      const isThrob = recording.throbs.includes(i) ? '1' : '0';
      rows.push(`${i},${val},${isThrob}`);
    }
    const csvContent = rows.join('\n');
    const blob = new Blob([csvContent], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `recording_${Date.now()}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Start recording
  function startRecording() {
    resetRecordingData();
    selectedRecordingIndex = null;
    isRecording = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    markThrobBtn.disabled = false;
    displayMetrics(null);
    drawLoop();
  }

  // Stop recording
  function stopRecording() {
    isRecording = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    markThrobBtn.disabled = true;
    cancelAnimationFrame(animationFrameId);
    clearCanvas();
    draw(); // draw final waveform & throbs
  }

  // Animation loop for live recording
  function drawLoop() {
    if (!isRecording) return;

    // Generate new pulse value and add
    const time = pulseWaveform.length / 60; // seconds
    const val = generatePulseValue(time);
    pulseWaveform.push(val);

    draw();

    animationFrameId = requestAnimationFrame(drawLoop);
  }

  // Mark a throb at current pulseWaveform end index
  function markThrob() {
    if (!isRecording || pulseWaveform.length === 0) return;
    throbs.push(pulseWaveform.length - 1);
    // Optionally, update metrics live here if you want:
    // displayMetrics({pulseWaveform, throbs});
  }

  // Save recording
  function saveRecording() {
    if (pulseWaveform.length === 0) return;

    recordings.push({
      pulseWaveform: [...pulseWaveform],
      throbs: [...throbs]
    });
    renderRecordingsList();
  }

  // Attach event listeners
  startBtn.onclick = () => {
    startRecording();
  };

  stopBtn.onclick = () => {
    stopRecording();
    saveRecording();
  };

  markThrobBtn.onclick = () => {
    markThrob();
  };

  // Initial render
  renderRecordingsList();
  clearCanvas();

})();
</script>
</body>
</html>
