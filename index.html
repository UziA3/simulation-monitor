<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pulse Waveform with Stats</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f4f4f4;
  }
  #container {
    max-width: 960px;
    margin: 20px auto;
    text-align: center;
    padding: 10px;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
  }
  canvas {
    border: 1px solid #ccc;
    background: #fafafa;
    max-width: 100%;
    height: auto;
  }
  #stats {
    margin-top: 15px;
    font-size: 14px;
    text-align: left;
    background: #eee;
    padding: 10px;
    border-radius: 4px;
    font-family: monospace;
    overflow-x: auto;
  }
  button, select {
    margin: 5px;
    padding: 8px 12px;
    font-size: 14px;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
  button:hover, select:hover {
    background-color: #f0f0f0;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="pulseCanvas" width="880" height="240"></canvas>
  <div>
    <button id="markThrobBtn">Mark Throb</button>
    <button id="saveBtn">Save Recording</button>
    <button id="showStatsBtn">Show Stats</button>
    <button id="toggleDisplayBtn">Hide Waveform & Stats</button>
    <button id="downloadCSVBtn">Download CSV</button>
  </div>
  <select id="savedRecordings">
    <option value="">-- Select Saved Recording --</option>
  </select>
  <pre id="stats" style="display:none;"></pre>
</div>

<script>
(() => {
  const canvas = document.getElementById('pulseCanvas');
  const ctx = canvas.getContext('2d');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const saveBtn = document.getElementById('saveBtn');
  const showStatsBtn = document.getElementById('showStatsBtn');
  const toggleDisplayBtn = document.getElementById('toggleDisplayBtn');
  const downloadCSVBtn = document.getElementById('downloadCSVBtn');
  const savedRecordingsSelect = document.getElementById('savedRecordings');
  const statsPre = document.getElementById('stats');

  const durationSec = 20;
  const samplingIntervalMs = 50;
  const totalPoints = durationSec * 1000 / samplingIntervalMs;

  let pulseData = [], throbs = [], peaks = [], savedRecordings = [], displayOn = true;
  let currentStats = null;

  function nowMs() { return performance.now(); }

  function generateArterialPulse(tMs) {
    const tSec = tMs / 1000;
    const frequency = 1.1; // ~66 bpm
    const alpha = 10 * frequency;
    const beta = 0.6 * frequency;
    const wave = Math.pow(tSec % (1/frequency), 2) * Math.exp(-alpha * (tSec % (1/frequency))) * Math.sin(2 * Math.PI * frequency * tSec);
    return wave + (Math.random() - 0.5) * 0.2;
  }

  function detectPeaks(data) {
    const detected = [];
    for (let i = 1; i < data.length - 1; i++) {
      if (data[i].value > data[i-1].value && data[i].value > data[i+1].value) {
        detected.push(data[i]);
      }
    }
    return detected;
  }

  function calculatePhases(throbs, peaks) {
    const phases = [];
    const sortedPeaks = [...peaks].sort((a,b) => a.timeMs - b.timeMs);
    for (const throb of throbs) {
      let prev = null, next = null;
      for (let p of sortedPeaks) {
        if (p.timeMs <= throb.timeMs) prev = p;
        if (p.timeMs > throb.timeMs) {
          next = p;
          break;
        }
      }
      if (prev && next) {
        const phase = ((throb.timeMs - prev.timeMs) / (next.timeMs - prev.timeMs)) * 2 * Math.PI;
        phases.push((phase + 2 * Math.PI) % (2 * Math.PI));
      }
    }
    return phases;
  }

  function calculatePhaseLocking(phases) {
    if (!phases.length) return {meanPhase: null, plv: null};
    let sinSum = 0, cosSum = 0;
    for (let p of phases) {
      sinSum += Math.sin(p);
      cosSum += Math.cos(p);
    }
    const n = phases.length;
    const meanPhase = Math.atan2(sinSum / n, cosSum / n);
    const plv = Math.sqrt(Math.pow(sinSum / n, 2) + Math.pow(cosSum / n, 2));
    return {meanPhase, plv};
  }

  function rayleighTest(phases) {
    if (!phases.length) return null;
    const n = phases.length;
    let sumSin = 0, sumCos = 0;
    for (let p of phases) {
      sumSin += Math.sin(p);
      sumCos += Math.cos(p);
    }
    const R = Math.sqrt(sumSin**2 + sumCos**2);
    const Rbar = R / n;
    const Z = n * Rbar ** 2;
    return Math.exp(-Z);
  }

  function calculateMeanPulseRate(peaks) {
    if (peaks.length < 2) return null;
    let totalTime = peaks[peaks.length - 1].timeMs - peaks[0].timeMs;
    let bpm = (peaks.length - 1) / (totalTime / 60000);
    return bpm;
  }

  function formatFixed(v, d=3) { return v === null ? 'N/A' : v.toFixed(d); }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!displayOn) return;

    const now = nowMs();
    const start = now - durationSec * 1000;
    const mapX = t => ((t - start) / (durationSec * 1000)) * canvas.width;
    const mapY = v => canvas.height/2 - (v * canvas.height/4);

    ctx.beginPath();
    ctx.strokeStyle = '#007bff';
    pulseData.forEach((p, i) => {
      const x = mapX(p.timeMs), y = mapY(p.value);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    ctx.fillStyle = 'green';
    peaks.forEach(p => ctx.beginPath(), ctx.arc(mapX(p.timeMs), mapY(p.value), 3, 0, 2 * Math.PI), ctx.fill());
    ctx.fillStyle = 'red';
    throbs.forEach(p => ctx.beginPath(), ctx.arc(mapX(p.timeMs), mapY(p.value), 4, 0, 2 * Math.PI), ctx.fill());

    if (currentStats) {
      const txt = [
        `Throbs: ${currentStats.throbCount}`,
        `Mean Phase (rad): ${formatFixed(currentStats.meanPhase)}`,
        `PLV: ${formatFixed(currentStats.plv)}`,
        `Rayleigh p-value: ${formatFixed(currentStats.pValue,5)}`,
        `Mean Pulse Rate (bpm): ${formatFixed(currentStats.meanPulseRate)}`,
        `Peak Count: ${currentStats.peakCount}`
      ];
      ctx.fillStyle = '#333';
      ctx.font = '14px monospace';
      txt.forEach((line, i) => ctx.fillText(line, 10, 10 + i * 20));
    }
  }

  function updatePulse() {
    const t = nowMs();
    pulseData.push({ timeMs: t, value: generateArterialPulse(t) });
    if (pulseData.length > totalPoints) pulseData.shift();
    peaks = detectPeaks(pulseData);
    draw();
  }

  setInterval(updatePulse, samplingIntervalMs);

  markThrobBtn.onclick = () => {
    if (!pulseData.length) return;
    throbs.push({ ...pulseData[pulseData.length - 1] });
    draw();
  };

  saveBtn.onclick = () => {
    if (!throbs.length || !pulseData.length) return alert('Missing data.');
    const rec = { pulseData: [...pulseData], throbs: [...throbs], peaks: [...peaks], timestamp: new Date().toISOString() };
    savedRecordings.push(rec);
    const opt = document.createElement('option');
    opt.value = savedRecordings.length - 1;
    opt.textContent = `Recording ${savedRecordings.length} (${rec.timestamp})`;
    savedRecordingsSelect.appendChild(opt);
    alert('Recording saved.');
  };

  showStatsBtn.onclick = () => {
    const idx = savedRecordingsSelect.value;
    if (!idx) return alert('Select a recording.');
    const rec = savedRecordings[idx];
    const phases = calculatePhases(rec.throbs, rec.peaks);
    const { meanPhase, plv } = calculatePhaseLocking(phases);
    const pValue = rayleighTest(phases);
    const meanPulseRate = calculateMeanPulseRate(rec.peaks);

    let deltaTimes = rec.throbs.map((t, i, a) => i === 0 ? 'N/A' : (t.timeMs - a[i-1].timeMs).toFixed(0));

    currentStats = {
      throbCount: rec.throbs.length,
      meanPhase,
      plv,
      pValue,
      meanPulseRate,
      peakCount: rec.peaks.length
    };

    statsPre.textContent = `--- Stats ---\n${rec.throbs.map((t, i) => {
      const phase = phases[i] ? formatFixed(phases[i]) : 'N/A';
      return `Throb ${i+1}: Time=${t.timeMs.toFixed(0)} ms, Î”=${deltaTimes[i]} ms, Phase=${phase}, Val=${t.value.toFixed(3)}`;
    }).join('\n')}`;
    statsPre.style.display = 'block';
    draw();
  };

  downloadCSVBtn.onclick = () => {
    const idx = savedRecordingsSelect.value;
    if (!idx) return alert('Select a recording.');
    const rec = savedRecordings[idx];
    const phases = calculatePhases(rec.throbs, rec.peaks);
    const csvRows = [
      'Index,Time(ms),Delta(ms),Phase(rad),Pulse Value'
    ];
    let lastTime = null;
    rec.throbs.forEach((t, i) => {
      const phase = phases[i] ? phases[i].toFixed(5) : 'N/A';
      const dt = lastTime === null ? 'N/A' : (t.timeMs - lastTime).toFixed(0);
      csvRows.push(`${i+1},${t.timeMs.toFixed(0)},${dt},${phase},${t.value.toFixed(5)}`);
      lastTime = t.timeMs;
    });
    const blob = new Blob([csvRows.join('\n')], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `recording_${idx}_throbs.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  toggleDisplayBtn.onclick = () => {
    displayOn = !displayOn;
    toggleDisplayBtn.textContent = displayOn ? 'Hide Waveform & Stats' : 'Show Waveform & Stats';
    statsPre.style.display = displayOn && currentStats ? 'block' : 'none';
    draw();
  };
})();
</script>
</body>
</html>
