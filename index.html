<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Migraine Throb Temporal Synchrony App</title>
<style>
  body { font-family: Arial; margin: 2rem auto; max-width: 900px; }
  canvas { border: 1px solid #ccc; display: block; margin-bottom: 1rem; }
  button, input { margin: 5px; }
  .recording { border: 1px solid #ddd; padding: 10px; margin-top: 10px; }
</style>
</head>
<body>
<h2>Migraine Throb Temporal Synchrony App</h2>
<canvas id="canvas" width="800" height="230"></canvas>
<div>
  <input type="text" id="recordingName" placeholder="Enter recording name" />
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markBtn" disabled>Mark Throb</button>
  <button id="toggleBtn">Hide Waveform</button>
</div>
<h3>Recordings</h3>
<div id="recordingsList"><p>No recordings yet.</p></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn = document.getElementById("stopBtn");
const markBtn = document.getElementById("markBtn");
const toggleBtn = document.getElementById("toggleBtn");
const recNameInput = document.getElementById("recordingName");
const recordingsList = document.getElementById("recordingsList");

const MS_PER_MIN = 60000;
const VIEW_MS = 8000;

let isRecording = false;
let isPaused = false;
let showWave = true;

let timer = 0;
let lastFrameTime = 0;

let throbs = [];
let peaks = [];

let phase = 0;
let currentBPM = 75;
let targetBPM = 75;
let bpmChangeStartTime = 0;
const bpmChangeDuration = 3000; // 3 seconds smooth bpm changes

let lastWaveVal = null;

// Constants for consistent first peak detection:
const FULL_CYCLE = 2 * Math.PI;
// Adjust this to your waveformâ€™s first peak phase (where main systolic peak is):
const FIRST_PEAK_PHASE = 0.3 * FULL_CYCLE;

let lastPeakCycle = -1;

function randomBPM() {
  return 60 + Math.random() * 40;
}

// Arterial pulse waveform shape function (one cycle)
function arterialPulseShape(phase) {
  if (phase < Math.PI * 0.6) {
    return Math.sin((phase / (Math.PI * 0.6)) * Math.PI);
  } else {
    const fallPhase = (phase - Math.PI * 0.6) / (FULL_CYCLE - Math.PI * 0.6);
    if (fallPhase < 0.5) {
      return Math.cos(fallPhase * Math.PI) * 0.5;
    } else {
      return Math.cos(fallPhase * Math.PI) * 0.3;
    }
  }
}

// Format milliseconds to mm:ss.ss (two decimals)
function formatTime(ms) {
  const m = Math.floor(ms / 60000);
  const s = ((ms % 60000) / 1000).toFixed(2);
  return `${m}:${s.padStart(5, "0")}`;
}

function findPriorPeak(time) {
  for (let i = peaks.length - 1; i >= 0; i--) {
    if (peaks[i].time <= time) return peaks[i];
  }
  return null;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw baseline
  ctx.strokeStyle = "#ccc";
  ctx.beginPath();
  ctx.moveTo(0, 150);
  ctx.lineTo(canvas.width, 150);
  ctx.stroke();

  // Draw waveform and markers if visible
  if (showWave) {
    // Draw waveform path for VIEW_MS
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.beginPath();

    for (let x = 0; x <= canvas.width; x++) {
      // Calculate phase for each pixel relative to timer-VIEW_MS window
      const t = timer - VIEW_MS + (x / canvas.width) * VIEW_MS;
      if (t < 0) continue;
      const cyclePhase = ((t / 1000) * (currentBPM / 60) * FULL_CYCLE) % FULL_CYCLE;
      const y = 150 - arterialPulseShape(cyclePhase) * 50;
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw peaks as vertical red lines
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    peaks.forEach(peak => {
      if (peak.time >= timer - VIEW_MS && peak.time <= timer) {
        const x = ((peak.time - (timer - VIEW_MS)) / VIEW_MS) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 120);
        ctx.lineTo(x, 180);
        ctx.stroke();
      }
    });

    // Draw throb markers as green vertical lines
    ctx.strokeStyle = "green";
    ctx.lineWidth = 1;
    throbs.forEach(throb => {
      if (throb >= timer - VIEW_MS && throb <= timer) {
        const x = ((throb - (timer - VIEW_MS)) / VIEW_MS) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 80);
        ctx.lineTo(x, 110);
        ctx.stroke();
      }
    });
  }

  // Draw timer below waveform, two decimals
  ctx.fillStyle = "black";
  ctx.font = "16px Arial";
  ctx.fillText(formatTime(timer), 10, 220);
}

function computeStats(name) {
  // Compute phase for throbs and deltas relative to prior peak only
  let rows = [];
  throbs.forEach(t => {
    const priorPeak = findPriorPeak(t);
    if (!priorPeak) return; // skip if no prior peak

    const delta = t - priorPeak.time;
    // Calculate phase angle (radians) of throb relative to peak interval
    const peakInterval = MS_PER_MIN / priorPeak.bpm;
    let phase = (delta / peakInterval) * FULL_CYCLE;
    while (phase < 0) phase += FULL_CYCLE;
    while (phase >= FULL_CYCLE) phase -= FULL_CYCLE;

    rows.push({ t, priorPeak: priorPeak.time, delta, bpm: priorPeak.bpm, phase });
  });

  // Rayleigh test of uniformity for phases (simplified)
  let sumSin = 0, sumCos = 0;
  rows.forEach(r => {
    sumSin += Math.sin(r.phase);
    sumCos += Math.cos(r.phase);
  });
  const n = rows.length;
  const R = n === 0 ? 0 : Math.sqrt(sumSin*sumSin + sumCos*sumCos) / n;

  // Rayleigh p-value approximation
  let p = 1;
  if (n > 0) {
    const z = n * R * R;
    p = Math.exp(Math.sqrt(1 + 4*n + 4*n*n - 4*n*z) - (1 + 2*n));
  }

  // Mean pulse rate over recorded peaks
  const bpms = peaks.map(p => p.bpm);
  const meanBPM = bpms.length > 0 ? bpms.reduce((a,b) => a+b,0) / bpms.length : 0;

  // Build CSV text
  let csv = `Recording Name:,${name}\n`;
  csv += `Duration (ms),${timer.toFixed(2)}\n`;
  csv += `Total throbs,${throbs.length}\n`;
  csv += `Total peaks,${peaks.length}\n`;
  csv += `Mean BPM,${meanBPM.toFixed(2)}\n`;
  csv += `Rayleigh's R,${R.toFixed(4)}\n`;
  csv += `Rayleigh's p-value,${p.toExponential(4)}\n\n`;

  csv += `ThrobTime(ms),PriorPeakTime(ms),Delta(ms),PulseBPM,Phase(rad)\n`;
  rows.forEach(r => {
    csv += `${r.t.toFixed(2)},${r.priorPeak.toFixed(2)},${r.delta.toFixed(2)},${r.bpm.toFixed(2)},${r.phase.toFixed(4)}\n`;
  });

  csv += `\nDelta between each throb and prior peak (ms):\n`;
  rows.forEach(r => {
    csv += `${r.delta.toFixed(2)}\n`;
  });

  return csv;
}

function saveRecording() {
  if (throbs.length === 0) {
    alert("No throbs recorded.");
    return;
  }
  const name = recNameInput.value.trim() || `Recording_${recordingsList.children.length + 1}`;
  const csv = computeStats(name);

  const recDiv = document.createElement("div");
  recDiv.className = "recording";

  const title = document.createElement("h4");
  title.textContent = name;
  recDiv.appendChild(title);

  const statsPre = document.createElement("pre");
  statsPre.textContent = csv;
  recDiv.appendChild(statsPre);

  // Download button for CSV
  const dlBtn = document.createElement("button");
  dlBtn.textContent = "Download CSV";
  dlBtn.onclick = () => {
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  recDiv.appendChild(dlBtn);

  recordingsList.appendChild(recDiv);

  // Reset for next recording
  throbs = [];
  peaks = [];
  timer = 0;
  recNameInput.value = "";
  draw();
}

function updateBPM(now) {
  const elapsed = now - bpmChangeStartTime;
  if (elapsed >= bpmChangeDuration) {
    bpmChangeStartTime = now;
    currentBPM = targetBPM;
    targetBPM = randomBPM();
  } else {
    const fraction = elapsed / bpmChangeDuration;
    currentBPM = currentBPM + fraction * (targetBPM - currentBPM);
  }
}

function animate(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  const deltaTime = timestamp - lastFrameTime;

  if (isRecording && !isPaused) {
    timer += deltaTime;
    updateBPM(timestamp);

    // Update phase (radians)
    phase += (deltaTime / 1000) * (currentBPM / 60) * FULL_CYCLE;
    if (phase >= FULL_CYCLE) {
      phase -= FULL_CYCLE;
    }

    // Determine current cycle number
    const cycle = Math.floor(phase / FULL_CYCLE);
    // Detect first peak at consistent phase per cycle
    // We trigger peak when phase crosses FIRST_PEAK_PHASE from below
    // Because phase wraps at FULL_CYCLE, handle wrap-around carefully

    // To detect crossing of FIRST_PEAK_PHASE between last and current phase:
    let phasePrev = phase - (deltaTime / 1000) * (currentBPM / 60) * FULL_CYCLE;
    if (phasePrev < 0) phasePrev += FULL_CYCLE;

    // Only add peak once per cycle
    if (cycle > lastPeakCycle) {
      // Check if FIRST_PEAK_PHASE was crossed between last and current phase
      if (
        (phasePrev < FIRST_PEAK_PHASE && phase >= FIRST_PEAK_PHASE) ||
        // Handle wrap-around if phasePrev near end and phase near start
        (phasePrev > phase && (FIRST_PEAK_PHASE > phasePrev || FIRST_PEAK_PHASE <= phase))
      ) {
        peaks.push({ time: timer, bpm: currentBPM });
        lastPeakCycle = cycle;
      }
    }
  }

  lastFrameTime = timestamp;
  draw();
  requestAnimationFrame(animate);
}

startBtn.onclick = () => {
  if (isRecording) return;
  isRecording = true;
  isPaused = false;
  timer = 0;
  phase = 0;
  currentBPM = randomBPM();
  targetBPM = randomBPM();
  bpmChangeStartTime = performance.now();
  throbs = [];
  peaks = [];
  lastPeakCycle = -1;
  lastFrameTime = 0;

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  markBtn.disabled = false;
  recNameInput.disabled = true;

  draw();
};

pauseBtn.onclick = () => {
  if (!isRecording) return;
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
};

stopBtn.onclick = () => {
  if (!isRecording) return;
  isRecording = false;
  isPaused = false;

  startBtn.disabled = false;
  pauseBtn.disabled = true;
  pauseBtn.textContent = "Pause";
  stopBtn.disabled = true;
  markBtn.disabled = true;
  recNameInput.disabled = false;

  saveRecording();
};

markBtn.onclick = () => {
  if (!isRecording) return;
  // Mark current timer as throb time
  throbs.push(timer);
};

toggleBtn.onclick = () => {
  showWave = !showWave;
  toggleBtn.textContent = showWave ? "Hide Waveform" : "Show Waveform";
  draw();
};

draw();
requestAnimationFrame(animate);
</script>
</body>
</html>
