<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pulse Waveform with Stats</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    #container {
      max-width: 900px;
      margin: 20px auto;
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      background: #fafafa;
    }
    #stats {
      margin-top: 15px;
      font-size: 14px;
      text-align: left;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      white-space: pre-wrap;
      background: #eee;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
    }
    button {
      margin: 5px;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="pulseCanvas" width="880" height="240"></canvas>
    <div>
      <button id="markThrobBtn">Mark Throb</button>
      <button id="saveBtn">Save Recording</button>
      <button id="showStatsBtn">Show Stats</button>
      <button id="toggleDisplayBtn">Hide Display</button>
      <button id="downloadCSVBtn">Download CSV</button>
    </div>
    <select id="savedRecordings" style="margin-top:10px;">
      <option value="">-- Select Saved Recording --</option>
    </select>
    <pre id="stats" style="display:none;"></pre>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('pulseCanvas');
      const ctx = canvas.getContext('2d');
      const markThrobBtn = document.getElementById('markThrobBtn');
      const saveBtn = document.getElementById('saveBtn');
      const showStatsBtn = document.getElementById('showStatsBtn');
      const toggleDisplayBtn = document.getElementById('toggleDisplayBtn');
      const downloadCSVBtn = document.getElementById('downloadCSVBtn');
      const savedRecordingsSelect = document.getElementById('savedRecordings');
      const statsPre = document.getElementById('stats');

      const durationSec = 20;
      const samplingIntervalMs = 50;
      const totalPoints = durationSec * 1000 / samplingIntervalMs;

      let pulseData = [];
      let throbs = [];
      let peaks = [];
      let savedRecordings = [];
      let displayOn = true;
      let currentStats = null;

      function nowMs() {
        return performance.now();
      }

      function generatePulseValue(tMs) {
        const tSec = tMs / 1000;
        const frequencyHz = 1;
        const sineVal = Math.sin(2 * Math.PI * frequencyHz * tSec);
        const noise = (Math.random() - 0.5) * 0.4;
        return sineVal + noise;
      }

      function detectPeaks(data) {
        const detected = [];
        for (let i = 1; i < data.length - 1; i++) {
          if (data[i].value > data[i-1].value && data[i].value > data[i+1].value) {
            detected.push(data[i]);
          }
        }
        return detected;
      }

      function calculatePhases(throbs, peaks) {
        const phases = [];
        const sortedPeaks = [...peaks].sort((a,b) => a.timeMs - b.timeMs);
        for (const throb of throbs) {
          let prevPeak = null;
          let nextPeak = null;
          for (let i = 0; i < sortedPeaks.length; i++) {
            if (sortedPeaks[i].timeMs <= throb.timeMs) {
              prevPeak = sortedPeaks[i];
            }
            if (sortedPeaks[i].timeMs > throb.timeMs) {
              nextPeak = sortedPeaks[i];
              break;
            }
          }
          if (prevPeak && nextPeak) {
            const cycleLength = nextPeak.timeMs - prevPeak.timeMs;
            const position = throb.timeMs - prevPeak.timeMs;
            let phase = (position / cycleLength) * 2 * Math.PI;
            phase = ((phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            phases.push(phase);
          }
        }
        return phases;
      }

      function calculatePhaseLocking(phases) {
        if (phases.length === 0) return {meanPhase: null, plv: null};
        let sumSin = 0, sumCos = 0;
        for (const phase of phases) {
          sumSin += Math.sin(phase);
          sumCos += Math.cos(phase);
        }
        const meanSin = sumSin / phases.length;
        const meanCos = sumCos / phases.length;
        const meanPhase = Math.atan2(meanSin, meanCos);
        const plv = Math.sqrt(meanSin * meanSin + meanCos * meanCos);
        return {meanPhase, plv};
      }

      function rayleighTest(phases) {
        if (phases.length === 0) return null;
        const n = phases.length;
        let sumSin = 0, sumCos = 0;
        for (const phase of phases) {
          sumSin += Math.sin(phase);
          sumCos += Math.cos(phase);
        }
        const R = Math.sqrt(sumSin * sumSin + sumCos * sumCos);
        const Rbar = R / n;
        const Z = n * Rbar * Rbar;
        const p = Math.exp(Math.sqrt(1 + 4 * n + 4 * (n * n - R * R)) - (1 + 2 * n));
        return p;
      }

      function calculateMeanPulseRate(peaks) {
        if (peaks.length < 2) return null;
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
          intervals.push(peaks[i].timeMs - peaks[i-1].timeMs);
        }
        const meanIntervalMs = intervals.reduce((a,b) => a+b, 0) / intervals.length;
        return meanIntervalMs === 0 ? null : 60000 / meanIntervalMs;
      }

      function formatFixed(value, decimals=3) {
        return value === null || value === undefined ? 'N/A' : value.toFixed(decimals);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!displayOn) return;

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#007bff';
        ctx.beginPath();
        if (pulseData.length > 0) {
          for (let i = 0; i < pulseData.length; i++) {
            const p = pulseData[i];
            const now = pulseData[pulseData.length-1].timeMs;
            const x = ((p.timeMs - (now - durationSec * 1000)) / (durationSec * 1000)) * canvas.width;
            const y = canvas.height/2 - (p.value * (canvas.height/3));
            if (i === 0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
          }
        }
        ctx.stroke();

        ctx.fillStyle = 'green';
        for (const peak of peaks) {
          const now = pulseData.length > 0 ? pulseData[pulseData.length-1].timeMs : 0;
          if (peak.timeMs < now - durationSec * 1000) continue;
          const x = ((peak.timeMs - (now - durationSec * 1000)) / (durationSec * 1000)) * canvas.width;
          const y = canvas.height/2 - (peak.value * (canvas.height/3));
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.fillStyle = 'red';
        for (const throb of throbs) {
          const now = pulseData.length > 0 ? pulseData[pulseData.length-1].timeMs : 0;
          if (throb.timeMs < now - durationSec * 1000) continue;
          const x = ((throb.timeMs - (now - durationSec * 1000)) / (durationSec * 1000)) * canvas.width;
          const y = canvas.height/2 - (throb.value * (canvas.height/3));
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.fillStyle = '#222';
        ctx.font = '16px monospace';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        if (currentStats) {
          const lines = [
            `Throbs: ${currentStats.throbCount}`,
            `Peaks: ${currentStats.peakCount}`,
            `Mean Phase (rad): ${formatFixed(currentStats.meanPhase)}`,
            `PLV: ${formatFixed(currentStats.plv)}`,
            `Rayleigh p-value: ${formatFixed(currentStats.pValue,5)}`,
            `Mean Pulse Rate (bpm): ${formatFixed(currentStats.meanPulseRate)}`
          ];
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], 10, 10 + i * 20);
          }
        }
      }

      function updatePulse() {
        const t = nowMs();
        const val = generatePulseValue(t);
        pulseData.push({timeMs: t, value: val});
        if (pulseData.length > totalPoints) pulseData.shift();
        peaks = detectPeaks(pulseData);
        draw();
      }

      function saveRecording() {
        if (pulseData.length === 0 || throbs.length === 0) {
          alert('Need both pulse data and throbs.');
          return;
        }
        const recording = {
          pulseData: [...pulseData],
          throbs: [...throbs],
          peaks: [...peaks],
          timestamp: new Date().toISOString()
        };
        savedRecordings.push(recording);
        const opt = document.createElement('option');
        opt.value = savedRecordings.length - 1;
        opt.textContent = `Recording ${savedRecordings.length}`;
        savedRecordingsSelect.appendChild(opt);
        alert('Recording saved.');
      }

      function downloadCSV() {
        if (savedRecordings.length === 0) {
          alert('No recordings to export.');
          return;
        }
        let csv = "Recording,Throb Count,Peak Count,Mean Phase (rad),PLV,Rayleigh p-value,Mean Pulse Rate (bpm)\n";
        for (let i = 0; i < savedRecordings.length; i++) {
          const rec = savedRecordings[i];
          const phases = calculatePhases(rec.throbs, rec.peaks);
          const {meanPhase, plv} = calculatePhaseLocking(phases);
          const pValue = rayleighTest(phases);
          const meanPulseRate = calculateMeanPulseRate(rec.peaks);
          csv += `${i+1},${rec.throbs.length},${rec.peaks.length},${formatFixed(meanPhase)},${formatFixed(plv)},${formatFixed(pValue,5)},${formatFixed(meanPulseRate)}\n`;
        }
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pulse_recordings.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      function showStats() {
        if (savedRecordings.length === 0) {
          alert('No recordings saved.');
          return;
        }
        const lines = [];
        savedRecordings.forEach((rec, i) => {
          const phases = calculatePhases(rec.throbs, rec.peaks);
          const {meanPhase, plv} = calculatePhaseLocking(phases);
          const pValue = rayleighTest(phases);
          const meanPulseRate = calculateMeanPulseRate(rec.peaks);
          currentStats = {
            throbCount: rec.throbs.length,
            peakCount: rec.peaks.length,
            meanPhase, plv, pValue,
            meanPulseRate
          };
          lines.push(`--- Recording ${i+1} ---`);
          lines.push(`Throb Count: ${rec.throbs.length}`);
          lines.push(`Peak Count: ${rec.peaks.length}`);
          lines.push(`Mean Phase (rad): ${formatFixed(meanPhase)}`);
          lines.push(`PLV: ${formatFixed(plv)}`);
          lines.push(`Rayleigh p-value: ${formatFixed(pValue,5)}`);
          lines.push(`Mean Pulse Rate (bpm): ${formatFixed(meanPulseRate)}`);
          lines.push('');
        });
        statsPre.textContent = lines.join('\n');
        statsPre.style.display = 'block';
        draw();
      }

      markThrobBtn.onclick = () => {
        const last = pulseData[pulseData.length-1];
        if (last) {
          throbs.push({...last});
          draw();
        }
      };
      saveBtn.onclick = saveRecording;
      downloadCSVBtn.onclick = downloadCSV;
      showStatsBtn.onclick = showStats;
      toggleDisplayBtn.onclick = () => {
        displayOn = !displayOn;
        toggleDisplayBtn.textContent = displayOn ? "Hide Display" : "Show Display";
        draw();
      };

      setInterval(updatePulse, samplingIntervalMs);
    })();
  </script>
</body>
</html>
