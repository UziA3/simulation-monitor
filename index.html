<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony App</title>
<style>
  canvas {
    border: 1px solid black;
    display: block;
    margin-bottom: 10px;
  }
  button {
    margin: 4px;
  }
  .recordings-list {
    margin-top: 10px;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony App</h1>
<canvas id="ecgCanvas" width="1000" height="200"></canvas>
<div>
  <button onclick="startRecording()">Start</button>
  <button onclick="pauseResumeRecording()">Pause/Resume</button>
  <button onclick="stopRecording()">Stop & Save</button>
  <button onclick="markThrob()">Mark Throb</button>
  <label><input type="checkbox" id="toggleDisplay" onchange="toggleWaveform()"> Show/Hide Waveform</label>
  <div id="timer">00:00.00</div>
</div>
<div class="recordings-list" id="recordingsList"></div>

<script>
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');
  const toggleDisplay = document.getElementById('toggleDisplay');
  const timerDisplay = document.getElementById('timer');

  let startTime, timerInterval, isPaused = false, pauseStart, pausedDuration = 0;
  let ecgData = [], rPeaks = [], throbs = [], bpm = 70, bpmChanges = [], phaseData = [];
  let lastBpmChange = 0, recording = false;
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;
  const ecgBuffer = 5000; // ms

  function generateECGWave(t, bpm) {
    const beatInterval = 60000 / bpm;
    const timeInBeat = t % beatInterval;
    const phase = timeInBeat / beatInterval;
    let value = 0;
    value += Math.exp(-Math.pow((phase - 0.2) * 40, 2)) * 0.15; // P wave
    value += Math.exp(-Math.pow((phase - 0.3) * 200, 2)) * 1.5;  // R peak
    value -= Math.exp(-Math.pow((phase - 0.35) * 100, 2)) * 0.3; // S wave
    value += Math.exp(-Math.pow((phase - 0.5) * 60, 2)) * 0.5;   // T wave
    return value;
  }

  function updateTimer() {
    const now = performance.now();
    const elapsed = (now - startTime - pausedDuration) / 1000;
    const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
    const seconds = (elapsed % 60).toFixed(2).padStart(5, '0');
    timerDisplay.textContent = `${minutes}:${seconds}`;
  }

  function scheduleNextBPMChange() {
    const delay = Math.random() * 4000 + 3000;
    setTimeout(() => {
      bpm = Math.floor(Math.random() * 41) + 60;
      lastBpmChange = performance.now();
      bpmChanges.push({ time: lastBpmChange - startTime, bpm });
      if (recording) scheduleNextBPMChange();
    }, delay);
  }

  function detectRPeaks() {
    rPeaks = [];
    const threshold = 0.2;  // <-- Lowered threshold here ONLY
    for (let i = 1; i < ecgData.length - 1; i++) {
      const prev = ecgData[i - 1].value;
      const curr = ecgData[i].value;
      const next = ecgData[i + 1].value;
      if (curr > threshold && curr > prev && curr > next) {
        rPeaks.push({ time: ecgData[i].time, bpm: getBPMAt(ecgData[i].time) });
      }
    }
  }

  function getBPMAt(time) {
    let bpmVal = bpm;
    for (const change of bpmChanges) {
      if (time >= change.time) bpmVal = change.bpm;
      else break;
    }
    return bpmVal;
  }

  function drawECG() {
    if (!toggleDisplay.checked) return;
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    const currentTime = performance.now() - startTime - pausedDuration;
    const fromTime = currentTime - ecgBuffer;
    ctx.beginPath();
    ctx.moveTo(0, canvasHeight / 2);
    for (let i = 0; i < ecgData.length; i++) {
      const x = ((ecgData[i].time - fromTime) / ecgBuffer) * canvasWidth;
      const y = canvasHeight / 2 - ecgData[i].value * 80;
      if (x >= 0 && x <= canvasWidth) ctx.lineTo(x, y);
    }
    ctx.stroke();

    for (const peak of rPeaks) {
      const x = ((peak.time - fromTime) / ecgBuffer) * canvasWidth;
      if (x >= 0 && x <= canvasWidth) {
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
      }
    }

    for (const throb of throbs) {
      const x = ((throb - fromTime) / ecgBuffer) * canvasWidth;
      if (x >= 0 && x <= canvasWidth) {
        ctx.beginPath();
        ctx.strokeStyle = 'green';
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
      }
    }
    ctx.strokeStyle = 'black';
  }

  function updateECG() {
    if (!recording || isPaused) return;
    const t = performance.now() - startTime - pausedDuration;
    const value = generateECGWave(t, bpm);
    ecgData.push({ time: t, value });
    if (ecgData.length > 10000) ecgData.shift();
    detectRPeaks();
    drawECG();
    updateTimer();
  }

  function startRecording() {
    recording = true;
    isPaused = false;
    pausedDuration = 0;
    throbs = [];
    ecgData = [];
    rPeaks = [];
    bpmChanges = [];
    phaseData = [];
    startTime = performance.now();
    bpmChanges.push({ time: 0, bpm });
    scheduleNextBPMChange();
    clearInterval(timerInterval);
    timerInterval = setInterval(updateECG, 20);
  }

  function pauseResumeRecording() {
    if (!recording) return;
    if (!isPaused) {
      isPaused = true;
      pauseStart = performance.now();
    } else {
      isPaused = false;
      pausedDuration += performance.now() - pauseStart;
    }
  }

  function stopRecording() {
    recording = false;
    clearInterval(timerInterval);
    const name = prompt("Enter recording name:");
    if (!name) return;
    // Save summary or CSV here (left as-is)
    alert(`Recording "${name}" saved.`);
  }

  function markThrob() {
    if (!recording || isPaused) return;
    const t = performance.now() - startTime - pausedDuration;
    throbs.push(t);
  }

  function toggleWaveform() {
    drawECG();
  }
</script>
</body>
</html>
