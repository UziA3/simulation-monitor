<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Sync Simulator</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #121212;
    color: #eee;
  }
  #controls {
    margin-bottom: 10px;
  }
  button {
    margin-right: 10px;
    padding: 8px 14px;
    font-size: 16px;
    background: #007bff;
    border: none;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.2s ease;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  button:active {
    background: #0056b3;
  }
  #markThrobBtn {
    background: #28a745;
  }
  #markThrobBtn:active {
    background: #1e7e34;
  }
  #timer {
    font-size: 18px;
    font-weight: bold;
    display: inline-block;
    min-width: 80px;
  }
  #canvas-container {
    position: relative;
    width: 800px;
    max-width: 100%;
  }
  canvas {
    background: #000;
    display: block;
    border: 1px solid #444;
    border-radius: 6px;
  }
  #recordings {
    margin-top: 20px;
  }
  .recording-item {
    margin-bottom: 8px;
    background: #222;
    padding: 8px 12px;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .recording-name {
    font-family: monospace;
    font-size: 14px;
  }
  .download-btn {
    background: #17a2b8;
    border: none;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    font-size: 14px;
  }
  .download-btn:hover {
    background: #117a8b;
  }
  label {
    font-size: 14px;
    user-select: none;
    margin-left: 12px;
  }
</style>
</head>
<body>

<h2>Migraine Throb Sync Simulator</h2>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
  <span id="timer">0.00s</span>
  <label>
    <input type="checkbox" id="showWaveformToggle" checked /> Show Waveform
  </label>
</div>

<div id="canvas-container">
  <canvas id="ecgCanvas" width="800" height="200"></canvas>
</div>

<div id="recordings">
  <h3>Recordings</h3>
</div>

<script>
// ==== Constants & Helpers ====

const ecgCanvas = document.getElementById('ecgCanvas');
const ctx = ecgCanvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const markThrobBtn = document.getElementById('markThrobBtn');
const timerSpan = document.getElementById('timer');
const recordingsList = document.getElementById('recordings');
const showWaveformToggle = document.getElementById('showWaveformToggle');

const width = ecgCanvas.width;
const height = ecgCanvas.height;

// Heartbeat BPM parameters
const bpmMin = 60;
const bpmMax = 100;
const bpmChangeMinInterval = 3000; // 3 seconds
const bpmChangeMaxInterval = 7000; // 7 seconds

// ECG waveform parameters
const waveformDuration = 5000; // 5 seconds of data visible in ms
const samplesPerSecond = 500; // sample rate for waveform
const sampleInterval = 1000 / samplesPerSecond;

let running = false;
let paused = false;

let startTime = 0;
let pauseStart = 0;
let elapsedPauseTime = 0;
let elapsed = 0;
let lastTimestamp = 0;

let bpm = bpmMin;
let nextBpmChangeTime = 0;

let waveformSamples = []; // {time, value}
let rPeaks = []; // {time}
let throbs = []; // throb times (ms from start)

let animationFrameId = null;

let showWaveform = true;

// ==== ECG Waveform Simulation ====

function simulateEcgSample(t) {
  // t in ms from start
  // We simulate a repeating ECG waveform with synthetic peaks

  // Heartbeat interval in ms
  const hbInterval = 60000 / bpm;

  // Phase within heartbeat (0 to hbInterval)
  const phase = t % hbInterval;

  // Simple synthetic ECG shape:
  // P wave at ~0.1*hbInterval (small bump)
  // QRS complex at ~0.3*hbInterval (sharp peak)
  // T wave at ~0.6*hbInterval (medium bump)

  let val = 0;

  // P wave (small bump)
  const pCenter = 0.1 * hbInterval;
  const pWidth = 0.05 * hbInterval;
  val += 0.1 * Math.exp(-Math.pow((phase - pCenter) / pWidth, 2));

  // QRS complex (sharp peak)
  const qrsCenter = 0.3 * hbInterval;
  const qrsWidth = 0.015 * hbInterval;
  val += 1.0 * Math.exp(-Math.pow((phase - qrsCenter) / qrsWidth, 2));

  // T wave (medium bump)
  const tCenter = 0.6 * hbInterval;
  const tWidth = 0.07 * hbInterval;
  val += 0.3 * Math.exp(-Math.pow((phase - tCenter) / tWidth, 2));

  // Add small random noise
  val += (Math.random() - 0.5) * 0.05;

  return val;
}

function detectRPeaks() {
  // Detect R peaks in waveformSamples based on threshold and local maxima
  // We'll find samples where value > 0.8 and is local max

  const threshold = 0.8;
  rPeaks = [];

  for (let i = 1; i < waveformSamples.length - 1; i++) {
    const prev = waveformSamples[i - 1].value;
    const curr = waveformSamples[i].value;
    const next = waveformSamples[i + 1].value;
    if (curr > threshold && curr > prev && curr > next) {
      rPeaks.push(waveformSamples[i].time);
    }
  }
}

// ==== Circular statistics helpers ====

function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

function degToRad(deg) {
  return deg * Math.PI / 180;
}

function circularMean(angles) {
  // angles in radians
  const n = angles.length;
  let sumSin = 0;
  let sumCos = 0;
  for (const a of angles) {
    sumSin += Math.sin(a);
    sumCos += Math.cos(a);
  }
  return Math.atan2(sumSin / n, sumCos / n);
}

function phaseVectorLength(angles) {
  const n = angles.length;
  let sumSin = 0;
  let sumCos = 0;
  for (const a of angles) {
    sumSin += Math.sin(a);
    sumCos += Math.cos(a);
  }
  return Math.sqrt(sumSin * sumSin + sumCos * sumCos) / n;
}

function circularStd(angles) {
  // Circular standard deviation
  const pvl = phaseVectorLength(angles);
  if (pvl === 0) return Math.PI / Math.sqrt(3);
  return Math.sqrt(-2 * Math.log(pvl));
}

function rayleighPValue(r, n) {
  // Rayleigh test p-value approximation
  const z = n * r * r;
  if (z < 0.01) return 1.0;
  return Math.exp(-z) * (1 + (2 * z - z * z) / (4 * n) - (24 * z - 132 * z * z + 76 * z * z * z - 9 * z * z * z * z) / (288 * n * n));
}

// ==== Phase Computation ====

function computeThrobPhases() {
  // For each throb time, find the most recent prior R peak
  // Compute delta time from R peak to throb in ms
  // Convert delta to phase (radians) assuming heartbeat interval at that R peak

  let phaseData = [];

  if (rPeaks.length === 0 || throbs.length === 0) return phaseData;

  for (const throbTime of throbs) {
    // Find prior R peak
    let priorPeakTime = null;
    for (let i = rPeaks.length - 1; i >= 0; i--) {
      if (rPeaks[i] <= throbTime) {
        priorPeakTime = rPeaks[i];
        break;
      }
    }
    if (priorPeakTime === null) continue; // no prior peak

    // Find next peak after priorPeakTime to estimate heartbeat interval
    let nextPeakTime = null;
    for (let i = 0; i < rPeaks.length; i++) {
      if (rPeaks[i] > priorPeakTime) {
        nextPeakTime = rPeaks[i];
        break;
      }
    }
    if (nextPeakTime === null) {
      // No next peak, approximate with last bpm
      nextPeakTime = priorPeakTime + 60000 / bpm;
    }

    const hbInterval = nextPeakTime - priorPeakTime;

    const deltaMs = throbTime - priorPeakTime;

    const phaseRad = 2 * Math.PI * (deltaMs / hbInterval);

    // Get BPM at that peak (approximate)
    const bpmAtPeak = 60000 / hbInterval;

    phaseData.push({
      throbTime,
      priorPeakTime,
      deltaMs,
      bpmAtPeak: bpmAtPeak.toFixed(1),
      phaseRad,
    });
  }

  return phaseData;
}

// ==== Drawing ====

function drawWaveform() {
  ctx.clearRect(0, 0, width, height);

  if (!showWaveform) return;

  // Draw baseline
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, height / 2);
  ctx.lineTo(width, height / 2);
  ctx.stroke();

  // Draw waveform (green)
  ctx.strokeStyle = '#00ff00';
  ctx.lineWidth = 2;
  ctx.beginPath();

  const now = elapsed;
  const startWindow = now - waveformDuration;

  for (let i = 0; i < waveformSamples.length; i++) {
    const sample = waveformSamples[i];
    if (sample.time < startWindow) continue;

    const x = ((sample.time - startWindow) / waveformDuration) * width;
    const y = height / 2 - sample.value * 80;

    if (i === 0 || waveformSamples[i-1].time < startWindow) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();

  // Draw R peaks (red dots)
  ctx.fillStyle = '#ff0000';
  for (const rTime of rPeaks) {
    if (rTime < startWindow) continue;
    const x = ((rTime - startWindow) / waveformDuration) * width;
    const y = height / 2 - 80; // peak top
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fill();
  }

  // Draw throbs (green vertical lines)
  ctx.strokeStyle = '#28a745';
  ctx.lineWidth = 2;
  for (const tTime of throbs) {
    if (tTime < startWindow) continue;
    const x = ((tTime - startWindow) / waveformDuration) * width;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }
}

// ==== BPM random fluctuation ====

function scheduleNextBpmChange(now) {
  const interval = bpmChangeMinInterval + Math.random() * (bpmChangeMaxInterval - bpmChangeMinInterval);
  nextBpmChangeTime = now + interval;
}

function updateBpm(now) {
  if (now >= nextBpmChangeTime) {
    bpm = bpmMin + Math.random() * (bpmMax - bpmMin);
    bpm = Math.round(bpm);
    scheduleNextBpmChange(now);
  }
}

// ==== Timer update ====

function updateTimer() {
  // Show elapsed in seconds.milliseconds (2 decimals)
  if (!running) {
    timerSpan.textContent = '0.00s';
    return;
  }
  const elapsedMs = elapsed;
  const seconds = Math.floor(elapsedMs / 1000);
  const ms = elapsedMs % 1000;
  const display = (seconds + ms / 1000).toFixed(2) + 's';
  timerSpan.textContent = display;
}

// ==== Animation Loop ====

function animate(timestamp) {
  if (!running) return;

  if (lastTimestamp === 0) lastTimestamp = timestamp;
  const dt = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  if (!paused) {
    elapsed = performance.now() - startTime - elapsedPauseTime;

    // Update BPM if needed
    updateBpm(elapsed);

    // Add new samples based on elapsed time
    const lastSampleTime = waveformSamples.length > 0 ? waveformSamples[waveformSamples.length - 1].time : 0;
    while (lastSampleTime + sampleInterval < elapsed) {
      const t = lastSampleTime + sampleInterval;
      const val = simulateEcgSample(t);
      waveformSamples.push({ time: t, value: val });
    }

    // Keep samples within rolling window
    waveformSamples = waveformSamples.filter(s => s.time >= elapsed - waveformDuration);

    // Detect R peaks in current window
    detectRPeaks();

    // Draw waveform and indicators
    drawWaveform();

    updateTimer();
  }

  animationFrameId = requestAnimationFrame(animate);
}

// ==== Button Handlers ====

function startRecording() {
  if (running) return;

  // Reset all data
  running = true;
  paused = false;
  elapsed = 0;
  elapsedPauseTime = 0;
  startTime = performance.now();
  lastTimestamp = 0;

  waveformSamples = [];
  rPeaks = [];
  throbs = [];

  bpm = bpmMin + Math.random() * (bpmMax - bpmMin);
  bpm = Math.round(bpm);
  scheduleNextBpmChange(0);

  // UI
  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  markThrobBtn.disabled = false;

  animate();
}

function pauseRecording() {
  if (!running || paused) return;
  paused = true;
  pauseStart = performance.now();

  // UI
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  markThrobBtn.disabled = true;
}

function resumeRecording() {
  if (!running || !paused) return;
  paused = false;
  const pauseEnd = performance.now();
  elapsedPauseTime += (pauseEnd - pauseStart);

  // UI
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  markThrobBtn.disabled = false;
}

function stopRecording() {
  if (!running) return;

  running = false;
  paused = false;

  cancelAnimationFrame(animationFrameId);

  // UI
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  markThrobBtn.disabled = true;

  updateTimer();

  // Save the recording data
  saveRecording();
}

// User presses "Mark Throb" at any time (no R peak restriction)
function markThrob() {
  if (!running || paused) return;
  const t = elapsed;
  throbs.push(t);

  // Quick button flash for feedback
  markThrobBtn.style.backgroundColor = '#28a745';
  setTimeout(() => {
    markThrobBtn.style.backgroundColor = '#007bff';
  }, 150);
}

// Save recording to local and display in list
function saveRecording() {
  // Compute phases
  const phaseData = computeThrobPhases();

  // Prepare CSV content with headers
  let csvContent = 'ThrobTime_ms,PriorRPeakTime_ms,DeltaFromRPeak_ms,BPMatPeak,Phase_radians,Phase_degrees\n';
  for (const d of phaseData) {
    csvContent += `${d.throbTime.toFixed(1)},${d.priorPeakTime.toFixed(1)},${d.deltaMs.toFixed(1)},${d.bpmAtPeak},${d.phaseRad.toFixed(4)},${radToDeg(d.phaseRad).toFixed(1)}\n`;
  }

  // Compute circular stats for phases
  const angles = phaseData.map(d => d.phaseRad);
  const n = angles.length;
  if (n > 0) {
    const meanPhase = circularMean(angles);
    const pvl = phaseVectorLength(angles);
    const stdPhase = circularStd(angles);
    const pRayleigh = rayleighPValue(pvl, n);

    csvContent += '\n';
    csvContent += `Number of throbs,${n}\n`;
    csvContent += `Mean phase (radians),${meanPhase.toFixed(4)}\n`;
    csvContent += `Mean phase (degrees),${radToDeg(meanPhase).toFixed(1)}\n`;
    csvContent += `Phase vector length,R=${pvl.toFixed(4)}\n`;
    csvContent += `Circular standard deviation (radians),${stdPhase.toFixed(4)}\n`;
    csvContent += `Rayleigh test p-value,${pRayleigh.toExponential(4)}\n`;
  } else {
    csvContent += '\nNo throbs recorded or no matching R peaks found.\n';
  }

  // Create a filename with timestamp
  const nowDate = new Date();
  const timestampStr = nowDate.toISOString().replace(/:/g, '-').replace(/\..+/, '');
  const filename = `migraine_throb_sync_${timestampStr}.csv`;

  // Create a blob and download link
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);

  // Add to recordings list UI
  const recItem = document.createElement('div');
  recItem.className = 'recording-item';

  const nameSpan = document.createElement('span');
  nameSpan.className = 'recording-name';
  nameSpan.textContent = filename;

  const dlBtn = document.createElement('button');
  dlBtn.className = 'download-btn';
  dlBtn.textContent = 'Download CSV';
  dlBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
  };

  recItem.appendChild(nameSpan);
  recItem.appendChild(dlBtn);
  recordingsList.appendChild(recItem);
}

// ==== Event Listeners ====

startBtn.addEventListener('click', startRecording);
pauseBtn.addEventListener('click', pauseRecording);
resumeBtn.addEventListener('click', resumeRecording);
stopBtn.addEventListener('click', stopRecording);
markThrobBtn.addEventListener('click', markThrob);

showWaveformToggle.addEventListener('change', (e) => {
  showWaveform = e.target.checked;
  drawWaveform();
});

// ==== Initial ====

updateTimer();
drawWaveform();

</script>
</body>
</html>
