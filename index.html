<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    text-align: center;
    margin-bottom: 10px;
  }
  button {
    margin: 0 5px;
    padding: 8px 16px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background: #ddd;
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
  #timer {
    font-size: 1.2rem;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
  }
  #canvasContainer {
    text-align: center;
    margin-bottom: 15px;
  }
  canvas {
    border: 1px solid #aaa;
    background: #fff;
  }
  #showWaveformLabel {
    display: block;
    text-align: center;
    margin-bottom: 15px;
  }
  #recordingsList {
    margin-top: 20px;
  }
  .recording-item {
    margin-bottom: 10px;
  }
  .recording-name {
    font-weight: bold;
    margin-right: 10px;
  }
  .download-btn {
    padding: 4px 10px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  .download-btn:hover {
    background: #ddd;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
</div>

<div id="timer">0.00s</div>

<label id="showWaveformLabel">
  <input type="checkbox" id="showWaveformToggle" checked /> Show Waveform
</label>

<div id="canvasContainer">
  <canvas id="ecgCanvas" width="800" height="200"></canvas>
</div>

<div id="recordingsList"></div>

<script>
(() => {
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const timerEl = document.getElementById('timer');
  const showWaveformToggle = document.getElementById('showWaveformToggle');
  const recordingsList = document.getElementById('recordingsList');

  const waveformDuration = 5000; // 5 seconds window shown on canvas
  const sampleRate = 250; // Hz
  const sampleInterval = 1000 / sampleRate; // ms

  function ecgWaveform(tNorm) {
    const p = 0.1, pWidth = 0.07, pAmp = 0.15;
    const q = 0.2, qWidth = 0.01, qAmp = -0.25;
    const r = 0.22, rWidth = 0.015, rAmp = 1.0;
    const s = 0.26, sWidth = 0.01, sAmp = -0.35;
    const t = 0.4, tWidth = 0.1, tAmp = 0.3;

    const pWave = pAmp * Math.exp(-((tNorm - p) ** 2) / (2 * pWidth ** 2));
    const qWave = qAmp * Math.exp(-((tNorm - q) ** 2) / (2 * qWidth ** 2));
    const rWave = rAmp * Math.exp(-((tNorm - r) ** 2) / (2 * rWidth ** 2));
    const sWave = sAmp * Math.exp(-((tNorm - s) ** 2) / (2 * sWidth ** 2));
    const tWave = tAmp * Math.exp(-((tNorm - t) ** 2) / (2 * tWidth ** 2));

    return pWave + qWave + rWave + sWave + tWave;
  }

  let running = false;
  let paused = false;
  let startTime = 0;
  let elapsedPauseTime = 0;
  let pauseStartTime = 0;
  let elapsed = 0;
  let animationFrameId = 0;

  let waveformSamples = [];
  let rPeaks = [];
  let throbs = [];

  let currentBpm = 75;
  let bpmChangeTime = 0;
  let nextBpmChangeInterval = 0;

  let showWaveform = true;

  function randomInterval() {
    return 3000 + Math.random() * 4000;
  }
  function randomBpm() {
    return 60 + Math.floor(Math.random() * 41);
  }
  function bpmToMs(bpm) {
    return 60000 / bpm;
  }
  function simulateEcgSample(elapsedMs) {
    let elapsedSinceBpmChange = elapsedMs - bpmChangeTime;
    let beatInterval = bpmToMs(currentBpm);
    let beatPos = (elapsedSinceBpmChange % beatInterval) / beatInterval;
    return ecgWaveform(beatPos);
  }

  function detectRPeaks() {
    const minDistance = 400;
    let lastPeakTime = rPeaks.length > 0 ? rPeaks[rPeaks.length - 1].time : -Infinity;

    for (let i = 1; i < waveformSamples.length - 1; i++) {
      let s = waveformSamples[i];
      if (
        s.value > 0.8 &&
        s.value > waveformSamples[i - 1].value &&
        s.value > waveformSamples[i + 1].value &&
        s.time > lastPeakTime + minDistance
      ) {
        let bpmAtPeak = currentBpm;
        rPeaks.push({ time: s.time, value: s.value, bpm: bpmAtPeak });
        lastPeakTime = s.time;
      }
    }

    // Remove old peaks outside the window (plus some margin)
    rPeaks = rPeaks.filter(rp => rp.time >= elapsed - waveformDuration - 1000);
  }

  function drawWaveform() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!showWaveform) return;

    const midY = canvas.height / 2;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, midY);
    ctx.lineTo(canvas.width, midY);
    ctx.stroke();

    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;
    ctx.beginPath();

    const tStart = elapsed - waveformDuration;
    const tEnd = elapsed;

    for (let i = 0; i < waveformSamples.length; i++) {
      const s = waveformSamples[i];
      if (s.time < tStart) continue;
      if (s.time > tEnd) break;

      const x = ((s.time - tStart) / waveformDuration) * canvas.width;
      const y = midY - s.value * 70;
      if (i === 0 || waveformSamples[i - 1].time < tStart) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();

    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    rPeaks.forEach(rp => {
      if (rp.time >= tStart && rp.time <= tEnd) {
        const x = ((rp.time - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
    });

    ctx.strokeStyle = 'green';
    ctx.lineWidth = 2;
    throbs.forEach(throb => {
      if (throb >= tStart && throb <= tEnd) {
        const x = ((throb - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
    });
  }

  function formatTime(ms) {
    return (ms / 1000).toFixed(2) + 's';
  }

  function updateTimer() {
    if (!running || paused) return;
    elapsed = performance.now() - startTime - elapsedPauseTime;
    timerEl.textContent = formatTime(elapsed);
  }

  function animationStep(timestamp) {
    if (!running || paused) {
      animationFrameId = requestAnimationFrame(animationStep);
      return;
    }

    elapsed = timestamp - startTime - elapsedPauseTime;

    if (elapsed - bpmChangeTime > nextBpmChangeInterval) {
      bpmChangeTime = elapsed;
      currentBpm = randomBpm();
      nextBpmChangeInterval = randomInterval();
    }

    let lastSampleTime = waveformSamples.length > 0 ? waveformSamples[waveformSamples.length - 1].time : -sampleInterval;
    while (lastSampleTime + sampleInterval < elapsed) {
      lastSampleTime += sampleInterval;
      waveformSamples.push({ time: lastSampleTime, value: simulateEcgSample(lastSampleTime) });
    }

    detectRPeaks();

    drawWaveform();
    updateTimer();

    animationFrameId = requestAnimationFrame(animationStep);
  }

  function startRecording() {
    if (running) return;

    running = true;
    paused = false;
    startTime = performance.now();
    elapsedPauseTime = 0;
    waveformSamples = [];
    rPeaks = [];
    throbs = [];
    currentBpm = randomBpm();
    bpmChangeTime = 0;
    nextBpmChangeInterval = randomInterval();

    waveformSamples.push({ time: 0, value: simulateEcgSample(0) });

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    markThrobBtn.disabled = false;

    animationFrameId = requestAnimationFrame(animationStep);
  }

  function pauseRecording() {
    if (!running || paused) return;
    paused = true;
    pauseStartTime = performance.now();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
  }

  function resumeRecording() {
    if (!running || !paused) return;
    paused = false;
    elapsedPauseTime += performance.now() - pauseStartTime;

    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
  }

  function stopRecording() {
    if (!running) return;

    running = false;
    paused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    markThrobBtn.disabled = true;

    cancelAnimationFrame(animationFrameId);

    saveRecording();
  }

  function markThrob() {
    if (!running || paused) return;
    throbs.push(elapsed);
  }

  // Circular stats helper functions
  function degToRad(deg) { return (deg * Math.PI) / 180; }
  function radToDeg(rad) { return (rad * 180) / Math.PI; }
  function meanAngle(angles) {
    let x = 0, y = 0;
    angles.forEach(a => {
      x += Math.cos(a);
      y += Math.sin(a);
    });
    return Math.atan2(y, x);
  }
  function vectorLength(angles) {
    let x = 0, y = 0;
    angles.forEach(a => {
      x += Math.cos(a);
      y += Math.sin(a);
    });
    x /= angles.length;
    y /= angles.length;
    return Math.sqrt(x * x + y * y);
  }
  function rayleighPValue(R, n) {
    if (n === 0) return 1;
    const z = n * R * R;
    if (z > 100) return 0;
    return Math.exp(-z) * (1 + (2 * z - z * z) / (4 * n) - (24 * z - 132 * z * z + 76 * z * z * z - 9 * z * z * z * z) / (288 * n * n));
  }
  function stdDev(arr) {
    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
    const variance = arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
    return Math.sqrt(variance);
  }

  function saveRecording() {
    const recName = prompt('Enter recording name:', `Recording_${new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-')}`);
    if (!recName) return;

    // Associate each throb with immediately preceding R peak (not nearest)
    // For phase, find next R peak after preceding R peak, then calculate normalized phase
    const throbData = throbs.map(throbTime => {
      // Find preceding R peak
      const precedingPeaks = rPeaks.filter(rp => rp.time <= throbTime);
      if (precedingPeaks.length === 0) return null; // no preceding peak
      const priorPeak = precedingPeaks[precedingPeaks.length - 1];
      // Find next peak after priorPeak
      const followingPeaks = rPeaks.filter(rp => rp.time > priorPeak.time);
      const nextPeak = followingPeaks.length > 0 ? followingPeaks[0] : null;

      const delta = throbTime - priorPeak.time; // ms
      let phase = 0;
      if (nextPeak) {
        const interval = nextPeak.time - priorPeak.time;
        if (interval > 0) {
          phase = (delta / interval) * 2 * Math.PI;
        }
      }
      return {
        throbTime,
        priorPeakTime: priorPeak.time,
        delta,
        bpm: priorPeak.bpm,
        phase,
      };
    }).filter(x => x !== null);

    // Mean BPM across all R peaks
    const meanBpm = rPeaks.length > 0 ? rPeaks.reduce((a, r) => a + r.bpm, 0) / rPeaks.length : 0;

    // Rayleigh test on phases
    const phases = throbData.map(d => d.phase);
    const R = vectorLength(phases);
    const n = phases.length;
    const pValueRaw = rayleighPValue(R, n);
    const pValue = pValueRaw < 0.001 ? '<0.001' : pValueRaw.toFixed(3);

    // PVL (phase vector length) = same as R here
    const PVL = R;

    // Mean vector angle in radians
    const meanVecAngle = meanAngle(phases);

    // Std dev of delta times (ms)
    const deltaStdDev = throbData.length > 0 ? stdDev(throbData.map(d => d.delta)) : 0;

    // CSV content generation
    let csv = '';
    csv += `Recording Name:,${recName}\n`;
    csv += `Total Throb Count:,${throbData.length}\n`;
    csv += `Total Pulse Peak Count:,${rPeaks.length}\n`;
    csv += `Mean Pulse Rate (BPM):,${meanBpm.toFixed(2)}\n`;
    csv += `Rayleigh R:,${R.toFixed(4)}\n`;
    csv += `Rayleigh p-value:,${pValue}\n`;
    csv += `PVL:,${PVL.toFixed(4)}\n`;
    csv += `Std Dev of Deltas (ms):,${deltaStdDev.toFixed(2)}\n`;
    csv += `Mean Vector Angle (rad):,${meanVecAngle.toFixed(4)}\n\n`;

    csv += 'Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)\n';
    throbData.forEach(d => {
      csv += `${d.throbTime.toFixed(2)},${d.priorPeakTime.toFixed(2)},${d.delta.toFixed(2)},${d.bpm},${d.phase.toFixed(4)}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    const div = document.createElement('div');
    div.className = 'recording-item';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'recording-name';
    nameSpan.textContent = recName;

    const downloadBtn = document.createElement('a');
    downloadBtn.className = 'download-btn';
    downloadBtn.href = url;
    downloadBtn.download = recName + '.csv';
    downloadBtn.textContent = 'Download CSV';

    div.appendChild(nameSpan);
    div.appendChild(downloadBtn);
    recordingsList.appendChild(div);

    alert('Recording saved!');
  }

  startBtn.addEventListener('click', startRecording);
  pauseBtn.addEventListener('click', pauseRecording);
  resumeBtn.addEventListener('click', resumeRecording);
  stopBtn.addEventListener('click', stopRecording);
  markThrobBtn.addEventListener('click', markThrob);
  showWaveformToggle.addEventListener('change', () => {
    showWaveform = showWaveformToggle.checked;
    drawWaveform();
  });
})();
</script>
</body>
</html>
