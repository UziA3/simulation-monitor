<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; margin-bottom: 10px; }
  button, label { margin: 5px; }
  .stats { margin-top: 10px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<!-- Pulse waveform canvas -->
<canvas id="pulseCanvas" width="800" height="200"></canvas><br>

<!-- Rose plot -->
<canvas id="phaseHistogramCanvas" width="300" height="300"></canvas>
<!-- Cross correlation -->
<canvas id="crossCorrelationCanvas" width="300" height="150"></canvas>
<!-- Phase scatter plot -->
<canvas id="phaseScatterCanvas" width="300" height="300"></canvas>

<br>

<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<div class="controls">
  <button id="toggleAllBtn">Hide All Stats & Markings & Waveform</button>
</div>

<div class="stats" id="metricsDisplay"></div>

<script>
(() => {
  // Canvas and contexts
  const pulseCanvas = document.getElementById("pulseCanvas");
  const pulseCtx = pulseCanvas.getContext("2d");

  const phaseHistogramCanvas = document.getElementById("phaseHistogramCanvas");
  const phaseHistCtx = phaseHistogramCanvas.getContext("2d");

  const crossCorrelationCanvas = document.getElementById("crossCorrelationCanvas");
  const crossCorrCtx = crossCorrelationCanvas.getContext("2d");

  const phaseScatterCanvas = document.getElementById("phaseScatterCanvas");
  const phaseScatterCtx = phaseScatterCanvas.getContext("2d");

  // Controls and displays
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const toggleAllBtn = document.getElementById("toggleAllBtn");

  // Variables
  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;

  // Toggle flag
  let displayAll = true;

  // Constants for waveform simulation
  const DISPLAY_DURATION = 20000; // 20 seconds window on canvas
  const SAMPLE_INTERVAL = 20; // 20 ms per sample
  const BASELINE = 100;
  const AMPLITUDE = 50;
  const FREQ = 1.2; // frequency in Hz (approx 72 bpm)

  // Simulate pulse waveform (sine wave + noise)
  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const noise = (Math.random() - 0.5) * 5;
      const value = BASELINE + AMPLITUDE * Math.sin(2 * Math.PI * FREQ * t) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    // Keep last 5 minutes data max
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  // Draw waveform, throbs, peaks
  function draw() {
    simulatePulse();

    pulseCtx.clearRect(0, 0, pulseCanvas.width, pulseCanvas.height);

    if (!displayAll) {
      // If hidden, do not draw anything
      if (isRecording && !isPaused) animationId = requestAnimationFrame(draw);
      return;
    }

    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    // Draw waveform line
    pulseCtx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * pulseCanvas.width;
      const y = pulseCanvas.height - p.value;
      if (i === 0) pulseCtx.moveTo(x, y);
      else pulseCtx.lineTo(x, y);
    });
    pulseCtx.strokeStyle = "blue";
    pulseCtx.lineWidth = 2;
    pulseCtx.stroke();

    // Draw throbs (red circles)
    throbs.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValue(throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * pulseCanvas.width;
      const y = pulseCanvas.height - val;
      pulseCtx.beginPath();
      pulseCtx.arc(x, y, 5, 0, 2 * Math.PI);
      pulseCtx.fillStyle = "red";
      pulseCtx.fill();
    });

    // Draw peaks (green circles)
    const peaks = findPeaks();
    peaks.forEach(peakTime => {
      if (peakTime < start || peakTime > now) return;
      const val = interpolatePulseValue(peakTime);
      if (val === null) return;
      const x = ((peakTime - start) / DISPLAY_DURATION) * pulseCanvas.width;
      const y = pulseCanvas.height - val;
      pulseCtx.beginPath();
      pulseCtx.arc(x, y, 4, 0, 2 * Math.PI);
      pulseCtx.fillStyle = "green";
      pulseCtx.fill();
    });

    if (isRecording && !isPaused) animationId = requestAnimationFrame(draw);
  }

  // Interpolate pulse value at time t
  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  // Detect peaks (local maxima)
  function findPeaks() {
    const peaks = [];
    const values = pulseWave.map(p => p.value);
    for (let i = 1; i < values.length - 1; i++) {
      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {
        peaks.push(pulseWave[i].time);
      }
    }
    return peaks;
  }

  // Calculate phase of time t relative to surrounding peaks
  function calculatePhase(t) {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;

    let prevPeak = null, nextPeak = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prevPeak = peaks[i];
        nextPeak = peaks[i + 1];
        break;
      }
    }
    if (prevPeak === null || nextPeak === null) return null;

    const phase = 2 * Math.PI * (t - prevPeak) / (nextPeak - prevPeak);
    return normalizeAngle(phase);
  }

  // Normalize angle to [0, 2Ï€)
  function normalizeAngle(angle) {
    let a = angle % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  // Circular mean of angles (radians)
  function circularMean(angles) {
    if (angles.length === 0) return null;
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    let mean = Math.atan2(sumSin, sumCos);
    mean = normalizeAngle(mean);
    return mean;
  }

  // Circular variance (0 to 1)
  function circularVariance(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    ) / n;
    return 1 - R;
  }

  // Rayleigh test p-value for non-uniformity
  function rayleighTest(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    );
    const z = (R * R) / n;
    return Math.exp(-z);
  }

  // Calculate PLV and related stats from throbs
  function calculatePLV() {
    // Assign phases to each throb:
    throbs.forEach(throb => {
      throb.phase = calculatePhase(throb.time);
    });

    const validPhases = throbs.filter(t => t.phase !== null).map(t => t.phase);
    if (validPhases.length === 0) return null;

    // PLV is the length of the mean resultant vector of phase angles
    const sumSin = validPhases.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = validPhases.reduce((acc, a) => acc + Math.cos(a), 0);
    const R = Math.sqrt(sumSin * sumSin + sumCos * sumCos) / validPhases.length;

    const meanPhase = circularMean(validPhases);
    const variance = circularVariance(validPhases);
    const pVal = rayleighTest(validPhases);

    return {
      plv: R,
      meanPhase,
      variance,
      rayleighP: pVal,
      count: validPhases.length
    };
  }

  // Draw rose plot (phase histogram)
  function drawRosePlot() {
    phaseHistCtx.clearRect(0, 0, phaseHistogramCanvas.width, phaseHistogramCanvas.height);

    if (!displayAll || throbs.length === 0) return;

    const centerX = phaseHistogramCanvas.width / 2;
    const centerY = phaseHistogramCanvas.height / 2;
    const radius = Math.min(centerX, centerY) - 20;
    const bins = 16;
    const binCounts = new Array(bins).fill(0);

    // Count throbs in phase bins
    throbs.forEach(t => {
      if (t.phase !== null) {
        let bin = Math.floor((t.phase / (2 * Math.PI)) * bins);
        bin = bin >= bins ? bins - 1 : bin;
        binCounts[bin]++;
      }
    });

    const maxCount = Math.max(...binCounts, 1);

    // Draw bins as bars around circle
    for (let i = 0; i < bins; i++) {
      const angle = (i / bins) * 2 * Math.PI;
      const length = (binCounts[i] / maxCount) * radius;

      phaseHistCtx.beginPath();
      phaseHistCtx.moveTo(centerX + Math.cos(angle) * 30, centerY + Math.sin(angle) * 30);
      phaseHistCtx.lineTo(centerX + Math.cos(angle) * (30 + length), centerY + Math.sin(angle) * (30 + length));
      phaseHistCtx.lineWidth = 8;
      phaseHistCtx.strokeStyle = "purple";
      phaseHistCtx.stroke();
    }

    // Draw outer circle
    phaseHistCtx.beginPath();
    phaseHistCtx.arc(centerX, centerY, radius + 30, 0, 2 * Math.PI);
    phaseHistCtx.strokeStyle = "#aaa";
    phaseHistCtx.lineWidth = 1;
    phaseHistCtx.stroke();

    // Center dot
    phaseHistCtx.beginPath();
    phaseHistCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
    phaseHistCtx.fillStyle = "black";
    phaseHistCtx.fill();
  }

  // Draw cross correlation plot (throbs vs pulse peaks)
  function drawCrossCorrelation() {
    crossCorrCtx.clearRect(0, 0, crossCorrelationCanvas.width, crossCorrelationCanvas.height);

    if (!displayAll || throbs.length === 0) return;

    // Cross-correlation time lags between throbs and pulse peaks
    const peaks = findPeaks();
    const lags = [];

    throbs.forEach(t => {
      peaks.forEach(p => {
        const lag = (t.time - p);
        if (lag > -5000 && lag < 5000) lags.push(lag);
      });
    });

    // Histogram bins for lags (-5000 ms to 5000 ms)
    const bins = 50;
    const binSize = 10000 / bins; // ms per bin
    const counts = new Array(bins).fill(0);

    lags.forEach(lag => {
      let bin = Math.floor((lag + 5000) / binSize);
      if (bin >= 0 && bin < bins) counts[bin]++;
    });

    const maxCount = Math.max(...counts, 1);

    // Draw histogram bars
    for (let i = 0; i < bins; i++) {
      const x = (i / bins) * crossCorrelationCanvas.width;
      const barHeight = (counts[i] / maxCount) * crossCorrelationCanvas.height;
      crossCorrCtx.fillStyle = "orange";
      crossCorrCtx.fillRect(x, crossCorrelationCanvas.height - barHeight, crossCorrelationCanvas.width / bins - 1, barHeight);
    }

    // Center line at zero lag
    const zeroX = ((0 + 5000) / 10000) * crossCorrelationCanvas.width;
    crossCorrCtx.strokeStyle = "black";
    crossCorrCtx.beginPath();
    crossCorrCtx.moveTo(zeroX, 0);
    crossCorrCtx.lineTo(zeroX, crossCorrelationCanvas.height);
    crossCorrCtx.stroke();
  }

  // Draw interactive phase scatter plot
  function drawPhaseScatter() {
    phaseScatterCtx.clearRect(0, 0, phaseScatterCanvas.width, phaseScatterCanvas.height);

    if (!displayAll || throbs.length === 0) return;

    const margin = 40;
    const width = phaseScatterCanvas.width - margin * 2;
    const height = phaseScatterCanvas.height - margin * 2;

    // Axes: time (ms since recording start) vs phase [0, 2Ï€]
    phaseScatterCtx.strokeStyle = "black";
    phaseScatterCtx.beginPath();
    // X axis
    phaseScatterCtx.moveTo(margin, phaseScatterCanvas.height - margin);
    phaseScatterCtx.lineTo(phaseScatterCanvas.width - margin, phaseScatterCanvas.height - margin);
    // Y axis
    phaseScatterCtx.moveTo(margin, margin);
    phaseScatterCtx.lineTo(margin, phaseScatterCanvas.height - margin);
    phaseScatterCtx.stroke();

    // Labels
    phaseScatterCtx.font = "12px Arial";
    phaseScatterCtx.fillStyle = "black";
    phaseScatterCtx.fillText("Time (ms)", phaseScatterCanvas.width / 2, phaseScatterCanvas.height - 10);
    phaseScatterCtx.save();
    phaseScatterCtx.translate(10, phaseScatterCanvas.height / 2);
    phaseScatterCtx.rotate(-Math.PI / 2);
    phaseScatterCtx.fillText("Phase (rad)", 0, 0);
    phaseScatterCtx.restore();

    if (!recordingStartTime) return;

    // Calculate relative times and plot points
    const times = throbs.map(t => t.time - recordingStartTime);
    const phases = throbs.map(t => t.phase);

    const maxTime = Math.max(...times, 1);

    for (let i = 0; i < throbs.length; i++) {
      if (phases[i] === null) continue;
      const x = margin + (times[i] / maxTime) * width;
      const y = phaseScatterCanvas.height - margin - (phases[i] / (2 * Math.PI)) * height;

      phaseScatterCtx.beginPath();
      phaseScatterCtx.arc(x, y, 4, 0, 2 * Math.PI);
      phaseScatterCtx.fillStyle = "teal";
      phaseScatterCtx.fill();
    }
  }

  // Update all metrics & redraw plots
  function updateMetrics() {
    if (!displayAll) {
      metricsDisplay.innerHTML = "";
      return;
    }
    if (throbs.length === 0) {
      metricsDisplay.innerHTML = "<em>No throbs recorded yet.</em>";
      phaseHistCtx.clearRect(0, 0, phaseHistogramCanvas.width, phaseHistogramCanvas.height);
      crossCorrCtx.clearRect(0, 0, crossCorrelationCanvas.width, crossCorrelationCanvas.height);
      phaseScatterCtx.clearRect(0, 0, phaseScatterCanvas.width, phaseScatterCanvas.height);
      return;
    }

    // Calculate PLV and stats
    const stats = calculatePLV();
    if (!stats) {
      metricsDisplay.innerHTML = "<em>Not enough data for statistics.</em>";
      return;
    }

    const pValStr = stats.rayleighP < 0.0001 ? "<0.0001" : stats.rayleighP.toFixed(4);

    metricsDisplay.innerHTML = `
      <strong>Overall Recording Stats</strong><br>
      Number of throbs: ${stats.count}<br>
      PLV (Phase Locking Value): ${stats.plv.toFixed(4)}<br>
      Mean Phase (rad): ${stats.meanPhase.toFixed(4)}<br>
      Circular Variance: ${stats.variance.toFixed(4)}<br>
      Rayleigh p-value: ${pValStr}
    `;

    // Draw rose plot
    drawRosePlot();

    // Draw cross correlation
    drawCrossCorrelation();

    // Draw phase scatter
    drawPhaseScatter();
  }

  // Timer update
  function updateTimer() {
    if (!recordingStartTime) return;
    const elapsed = performance.now() - recordingStartTime;
    const seconds = Math.floor(elapsed / 1000);
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    timerDisplay.textContent = `${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }

  // Start recording
  startBtn.onclick = () => {
    if (isRecording) return;
    isRecording = true;
    isPaused = false;
    throbs.length = 0;
    pulseWave.length = 0;
    recordingStartTime = performance.now();
    updateTimer();
    timerInterval = setInterval(updateTimer, 200);
    draw();
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    updateMetrics();
  };

  // Pause recording
  pauseBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    clearInterval(timerInterval);
    if (animationId) cancelAnimationFrame(animationId);
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    updateMetrics();
  };

  // Resume recording
  resumeBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    timerInterval = setInterval(updateTimer, 200);
    draw();
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    updateMetrics();
  };

  // Stop recording
  stopBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    clearInterval(timerInterval);
    if (animationId) cancelAnimationFrame(animationId);
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    updateMetrics();
  };

  // Mark a throb
  throbBtn.onclick = () => {
    if (!isRecording) return;
    const now = performance.now();
    throbs.push({ time: now });
    updateMetrics();
  };

  // Toggle all stats/markings/waveform visibility
  toggleAllBtn.onclick = () => {
    displayAll = !displayAll;
    toggleAllBtn.textContent = displayAll
      ? "Hide All Stats & Markings & Waveform"
      : "Show All Stats & Markings & Waveform";

    if (displayAll) {
      // Show stats and redraw plots with current data
      updateMetrics();

      // If recording is active and not paused, start drawing waveform loop again
      if (isRecording && !isPaused) {
        draw();
      }
    } else {
      // Hide all visuals and clear canvases and stats
      pulseCtx.clearRect(0, 0, pulseCanvas.width, pulseCanvas.height);
      phaseHistCtx.clearRect(0, 0, phaseHistogramCanvas.width, phaseHistogramCanvas.height);
      crossCorrCtx.clearRect(0, 0, crossCorrelationCanvas.width, crossCorrelationCanvas.height);
      phaseScatterCtx.clearRect(0, 0, phaseScatterCanvas.width, phaseScatterCanvas.height);
      metricsDisplay.innerHTML = "";
    }
  };

})();
</script>

</body>
</html>
