<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0; padding: 1rem;
    display: flex; flex-direction: column; align-items: center;
  }
  h1 {
    margin-bottom: 0.5rem;
  }
  #controls {
    margin-bottom: 1rem;
    display: flex; gap: 0.5rem; flex-wrap: wrap;
  }
  button {
    background-color: #007bff;
    border: none;
    color: white;
    padding: 0.5rem 1rem;
    cursor: pointer;
    font-weight: 600;
    border-radius: 4px;
    user-select: none;
    transition: background-color 0.3s;
  }
  button:hover:not(:disabled) {
    background-color: #0056b3;
  }
  button:disabled {
    background-color: #444;
    cursor: default;
  }
  #timer {
    font-family: monospace;
    font-size: 1.2rem;
    margin-left: 1rem;
    user-select: none;
  }
  #canvas-container {
    position: relative;
    border: 1px solid #333;
    background-color: #000;
    width: 800px;
    height: 200px;
    user-select: none;
  }
  canvas {
    display: block;
  }
  #recordings-list {
    margin-top: 1rem;
    width: 800px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #333;
    padding: 0.5rem;
    background-color: #222;
    border-radius: 4px;
  }
  .recording-item {
    margin-bottom: 0.75rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #444;
  }
  .recording-name {
    font-weight: 700;
    margin-bottom: 0.25rem;
  }
  .download-btn {
    background-color: #28a745;
    border: none;
    color: white;
    padding: 0.25rem 0.5rem;
    font-size: 0.9rem;
    border-radius: 4px;
    cursor: pointer;
  }
  .download-btn:hover {
    background-color: #1e7e34;
  }
  #show-waveform-label {
    user-select: none;
    font-weight: 600;
    margin-left: 0.5rem;
  }
</style>
</head>
<body>
  <h1>Migraine Throb Synchrony</h1>

  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="resumeBtn" disabled>Resume</button>
    <button id="stopBtn" disabled>Stop & Save</button>
    <button id="markThrobBtn" disabled>Mark Throb</button>

    <label id="show-waveform-label">
      <input type="checkbox" id="showWaveformToggle" checked /> Show Waveform
    </label>

    <div id="timer">00:00.000</div>
  </div>

  <div id="canvas-container">
    <canvas id="ecgCanvas" width="800" height="200"></canvas>
  </div>

  <div id="recordings-list"></div>

<script>
// ==== GLOBALS ====
const canvas = document.getElementById('ecgCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const markThrobBtn = document.getElementById('markThrobBtn');
const showWaveformToggle = document.getElementById('showWaveformToggle');
const timerDisplay = document.getElementById('timer');
const recordingsList = document.getElementById('recordings-list');

let running = false;
let paused = false;
let startTime = 0;
let pauseStart = 0;
let elapsedPauseTime = 0;
let elapsed = 0;

let animationFrameId;

const dataWindowMs = 5000; // 5 seconds visible on canvas
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

let bpm = 75; // Initial BPM
let nextBpmChangeTime = 0;
let bpmChangeInterval = 0; // ms until next BPM change

const bpmMin = 60;
const bpmMax = 100;
const bpmChangeIntervalMin = 3000; // 3 sec
const bpmChangeIntervalMax = 7000; // 7 sec

// ECG waveform synthesis parameters (timing in ms for one beat at 60 bpm)
const baseBeatDuration = 60000 / bpm; // ms per beat (updates dynamically)

let waveformSamples = []; // Stores ECG samples with timestamps for drawing
let rPeaks = []; // Stores {time(ms), bpm} for each detected R peak

let throbs = []; // stores throb times in ms

// UI state
let showWaveform = true;

// === FUNCTIONS ===

function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  const milliseconds = ms % 1000;
  return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3,'0')}`;
}

// ECG Waveform generator - compound Gaussian sum approximating P-QRS-T waves
// x is time in ms relative to beat start; beatDuration is ms per beat
function ecgWaveform(x, beatDuration) {
  // Normalize x into a 0 to 1 range (beat phase)
  const phase = x / beatDuration;
  if (phase < 0 || phase > 1) return 0;

  // P wave: Gaussian at ~0.1 phase
  const pAmp = 0.15;
  const pPos = 0.1;
  const pWidth = 0.03;

  // Q wave: small negative Gaussian at ~0.25 phase
  const qAmp = -0.1;
  const qPos = 0.25;
  const qWidth = 0.02;

  // R wave: tall positive Gaussian at ~0.3 phase
  const rAmp = 1.0;
  const rPos = 0.3;
  const rWidth = 0.015;

  // S wave: negative Gaussian at ~0.35 phase
  const sAmp = -0.25;
  const sPos = 0.35;
  const sWidth = 0.02;

  // T wave: moderate positive Gaussian at ~0.6 phase
  const tAmp = 0.3;
  const tPos = 0.6;
  const tWidth = 0.05;

  function gaussian(x, mean, width) {
    return Math.exp(-Math.pow((x - mean), 2) / (2 * width * width));
  }

  return pAmp * gaussian(phase, pPos, pWidth) +
         qAmp * gaussian(phase, qPos, qWidth) +
         rAmp * gaussian(phase, rPos, rWidth) +
         sAmp * gaussian(phase, sPos, sWidth) +
         tAmp * gaussian(phase, tPos, tWidth);
}

// Update BPM randomly every 3-7 seconds
function scheduleNextBpmChange(currentMs) {
  bpmChangeInterval = bpmChangeIntervalMin + Math.random() * (bpmChangeIntervalMax - bpmChangeIntervalMin);
  nextBpmChangeTime = currentMs + bpmChangeInterval;
}

// Find previous and next R peak times for a given time (ms)
function findSurroundingRPeaks(time) {
  if (rPeaks.length === 0) return [null, null];
  // rPeaks sorted by time ascending

  let prev = null;
  let next = null;
  for (let i = 0; i < rPeaks.length; i++) {
    if (rPeaks[i].time > time) {
      next = rPeaks[i];
      prev = i > 0 ? rPeaks[i - 1] : null;
      break;
    }
  }
  // If no next found, prev is last peak
  if (!next) {
    prev = rPeaks[rPeaks.length - 1];
  }
  return [prev, next];
}

// Compute phases of throbs relative to R peaks in radians
function computeThrobPhases() {
  // For each throb:
  // Find previous and next R peak.
  // Phase = (throbTime - prevRPeakTime) / (nextRPeakTime - prevRPeakTime)
  // Phase range: 0 to 1, multiply by 2pi for radians

  let results = [];
  for (const t of throbs) {
    const [prev, next] = findSurroundingRPeaks(t);

    if (!prev || !next || next.time === prev.time) {
      // Can't compute phase (e.g. only one R peak or no valid peaks)
      continue;
    }
    const deltaTime = next.time - prev.time;
    const phaseNorm = (t - prev.time) / deltaTime;
    const phaseRad = phaseNorm * 2 * Math.PI;

    // Also record delta (time difference between throb and prev R peak)
    const deltaMs = t - prev.time;

    results.push({
      throbTime: t,
      priorPeakTime: prev.time,
      deltaMs,
      bpmAtPeak: prev.bpm,
      phaseRad
    });
  }
  return results;
}

// Circular stats helper functions
function circularMean(angles) {
  let sumSin = 0;
  let sumCos = 0;
  for (const a of angles) {
    sumSin += Math.sin(a);
    sumCos += Math.cos(a);
  }
  return Math.atan2(sumSin / angles.length, sumCos / angles.length);
}

function resultantVectorLength(angles) {
  let sumSin = 0;
  let sumCos = 0;
  for (const a of angles) {
    sumSin += Math.sin(a);
    sumCos += Math.cos(a);
  }
  return Math.sqrt((sumCos/angles.length)**2 + (sumSin/angles.length)**2);
}

// Rayleigh test p-value calculation
// Source: http://www.emathzone.com/tutorials/basic-statistics/rayleigh-test.html
function rayleighPValue(R, n) {
  if (n === 0) return 1;
  const z = n * R * R;
  if (z < 0.5) {
    // approximation for small z
    return Math.exp(-z) * (1 + (2*z - z*z*z)/4 - (24*z*z)/288);
  }
  // For large z use formula below
  return Math.exp(-z) * (1 + (2*z - z*z*z)/4);
}

// Phase Vector Length (PVL) = resultant vector length, same as R
function phaseVectorLength(angles) {
  return resultantVectorLength(angles);
}

// Standard deviation of phase deltas (angular)
function circularStd(angles) {
  const R = resultantVectorLength(angles);
  return Math.sqrt(-2 * Math.log(R));
}

// Convert rad to degrees
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

// Draw the ECG waveform on canvas for the last 5 seconds (rolling window)
function drawWaveform() {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  if (!showWaveform) return;

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#0f0';

  ctx.beginPath();

  // Time window in ms (elapsed - dataWindowMs to elapsed)
  const windowStart = elapsed - dataWindowMs;
  const windowEnd = elapsed;

  // Draw waveform samples in the window
  // waveformSamples = array of {time, value}
  // Only draw points in [windowStart, windowEnd]
  // Map time to x pixel: left=windowStart, right=windowEnd
  // Map value (-0.5 to 1.2 approx) to y pixel

  const samples = waveformSamples.filter(s => s.time >= windowStart && s.time <= windowEnd);

  if (samples.length === 0) return;

  for (let i = 0; i < samples.length; i++) {
    const x = ((samples[i].time - windowStart) / dataWindowMs) * canvasWidth;
    // Map value from (-0.5 to 1.2) to canvas height (invert y)
    const y = canvasHeight - ((samples[i].value + 0.5) / 1.7) * canvasHeight;

    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw R peaks in red vertical lines
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#f00';
  for (const peak of rPeaks) {
    if (peak.time >= windowStart && peak.time <= windowEnd) {
      const x = ((peak.time - windowStart) / dataWindowMs) * canvasWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
  }

  // Draw throb markers as green vertical lines
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#0f0';
  for (const t of throbs) {
    if (t >= windowStart && t <= windowEnd) {
      const x = ((t - windowStart) / dataWindowMs) * canvasWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
  }
}

// Update timer display
function updateTimer() {
  timerDisplay.textContent = formatTime(elapsed);
}

// Generate waveform data and detect R peaks dynamically based on current bpm
function generateWaveformAndPeaks(deltaMs) {
  // deltaMs = time elapsed since last frame, in ms
  // We'll generate samples for the time interval from (elapsed - deltaMs) to elapsed

  // Sampling frequency: aim for 500Hz (2ms intervals)
  const sampleInterval = 2;
  const startSampleTime = elapsed - deltaMs;

  for (let t = startSampleTime; t <= elapsed; t += sampleInterval) {
    // Find which beat this time belongs to
    // Beats start at times: 0, beatDuration, 2*beatDuration, ...
    // But BPM can change over time. So beats are spaced by varying beatDuration.

    // We keep track of R peaks in rPeaks[]
    // So for generating waveform sample at time t, find which beat it is in

    // Simplify: Use rPeaks timestamps to determine current beat:
    // If no R peaks yet, assume first beat starts at 0

    let beatStartTime;
    let currentBpmForBeat = bpm;

    // Find the closest R peak before t (or 0 if none)
    let prevPeak = null;
    for (let i = rPeaks.length - 1; i >= 0; i--) {
      if (rPeaks[i].time <= t) {
        prevPeak = rPeaks[i];
        break;
      }
    }
    if (prevPeak) {
      beatStartTime = prevPeak.time;
      currentBpmForBeat = prevPeak.bpm;
    } else {
      beatStartTime = 0;
      currentBpmForBeat = bpm;
    }

    const beatDuration = 60000 / currentBpmForBeat;
    const timeInBeat = t - beatStartTime;

    // Calculate waveform value
    const val = ecgWaveform(timeInBeat, beatDuration);
    waveformSamples.push({ time: t, value: val });

    // Detect R peak dynamically: R peak is near rPos*beatDuration from beat start
    const rPos = 0.3; // phase of R peak
    const rPeakTimeInBeat = rPos * beatDuration;

    // If sample is near R peak (within sampleInterval), record peak once per beat
    if (
      timeInBeat >= rPeakTimeInBeat &&
      timeInBeat < rPeakTimeInBeat + sampleInterval
    ) {
      // Check if already recorded R peak at this beatStartTime
      const exists = rPeaks.some(p => Math.abs(p.time - (beatStartTime + rPeakTimeInBeat)) < 1);
      if (!exists) {
        rPeaks.push({ time: beatStartTime + rPeakTimeInBeat, bpm: currentBpmForBeat });
      }
    }
  }

  // Keep waveformSamples and rPeaks from growing too large: prune older than (elapsed - dataWindowMs - 2000ms)
  const cutoff = elapsed - dataWindowMs - 2000;
  waveformSamples = waveformSamples.filter(s => s.time >= cutoff);
  rPeaks = rPeaks.filter(p => p.time >= cutoff);
}

// BPM random updater (called inside main loop)
function updateBpm() {
  if (elapsed >= nextBpmChangeTime) {
    // Change BPM randomly between 60-100
    bpm = bpmMin + Math.random() * (bpmMax - bpmMin);
    bpm = Math.round(bpm);
    scheduleNextBpmChange(nextBpmChangeTime);
  }
}

// Main animation loop
let lastTimestamp = 0;
function animate(timestamp) {
  if (!running) return;

  if (!lastTimestamp) lastTimestamp = timestamp;
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  if (!paused) {
    elapsed = (performance.now() - startTime) - elapsedPauseTime;

    updateBpm();
    generateWaveformAndPeaks(delta);
    drawWaveform();
    updateTimer();
  }

  animationFrameId = requestAnimationFrame(animate);
}

// ==== BUTTON HANDLERS ====

function startRecording() {
  if (running) return;

  // Reset all data
  running = true;
  paused = false;
  elapsed = 0;
  elapsedPauseTime = 0;
  startTime = performance.now();
  lastTimestamp = 0;

  waveformSamples = [];
  rPeaks = [];
  throbs = [];

  bpm = bpmMin + Math.random() * (bpmMax - bpmMin);
  bpm = Math.round(bpm);
  scheduleNextBpmChange(0);

  // UI
  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  markThrobBtn.disabled = false;

  animate();
}

function pauseRecording() {
  if (!running || paused) return;
  paused = true;
  pauseStart = performance.now();

  // UI
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  markThrobBtn.disabled = true;
}

function resumeRecording() {
  if (!running || !paused) return;
  paused = false;
  const pauseEnd = performance.now();
  elapsedPauseTime += (pauseEnd - pauseStart);

  // UI
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  markThrobBtn.disabled = false;
}

function stopRecording() {
  if (!running) return;

  running = false;
  paused = false;

  cancelAnimationFrame(animationFrameId);

  // UI
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  markThrobBtn.disabled = true;

  updateTimer();

  // Save the recording data
  saveRecording();
}

// User presses "Mark Throb" at any time (no R peak restriction)
function markThrob() {
  if (!running || paused) return;
  const t = elapsed;
  throbs.push(t);

  // Quick button flash for feedback
  markThrobBtn.style.backgroundColor = '#28a745';
  setTimeout(() => {
    markThrobBtn.style.backgroundColor = '#007bff';
  }, 150);
}

// Save recording to local and display in list
function saveRecording() {
  // Compute phases
  const phaseData = computeThrobPhases();

  // Prepare CSV content with headers
  let csvContent = 'ThrobTime_ms,PriorRPeakTime_ms,DeltaFromRPeak_ms,BPMatPeak,Phase_radians,Phase_degrees\n';
  for (const d of phaseData) {
    csvContent += `${d.throbTime.toFixed(1)},${d.priorPeakTime.toFixed(1)},${d.deltaMs.toFixed(1)},${d.bpmAtPeak},${d.phaseRad.toFixed(4)},${radToDeg(d.phaseRad).toFixed(1)}\n`;
  }

  // Compute circular stats for phases
  const angles = phaseData.map(d => d.phaseRad);
  const n = angles.length;
  if (n > 0) {
    const meanPhase = circularMean(angles);
    const pvl = phaseVectorLength(angles);
    const stdPhase = circularStd(angles);
    const pRayleigh = rayleighPValue(pvl, n);

    csvContent += '\n';
    csvContent += `Number of throbs,${n}\n`;
    csvContent += `Mean phase (radians),${meanPhase.toFixed(4)}\n`;
    csvContent += `Mean phase (degrees),${radToDeg(meanPhase).toFixed(1)}\n`;
    csvContent += `Phase Vector Length (PVL),${pvl.toFixed(4)}\n`;
    csvContent += `Circular Std Dev (radians),${stdPhase.toFixed(4)}\n`;
    csvContent += `Rayleigh test p-value,${pRayleigh.toExponential(3)}\n`;
  } else {
    csvContent += '\nNo throbs recorded or not enough data for stats.\n';
  }

  // Create a download link
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);

  const timestamp = new Date().toISOString().replace(/:/g,'-');
  const filename = `migraine_throb_sync_${timestamp}.csv`;

  const itemDiv = document.createElement('div');
  itemDiv.className = 'recording-item';

  const nameSpan = document.createElement('div');
  nameSpan.className = 'recording-name';
  nameSpan.textContent = filename;

  const downloadBtn = document.createElement('button');
  downloadBtn.className = 'download-btn';
  downloadBtn.textContent = 'Download CSV';
  downloadBtn.onclick = () => {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
  };

  itemDiv.appendChild(nameSpan);
  itemDiv.appendChild(downloadBtn);
  recordingsList.prepend(itemDiv);
}

// === EVENT LISTENERS ===
startBtn.addEventListener('click', startRecording);
pauseBtn.addEventListener('click', pauseRecording);
resumeBtn.addEventListener('click', resumeRecording);
stopBtn.addEventListener('click', stopRecording);
markThrobBtn.addEventListener('click', markThrob);
showWaveformToggle.addEventListener('change', () => {
  showWaveform = showWaveformToggle.checked;
  drawWaveform();
});

// === INITIALIZATION ===
updateTimer();

</script>
</body>
</html>
