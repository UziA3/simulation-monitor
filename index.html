<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  button { margin: 5px; font-size: 1rem; padding: 8px 12px; }
  #canvas-container { position: relative; border: 1px solid #ccc; width: 800px; height: 200px; margin-top: 10px; }
  canvas { background: #fff; display: block; }
  #recordings-list { margin-top: 20px; max-width: 800px; }
  .recording-item { border-top: 1px solid #ccc; padding: 8px 0; display: flex; justify-content: space-between; align-items: center; }
  .recording-name { font-weight: bold; }
</style>
</head>
<body>

<h1>Migraine Throb Synchrony</h1>

<div>
  <button id="start-btn">Start</button>
  <button id="pause-btn" disabled>Pause</button>
  <button id="resume-btn" disabled>Resume</button>
  <button id="stop-btn" disabled>Stop & Save</button>
  <button id="throb-btn" disabled>Mark Throb</button>
  <button id="toggle-waveform-btn" disabled>Hide Waveform</button>
</div>

<div id="timer" style="font-size: 1.5rem; margin-top: 10px;">00:00.000</div>

<div id="canvas-container">
  <canvas id="pulse-canvas" width="800" height="200"></canvas>
</div>

<div id="recordings-list"></div>

<script>
// --- GLOBALS & CONSTANTS ---
const canvas = document.getElementById('pulse-canvas');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const START_BPM_MIN = 60;
const START_BPM_MAX = 100;
const BPM_CHANGE_MIN_INTERVAL = 3000; // ms
const BPM_CHANGE_MAX_INTERVAL = 7000; // ms

// Waveform parameters
const SAMPLES_PER_SECOND = 1000; // ms resolution
const WAVEFORM_DURATION_MS = 5000; // ms visible in canvas (5 sec window)
const PIXELS_PER_MS = WIDTH / WAVEFORM_DURATION_MS;

// --- STATE ---
let recordingState = 'stopped'; // 'running', 'paused', 'stopped'
let startTime = null;
let pauseStart = null;
let elapsedPause = 0;
let elapsedTime = 0;

let bpm = 75;
let bpmChangeTimeout = null;

let throbs = []; // { timestamp }
let pulsePeaks = []; // { timestamp, bpmAtPeak }
let bpmHistory = []; // { timestamp, bpm }

let waveformData = []; // { timestamp, value }

let showWaveform = true;

let animationFrameId = null;

let savedRecordings = [];

// --- ELEMENTS ---
const startBtn = document.getElementById('start-btn');
const pauseBtn = document.getElementById('pause-btn');
const resumeBtn = document.getElementById('resume-btn');
const stopBtn = document.getElementById('stop-btn');
const throbBtn = document.getElementById('throb-btn');
const toggleWaveformBtn = document.getElementById('toggle-waveform-btn');
const timerDisplay = document.getElementById('timer');
const recordingsList = document.getElementById('recordings-list');

// --- HELPERS ---
function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  const milliseconds = ms % 1000;
  return `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}.${milliseconds.toString().padStart(3,'0')}`;
}

function getCurrentTimestamp() {
  if(recordingState === 'running'){
    return Date.now() - startTime - elapsedPause;
  } else if(recordingState === 'paused'){
    return pauseStart - startTime - elapsedPause;
  } else {
    return 0;
  }
}

function gaussian(x, mean, std) {
  return Math.exp(-0.5 * ((x - mean)/std)**2);
}

// --- WAVEFORM SIMULATION ---

/**
 * Generate arterial pulse waveform value at t (ms) relative to pulse start.
 * Uses sum-of-sines + Gaussian peak to mimic waveform.
 * Period = 60,000 / bpm ms.
 * 
 * Pulse shape:
 *  - sharp peak (Gaussian)
 *  - small secondary humps with sinusoids
 */
function pulseWaveform(t, period) {
  const x = (t % period) / period; // normalize [0..1)
  // Gaussian peak at 0.2 of period with std=0.02 period
  const peak = gaussian(x, 0.2, 0.02);
  // Sum sinusoids for shoulder and notch
  const hum1 = 0.15 * Math.sin(2 * Math.PI * 4 * x + Math.PI/4);
  const hum2 = 0.1 * Math.sin(2 * Math.PI * 7 * x + Math.PI/2);
  return peak + hum1 + hum2;
}

// --- BPM MANAGEMENT ---

function scheduleNextBPMChange() {
  if(recordingState !== 'running') return;
  const interval = BPM_CHANGE_MIN_INTERVAL + Math.random() * (BPM_CHANGE_MAX_INTERVAL - BPM_CHANGE_MIN_INTERVAL);
  bpmChangeTimeout = setTimeout(() => {
    bpm = Math.floor(START_BPM_MIN + Math.random() * (START_BPM_MAX - START_BPM_MIN + 1));
    bpmHistory.push({ timestamp: getCurrentTimestamp(), bpm });
    scheduleNextBPMChange();
  }, interval);
}

// Get BPM at a specific timestamp (ms) by looking up bpmHistory
function getBPMAt(timestamp) {
  let bpmEntry = bpmHistory[0];
  for(let i=0; i<bpmHistory.length; i++){
    if(bpmHistory[i].timestamp > timestamp) break;
    bpmEntry = bpmHistory[i];
  }
  return bpmEntry.bpm;
}

// --- PEAK DETECTION ---

/**
 * Detect pulse peaks dynamically as waveform generates.
 * We'll detect peaks as max value points in each period cycle.
 * Store pulse peaks as {timestamp, bpmAtPeak}
 */
function detectPulsePeaks(waveformData) {
  // Assumption: waveformData is sorted by timestamp ascending
  // We'll detect local maxima that exceed 50% max waveform amplitude (heuristic)
  // And are spaced approx by period = 60,000 / bpm ms (variable bpm)

  const peaks = [];
  if(waveformData.length === 0) return peaks;

  // Max amplitude heuristic
  let maxAmp = Math.max(...waveformData.map(d => d.value));
  let threshold = 0.5 * maxAmp;

  for(let i=1; i<waveformData.length-1; i++){
    const prev = waveformData[i-1];
    const curr = waveformData[i];
    const next = waveformData[i+1];
    if(curr.value > prev.value && curr.value >= next.value && curr.value > threshold){
      // Check spacing to avoid multiple peaks close together
      if(peaks.length === 0 || (curr.timestamp - peaks[peaks.length-1].timestamp) > 300){ 
        // Approx 300ms minimum distance between peaks (~200 bpm max)
        // Get bpm at this timestamp
        const bpmAtPeak = getBPMAt(curr.timestamp);
        peaks.push({ timestamp: curr.timestamp, bpmAtPeak });
      }
    }
  }
  return peaks;
}

// --- PHASE & DELTA CALCULATION ---

/**
 * For each throb, find prior pulse peak and calculate delta, phase
 * Delta = throb.timestamp - priorPeak.timestamp
 * Phase = normalized [0..2pi] phase between priorPeak and nextPeak
 */
function analyzeThrobs(throbs, pulsePeaks) {
  // pulsePeaks sorted by timestamp ascending
  const results = [];

  for(const throb of throbs){
    // Find prior peak (max peak with timestamp <= throb.timestamp)
    let priorPeakIndex = -1;
    for(let i=0; i < pulsePeaks.length; i++){
      if(pulsePeaks[i].timestamp <= throb.timestamp){
        priorPeakIndex = i;
      } else break;
    }
    if(priorPeakIndex === -1) continue; // No prior peak (ignore)

    const priorPeak = pulsePeaks[priorPeakIndex];
    // Next peak index
    const nextPeak = pulsePeaks[priorPeakIndex+1];
    if(!nextPeak) continue; // No next peak - cannot calculate phase

    const delta = throb.timestamp - priorPeak.timestamp;
    const period = nextPeak.timestamp - priorPeak.timestamp;
    if(period <= 0) continue; // invalid period

    const phase = 2 * Math.PI * (delta / period);

    results.push({
      throbTime: throb.timestamp,
      priorPeakTime: priorPeak.timestamp,
      delta,
      bpmAtPeak: priorPeak.bpmAtPeak,
      phase,
    });
  }
  return results;
}

// --- CIRCULAR STATISTICS ---

/**
 * Rayleigh test for non-uniformity of circular data
 * Returns object with R (resultant vector length) and p-value
 * Reference: https://en.wikipedia.org/wiki/Rayleigh_test
 */
function rayleighTest(phases) {
  const n = phases.length;
  if(n === 0) return { R: 0, pValue: 1 };
  let sumSin = 0, sumCos = 0;
  for(const angle of phases){
    sumSin += Math.sin(angle);
    sumCos += Math.cos(angle);
  }
  const R = Math.sqrt(sumSin*sumSin + sumCos*sumCos) / n;
  const z = n * R * R;
  // Approximate p-value:
  const pValue = Math.exp(-z) * (1 + (2*z - z*z) / (4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z) / (288*n*n));
  return { R, pValue };
}

/**
 * Phase Vector Length (PVL) = mean resultant vector length, same as Rayleigh R here
 */
function phaseVectorLength(phases) {
  return rayleighTest(phases).R;
}

/**
 * Compute mean vector angle of phases
 */
function meanVectorAngle(phases) {
  const n = phases.length;
  if(n === 0) return 0;
  let sumSin = 0, sumCos = 0;
  for(const angle of phases){
    sumSin += Math.sin(angle);
    sumCos += Math.cos(angle);
  }
  return Math.atan2(sumSin, sumCos);
}

/**
 * Standard deviation of deltas (ms)
 */
function stdDevDeltas(deltas) {
  const n = deltas.length;
  if(n === 0) return 0;
  const mean = deltas.reduce((a,b) => a+b, 0) / n;
  const variance = deltas.reduce((a,b) => a+(b - mean)**2, 0) / n;
  return Math.sqrt(variance);
}

// --- CSV GENERATION ---
function generateCSV(recording) {
  const lines = [];
  // Header summary lines
  lines.push(`Recording Name,${recording.name}`);
  lines.push(`Total Throb Count,${recording.throbs.length}`);
  lines.push(`Total Pulse Peak Count,${recording.pulsePeaks.length}`);
  lines.push(`Mean Pulse Rate (BPM),${recording.meanBPM.toFixed(2)}`);
  lines.push(`Rayleigh R,${recording.rayleighR.toFixed(4)}`);
  lines.push(`Rayleigh p-value,${recording.rayleighPValue.toExponential(4)}`);
  lines.push(`PVL,${recording.pvl.toFixed(4)}`);
  lines.push(`StdDev Delta (ms),${recording.stdDevDelta.toFixed(2)}`);
  lines.push(`Mean Vector Angle (radians),${recording.meanVectorAngle.toFixed(4)}`);
  lines.push('');
  // Raw data table header
  lines.push('Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)');
  for(const t of recording.throbs){
    lines.push(`${t.throbTime},${t.priorPeakTime},${t.delta},${t.bpmAtPeak},${t.phase.toFixed(4)}`);
  }
  return lines.join('\n');
}

function downloadCSV(filename, csvContent) {
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// --- RENDERING ---

function clearCanvas() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
}

function drawWaveform() {
  if(waveformData.length === 0) return;
  clearCanvas();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#000';

  ctx.beginPath();

  // We draw only the last 5 seconds of data, mapping timestamps to X
  const now = getCurrentTimestamp();

  for(let i=0; i<waveformData.length; i++){
    const point = waveformData[i];
    const elapsed = now - point.timestamp;
    if(elapsed > WAVEFORM_DURATION_MS) continue; // only last 5s visible

    const x = WIDTH - (elapsed * PIXELS_PER_MS);
    const y = HEIGHT - (point.value * (HEIGHT * 0.8)) - 20; // scale & offset to bottom

    if(i === 0 || elapsed > WAVEFORM_DURATION_MS) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();

  // Draw pulse peaks (red vertical lines)
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  for(const peak of pulsePeaks){
    const elapsed = now - peak.timestamp;
    if(elapsed > WAVEFORM_DURATION_MS || elapsed < 0) continue;
    const x = WIDTH - (elapsed * PIXELS_PER_MS);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, HEIGHT);
    ctx.stroke();
  }

  // Draw throb markers (green vertical lines)
  ctx.strokeStyle = 'green';
  ctx.lineWidth = 1.5;
  for(const throb of throbs){
    const elapsed = now - throb.timestamp;
    if(elapsed > WAVEFORM_DURATION_MS || elapsed < 0) continue;
    const x = WIDTH - (elapsed * PIXELS_PER_MS);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, HEIGHT);
    ctx.stroke();
  }
}

// --- ANIMATION LOOP ---
function animationLoop() {
  if(recordingState !== 'running') {
    animationFrameId = null;
    return;
  }

  const now = Date.now();
  elapsedTime = now - startTime - elapsedPause;

  // Generate waveform point at current elapsedTime
  // BPM can change during recording, so find correct period per timestamp

  // We'll generate waveformData points every ms (to keep smooth)
  // But for performance, generate one point per animation frame

  const bpmAtNow = getBPMAt(elapsedTime);
  const period = 60000 / bpmAtNow;

  // waveform value at elapsedTime mod period
  const value = pulseWaveform(elapsedTime, period);
  waveformData.push({ timestamp: elapsedTime, value });

  // Clean old waveform data outside window
  while(waveformData.length && elapsedTime - waveformData[0].timestamp > WAVEFORM_DURATION_MS * 2){
    waveformData.shift();
  }

  // Detect pulse peaks every frame (recalculate from last ~1000ms to catch new peaks)
  // For efficiency, detect on last 1000ms only:
  const recentData = waveformData.filter(d => elapsedTime - d.timestamp < 1200);
  const detectedPeaks = detectPulsePeaks(recentData);
  // Add new peaks that are not in pulsePeaks yet:
  detectedPeaks.forEach(peak => {
    if(!pulsePeaks.find(p => p.timestamp === peak.timestamp)){
      pulsePeaks.push(peak);
    }
  });

  // Update timer display
  timerDisplay.textContent = formatTime(elapsedTime);

  // Draw waveform if visible
  if(showWaveform){
    drawWaveform();
  } else {
    clearCanvas();
  }

  animationFrameId = requestAnimationFrame(animationLoop);
}

// --- BUTTON HANDLERS ---

startBtn.onclick = () => {
  if(recordingState !== 'stopped') return;

  // Reset all
  startTime = Date.now();
  pauseStart = null;
  elapsedPause = 0;
  elapsedTime = 0;
  bpm = Math.floor(START_BPM_MIN + Math.random() * (START_BPM_MAX - START_BPM_MIN + 1));
  bpmHistory = [{ timestamp: 0, bpm }];
  throbs = [];
  pulsePeaks = [];
  waveformData = [];

  recordingState = 'running';

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  throbBtn.disabled = false;
  toggleWaveformBtn.disabled = false;
  toggleWaveformBtn.textContent = 'Hide Waveform';

  scheduleNextBPMChange();

  animationLoop();
};

pauseBtn.onclick = () => {
  if(recordingState !== 'running') return;
  recordingState = 'paused';
  pauseStart = Date.now();
  clearTimeout(bpmChangeTimeout);

  startBtn.disabled = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  stopBtn.disabled = false;
  throbBtn.disabled = true;
};

resumeBtn.onclick = () => {
  if(recordingState !== 'paused') return;
  recordingState = 'running';
  const now = Date.now();
  elapsedPause += now - pauseStart;
  pauseStart = null;

  scheduleNextBPMChange();

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  throbBtn.disabled = false;

  animationLoop();
};

stopBtn.onclick = () => {
  if(recordingState === 'stopped') return;
  recordingState = 'stopped';
  clearTimeout(bpmChangeTimeout);
  if(animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }

  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  toggleWaveformBtn.disabled = true;

  // Final peak detection over full waveform
  pulsePeaks = detectPulsePeaks(waveformData);

  // Analyze throbs
  const throbAnalysis = analyzeThrobs(throbs, pulsePeaks);

  if(throbAnalysis.length === 0){
    alert('No throbs were marked or insufficient pulse peaks detected. Recording discarded.');
    return;
  }

  // Calculate stats
  const meanBPM = bpmHistory.reduce((a,v) => a+v.bpm, 0) / bpmHistory.length;
  const phases = throbAnalysis.map(t => t.phase);
  const deltas = throbAnalysis.map(t => t.delta);
  const rayleighRes = rayleighTest(phases);
  const pvl = phaseVectorLength(phases);
  const stdDevDelta = stdDevDeltas(deltas);
  const meanAngle = meanVectorAngle(phases);

  // Prompt for recording name
  let name = prompt('Enter a name for this recording:', `Recording ${savedRecordings.length+1}`);
  if(!name) name = `Recording ${savedRecordings.length+1}`;

  // Save recording
  const recording = {
    name,
    throbs: throbAnalysis,
    pulsePeaks,
    bpmHistory,
    meanBPM,
    rayleighR: rayleighRes.R,
    rayleighPValue: rayleighRes.pValue,
    pvl,
    stdDevDelta,
    meanVectorAngle: meanAngle,
  };
  savedRecordings.push(recording);

  // Update recordings list UI
  updateRecordingsList();
};

throbBtn.onclick = () => {
  if(recordingState !== 'running') return;
  const t = getCurrentTimestamp();
  throbs.push({ timestamp: t });
};

toggleWaveformBtn.onclick = () => {
  showWaveform = !showWaveform;
  toggleWaveformBtn.textContent = showWaveform ? 'Hide Waveform' : 'Show Waveform';
  if(!showWaveform){
    clearCanvas();
  }
};

// --- RECORDINGS LIST UI ---
function updateRecordingsList() {
  recordingsList.innerHTML = '<h2>Saved Recordings</h2>';
  if(savedRecordings.length === 0){
    recordingsList.innerHTML += '<p>No recordings yet.</p>';
    return;
  }
  for(let i=0; i<savedRecordings.length; i++){
    const rec = savedRecordings[i];
    const div = document.createElement('div');
    div.className = 'recording-item';

    const info = document.createElement('div');
    info.className = 'recording-name';
    info.textContent = `${rec.name} â€” Throbs: ${rec.throbs.length}, Mean BPM: ${rec.meanBPM.toFixed(1)}, Rayleigh p: ${rec.rayleighPValue.toExponential(2)}`;

    const exportBtn = document.createElement('button');
    exportBtn.textContent = 'Export CSV';
    exportBtn.onclick = () => {
      const csv = generateCSV(rec);
      downloadCSV(`${rec.name.replace(/\s+/g, '_')}.csv`, csv);
    };

    div.appendChild(info);
    div.appendChild(exportBtn);

    recordingsList.appendChild(div);
  }
}

</script>

</body>
</html>
