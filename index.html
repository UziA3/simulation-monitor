<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  /* ... (same styles as before, omitted here for brevity) ... */
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    text-align: center;
    margin-bottom: 10px;
  }
  button {
    margin: 0 5px;
    padding: 8px 16px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background: #ddd;
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
  #timer {
    font-size: 1.2rem;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
  }
  #canvasContainer {
    text-align: center;
    margin-bottom: 15px;
  }
  canvas {
    border: 1px solid #aaa;
    background: #fff;
  }
  #showWaveformLabel {
    display: block;
    text-align: center;
    margin-bottom: 15px;
  }
  #recordingsList {
    margin-top: 20px;
  }
  .recording-item {
    margin-bottom: 10px;
  }
  .recording-name {
    font-weight: bold;
    margin-right: 10px;
  }
  .download-btn {
    padding: 4px 10px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  .download-btn:hover {
    background: #ddd;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
</div>

<div id="timer">0.00s</div>

<label id="showWaveformLabel">
  <input type="checkbox" id="showWaveformToggle" checked /> Show Waveform
</label>

<div id="canvasContainer">
  <canvas id="ecgCanvas" width="800" height="200"></canvas>
</div>

<div id="recordingsList"></div>

<script>
(() => {
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const timerEl = document.getElementById('timer');
  const showWaveformToggle = document.getElementById('showWaveformToggle');
  const recordingsList = document.getElementById('recordingsList');

  const waveformDuration = 5000; // 5 seconds window shown on canvas
  const sampleRate = 250; // Hz (samples per second)
  const sampleInterval = 1000 / sampleRate; // ms per sample

  function ecgWaveform(tNorm) {
    const p = 0.1, pWidth = 0.07, pAmp = 0.15;
    const q = 0.2, qWidth = 0.01, qAmp = -0.25;
    const r = 0.22, rWidth = 0.015, rAmp = 1.0;
    const s = 0.26, sWidth = 0.01, sAmp = -0.35;
    const t = 0.4, tWidth = 0.1, tAmp = 0.3;

    const pWave = pAmp * Math.exp(-((tNorm - p) ** 2) / (2 * pWidth ** 2));
    const qWave = qAmp * Math.exp(-((tNorm - q) ** 2) / (2 * qWidth ** 2));
    const rWave = rAmp * Math.exp(-((tNorm - r) ** 2) / (2 * rWidth ** 2));
    const sWave = sAmp * Math.exp(-((tNorm - s) ** 2) / (2 * sWidth ** 2));
    const tWave = tAmp * Math.exp(-((tNorm - t) ** 2) / (2 * tWidth ** 2));

    return pWave + qWave + rWave + sWave + tWave;
  }

  let running = false;
  let paused = false;
  let startTime = 0;
  let elapsedPauseTime = 0;
  let pauseStartTime = 0;
  let elapsed = 0;
  let lastTimestamp = 0;
  let animationFrameId = 0;

  let waveformSamples = [];
  let rPeaks = [];
  let throbs = [];

  let currentBpm = 75;
  let bpmChangeTime = 0;
  let nextBpmChangeInterval = 0;

  let showWaveform = true;

  function randomInterval() {
    return 3000 + Math.random() * 4000;
  }
  function randomBpm() {
    return 60 + Math.floor(Math.random() * 41);
  }
  function bpmToMs(bpm) {
    return 60000 / bpm;
  }
  function simulateEcgSample(elapsedMs) {
    let elapsedSinceBpmChange = elapsedMs - bpmChangeTime;
    let beatInterval = bpmToMs(currentBpm);
    let beatPos = (elapsedSinceBpmChange % beatInterval) / beatInterval;
    return ecgWaveform(beatPos);
  }

  function detectRPeaks() {
    const minDistance = 400;
    let lastPeakTime = rPeaks.length > 0 ? rPeaks[rPeaks.length - 1].time : -Infinity;

    for (let i = 1; i < waveformSamples.length - 1; i++) {
      let s = waveformSamples[i];
      if (
        s.value > 0.8 &&
        s.value > waveformSamples[i - 1].value &&
        s.value > waveformSamples[i + 1].value &&
        s.time > lastPeakTime + minDistance
      ) {
        let bpmAtPeak = currentBpm;
        rPeaks.push({ time: s.time, value: s.value, bpm: bpmAtPeak });
        lastPeakTime = s.time;
      }
    }

    rPeaks = rPeaks.filter(rp => rp.time >= elapsed - waveformDuration - 1000);
  }

  function drawWaveform() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!showWaveform) return;

    const midY = canvas.height / 2;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, midY);
    ctx.lineTo(canvas.width, midY);
    ctx.stroke();

    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;
    ctx.beginPath();

    const tStart = elapsed - waveformDuration;
    const tEnd = elapsed;

    for (let i = 0; i < waveformSamples.length; i++) {
      const s = waveformSamples[i];
      if (s.time < tStart) continue;
      if (s.time > tEnd) break;

      const x = ((s.time - tStart) / waveformDuration) * canvas.width;
      const y = midY - s.value * 70;
      if (i === 0 || waveformSamples[i - 1].time < tStart) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();

    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    rPeaks.forEach(rp => {
      if (rp.time >= tStart && rp.time <= tEnd) {
        const x = ((rp.time - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
    });

    ctx.strokeStyle = 'green';
    ctx.lineWidth = 2;
    throbs.forEach(throb => {
      if (throb >= tStart && throb <= tEnd) {
        const x = ((throb - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
    });
  }

  function formatTime(ms) {
    return (ms / 1000).toFixed(2) + 's';
  }

  function updateTimer() {
    if (!running) return;
    if (paused) return;

    elapsed = performance.now() - startTime - elapsedPauseTime;
    timerEl.textContent = formatTime(elapsed);
  }

  function animationStep(timestamp) {
    if (!running || paused) {
      animationFrameId = requestAnimationFrame(animationStep);
      return;
    }

    elapsed = timestamp - startTime - elapsedPauseTime;

    if (elapsed - bpmChangeTime > nextBpmChangeInterval) {
      bpmChangeTime = elapsed;
      currentBpm = randomBpm();
      nextBpmChangeInterval = randomInterval();
    }

    // Generate samples up to current elapsed
    let lastSampleTime = waveformSamples.length > 0 ? waveformSamples[waveformSamples.length - 1].time : -sampleInterval;
    while (lastSampleTime + sampleInterval < elapsed) {
      lastSampleTime += sampleInterval;
      waveformSamples.push({ time: lastSampleTime, value: simulateEcgSample(lastSampleTime) });
    }

    detectRPeaks();

    drawWaveform();
    updateTimer();

    animationFrameId = requestAnimationFrame(animationStep);
  }

  function startRecording() {
    if (running) return;

    running = true;
    paused = false;

    startTime = performance.now();
    elapsedPauseTime = 0;
    waveformSamples = [];
    rPeaks = [];
    throbs = [];
    currentBpm = randomBpm();
    bpmChangeTime = 0;
    nextBpmChangeInterval = randomInterval();

    // Seed initial sample at time 0 to allow waveform to draw immediately
    waveformSamples.push({ time: 0, value: simulateEcgSample(0) });

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    markThrobBtn.disabled = false;

    animationFrameId = requestAnimationFrame(animationStep);
  }

  function pauseRecording() {
    if (!running || paused) return;
    paused = true;
    pauseStartTime = performance.now();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
  }

  function resumeRecording() {
    if (!running || !paused) return;
    paused = false;
    elapsedPauseTime += performance.now() - pauseStartTime;

    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
  }

  function stopRecording() {
    if (!running) return;

    running = false;
    paused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    markThrobBtn.disabled = true;

    cancelAnimationFrame(animationFrameId);

    saveRecording();
  }

  function markThrob() {
    if (!running || paused) return;
    throbs.push(elapsed);
  }

  function saveRecording() {
    const recName = prompt('Enter recording name:', `Recording_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}`);
    if (!recName) return;

    // Compose CSV content (simplified example)
    let csv = 'time_ms,value,rPeak,throb\n';

    waveformSamples.forEach(s => {
      const isR = rPeaks.some(rp => Math.abs(rp.time - s.time) < sampleInterval / 2) ? 1 : 0;
      const isThrob = throbs.some(t => Math.abs(t - s.time) < sampleInterval / 2) ? 1 : 0;
      csv += `${s.time.toFixed(2)},${s.value.toFixed(4)},${isR},${isThrob}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    const div = document.createElement('div');
    div.className = 'recording-item';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'recording-name';
    nameSpan.textContent = recName;

    const downloadBtn = document.createElement('a');
    downloadBtn.className = 'download-btn';
    downloadBtn.href = url;
    downloadBtn.download = recName + '.csv';
    downloadBtn.textContent = 'Download CSV';

    div.appendChild(nameSpan);
    div.appendChild(downloadBtn);
    recordingsList.appendChild(div);

    alert('Recording saved!');
  }

  startBtn.addEventListener('click', startRecording);
  pauseBtn.addEventListener('click', pauseRecording);
  resumeBtn.addEventListener('click', resumeRecording);
  stopBtn.addEventListener('click', stopRecording);
  markThrobBtn.addEventListener('click', markThrob);
  showWaveformToggle.addEventListener('change', () => {
    showWaveform = showWaveformToggle.checked;
    drawWaveform();
  });
})();
</script>
</body>
</html>
