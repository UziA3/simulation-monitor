<!-- Save as pulse-throb-simulator-debug.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pulse Throb Simulator with PLV - Debug</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { border: 1px solid #ccc; margin-bottom: 10px; }
    button { margin: 5px; }
  </style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated) - Debug Version</h1>
<canvas id="canvas" width="800" height="200"></canvas><br>
<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>
<div>Timer: <span id="timer">00:00</span></div>
<ul id="recordingsList"></ul>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const timerDisplay = document.getElementById("timer");
  const recordingsList = document.getElementById("recordingsList");

  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId;
  let lastSampleTime = 0;

  const DISPLAY_DURATION = 20000; // 20s
  const SAMPLE_INTERVAL = 20;     // ms
  const WAVE_BASELINE = 100;
  const WAVE_AMPLITUDE = 50;
  const WAVE_FREQ = 1.2 + Math.random() * 0.5; // ~60-100bpm

  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const value = WAVE_BASELINE + WAVE_AMPLITUDE * Math.sin(2 * Math.PI * WAVE_FREQ * t);
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    pulseWave = pulseWave.filter(p => p.time >= now - DISPLAY_DURATION);
  }

  function draw() {
    simulatePulse();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    ctx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.stroke();

    // Draw throbs
    throbs.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValue(throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    });

    if (isRecording && !isPaused) {
      animationId = requestAnimationFrame(draw);
    }
  }

  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  function findPeaks() {
    const peaks = [];
    const window = 1;  // smaller window for sensitivity
    for (let i = window; i < pulseWave.length - window; i++) {
      const cur = pulseWave[i].value;
      let isPeak = true;
      for (let j = 1; j <= window; j++) {
        if (cur <= pulseWave[i - j].value || cur <= pulseWave[i + j].value) {
          isPeak = false;
          break;
        }
      }
      if (isPeak) peaks.push(pulseWave[i].time);
    }
    console.log("Detected peaks (ms since start):", peaks.map(p => (p - recordingStartTime).toFixed(0)));
    return peaks;
  }

  function calculatePhase(t) {
    const peaks = findPeaks();
    let prev = null, next = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prev = peaks[i];
        next = peaks[i + 1];
        break;
      }
    }
    if (!prev || !next) {
      console.warn("Phase calculation failed for time:", (t - recordingStartTime).toFixed(0));
      return null;
    }
    const phase = 2 * Math.PI * (t - prev) / (next - prev);
    console.log(`Phase for t=${(t - recordingStartTime).toFixed(0)}ms: ${phase.toFixed(4)}`);
    return phase;
  }

  function calculatePLV() {
    const valid = throbs.filter(t => t.phase !== null);
    if (valid.length === 0) return 0;
    let sumReal = 0, sumImag = 0;
    valid.forEach(t => {
      sumReal += Math.cos(t.phase);
      sumImag += Math.sin(t.phase);
    });
    return Math.sqrt(sumReal ** 2 + sumImag ** 2) / valid.length;
  }

  // Rayleigh test for uniformity of phase angles
  // returns approximate p-value, using formula for large samples
  function calculateRayleighP() {
    const valid = throbs.filter(t => t.phase !== null);
    if (valid.length === 0) return null;
    const n = valid.length;
    let sumReal = 0, sumImag = 0;
    valid.forEach(t => {
      sumReal += Math.cos(t.phase);
      sumImag += Math.sin(t.phase);
    });
    const R = Math.sqrt(sumReal**2 + sumImag**2) / n;
    const z = n * R * R;
    // Approximate p-value for Rayleigh test
    const p = Math.exp(-z) * (1 + (2*z - z*z)/(4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z)/(288*n*n));
    return p;
  }

  // Circular variance and std dev of phases
  function calculateCircularStats() {
    const valid = throbs.filter(t => t.phase !== null);
    if (valid.length === 0) return { variance: null, stddev: null };
    const n = valid.length;
    let sumReal = 0, sumImag = 0;
    valid.forEach(t => {
      sumReal += Math.cos(t.phase);
      sumImag += Math.sin(t.phase);
    });
    const R = Math.sqrt(sumReal**2 + sumImag**2) / n;
    const variance = 1 - R;
    const stddev = Math.sqrt(-2 * Math.log(R));
    return { variance, stddev };
  }

  // Mean inter-throb interval (ms)
  function calculateMeanInterThrobInterval() {
    if (throbs.length < 2) return null;
    const intervals = [];
    for (let i = 1; i < throbs.length; i++) {
      intervals.push(throbs[i].time - throbs[i-1].time);
    }
    return intervals.reduce((a,b) => a+b, 0) / intervals.length;
  }

  // Mean pulse cycle length (ms)
  function calculateMeanCycleLength() {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;
    const intervals = [];
    for (let i = 1; i < peaks.length; i++) {
      intervals.push(peaks[i] - peaks[i-1]);
    }
    return intervals.reduce((a,b) => a+b, 0) / intervals.length;
  }

  // Cross-correlation between throbs and pulse peaks
  // Simplified: compute correlation between interp throbs timeseries and pulse peaks timeseries
  function calculateCrossCorrelation() {
    const peaks = findPeaks();
    if (peaks.length < 2 || throbs.length < 2) return { maxCorr: null, lag: null };

    // Build time series vectors: 1ms bins over recording duration
    const start = recordingStartTime;
    const end = performance.now();
    const duration = end - start;
    const bins = Math.floor(duration); // 1 ms bins

    const pulseVec = new Array(bins).fill(0);
    const throbVec = new Array(bins).fill(0);

    peaks.forEach(t => {
      const idx = Math.floor(t - start);
      if (idx >= 0 && idx < bins) pulseVec[idx] = 1;
    });

    throbs.forEach(t => {
      const idx = Math.floor(t.time - start);
      if (idx >= 0 && idx < bins) throbVec[idx] = 1;
    });

    // Compute normalized cross-correlation and find max
    let maxCorr = -Infinity;
    let bestLag = 0;
    const maxLag = 5000; // max lag 5s

    for (let lag = -maxLag; lag <= maxLag; lag += 10) {
      let sumP = 0, sumT = 0, sumPT = 0;
      let count = 0;
      for (let i = 0; i < bins; i++) {
        const j = i + lag;
        if (j < 0 || j >= bins) continue;
        const pVal = pulseVec[i];
        const tVal = throbVec[j];
        sumP += pVal;
        sumT += tVal;
        sumPT += pVal * tVal;
        count++;
      }
      if (count === 0) continue;
      const meanP = sumP / count;
      const meanT = sumT / count;
      let num = 0;
      let denP = 0;
      let denT = 0;
      for (let i = 0; i < count; i++) {
        const pVal = pulseVec[i];
        const tVal = throbVec[i + lag];
        num += (pVal - meanP) * (tVal - meanT);
        denP += (pVal - meanP) ** 2;
        denT += (tVal - meanT) ** 2;
      }
      const den = Math.sqrt(denP * denT);
      if (den === 0) continue;
      const corr = num / den;
      if (corr > maxCorr) {
        maxCorr = corr;
        bestLag = lag;
      }
    }
    return { maxCorr, lag: bestLag };
  }

  function updateTimer() {
    const elapsed = performance.now() - recordingStartTime;
    const mins = Math.floor(elapsed / 60000);
    const secs = Math.floor((elapsed % 60000) / 1000);
    timerDisplay.textContent = `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  }

  // ---------- Button Logic ----------

  startBtn.onclick = () => {
    throbs = [];
    pulseWave = [];
    recordingStartTime = performance.now();
    isRecording = true;
    isPaused = false;
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    timerInterval = setInterval(updateTimer, 100);
    draw();
  };

  pauseBtn.onclick = () => {
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    cancelAnimationFrame(animationId);
    clearInterval(timerInterval);
  };

  resumeBtn.onclick = () => {
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    timerInterval = setInterval(updateTimer, 100);
    draw();
  };

  stopBtn.onclick = () => {
    isRecording = false;
    clearInterval(timerInterval);
    cancelAnimationFrame(animationId);
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    exportCSV();
  };

  throbBtn.onclick = () => {
    const peaks = findPeaks();
    if (peaks.length < 2) {
      alert("Not enough pulse peaks detected yet. Wait a moment.");
      return;
    }
    const t = performance.now();
    const phase = calculatePhase(t);
    throbs.push({ time: t, phase });
  };

  function exportCSV() {
    const header = ["Throb #", "Time (ms)", "Phase (radians)"];
    const rows = throbs.map((t, i) => [
      i + 1,
      (t.time - recordingStartTime).toFixed(1),
      t.phase !== null ? t.phase.toFixed(4) : "N/A"
    ]);
    const plv = calculatePLV();
    const rayleighP = calculateRayleighP();
    const { variance: circVar, stddev: circStd } = calculateCircularStats();
    const meanITI = calculateMeanInterThrobInterval();
    const meanCycle = calculateMeanCycleLength();
    const { maxCorr, lag } = calculateCrossCorrelation();

    console.log("PLV:", plv);
    console.log("Rayleigh p-value:", rayleighP);
    console.log("Circular Variance:", circVar);
    console.log("Circular StdDev:", circStd);
    console.log("Mean Inter-Throb Interval (ms):", meanITI);
    console.log("Mean Pulse Cycle Length (ms):", meanCycle);
    console.log("Cross-Correlation Max:", maxCorr);
    console.log("Cross-Correlation Lag (ms):", lag);

    let csv = header.join(",") + "\n";
    rows.forEach(row => csv += row.join(",") + "\n");
    csv += `\nPLV:,${plv.toFixed(4)}\n`;
    csv += `Rayleigh p-value:,${rayleighP !== null ? rayleighP.toExponential(3) : "N/A"}\n`;
    csv += `Circular Variance:,${circVar !== null ? circVar.toFixed(4) : "N/A"}\n`;
    csv += `Circular StdDev:,${circStd !== null ? circStd.toFixed(4) : "N/A"}\n`;
    csv += `Mean Inter-Throb Interval (ms):,${meanITI !== null ? meanITI.toFixed(1) : "N/A"}\n`;
    csv += `Mean Pulse Cycle Length (ms):,${meanCycle !== null ? meanCycle.toFixed(1) : "N/A"}\n`;
    csv += `Cross-Correlation Max:,${maxCorr !== null ? maxCorr.toFixed(4) : "N/A"}\n`;
    csv += `Cross-Correlation Lag (ms):,${lag !== null ? lag : "N/A"}\n`;

    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `pulse_throb_${Date.now()}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
})();
</script>

</body>
</html>
