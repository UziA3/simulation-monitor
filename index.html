<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Migraine Throb Synchrony App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
      background: #f9f9f9;
    }

    #controls {
      margin-bottom: 10px;
    }

    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }

    #timer {
      font-size: 24px;
      margin: 10px;
      font-weight: bold;
    }

    #ecgCanvas {
      background-color: #fff;
      border: 1px solid #ccc;
      margin-top: 10px;
    }

    #recordings {
      margin-top: 20px;
    }

    .recording-entry {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Migraine Throb Synchrony App</h1>

  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="resumeBtn" disabled>Resume</button>
    <button id="stopBtn" disabled>Stop & Save</button>
    <button id="markThrobBtn" disabled>Mark Throb</button>
    <label><input type="checkbox" id="toggleView" checked> Show Waveform</label>
  </div>

  <div id="timer">00:00.00</div>

  <canvas id="ecgCanvas" width="1000" height="300"></canvas>

  <h2>Recordings</h2>
  <div id="recordings"></div>

  <script>
    const canvas = document.getElementById('ecgCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const markThrobBtn = document.getElementById('markThrobBtn');
    const timerDisplay = document.getElementById('timer');
    const toggleView = document.getElementById('toggleView');
    const recordingsDiv = document.getElementById('recordings');

    let isRecording = false;
    let isPaused = false;
    let startTime = 0;
    let pausedTime = 0;
    let pauseStart = 0;
    let animationFrame;
    let bpm = 75;
    let lastBPMChange = 0;
    let bpmChangeInterval = getRandomInterval();
    let waveform = [];
    let rPeaks = [];
    let throbs = [];
    let recordings = [];
    let viewVisible = true;

    const canvasDuration = 5000; // 5 seconds

    function getTime() {
      if (!isRecording) return 0;
      let now = performance.now();
      return (now - startTime - pausedTime);
    }

    function formatTime(ms) {
      const sec = Math.floor(ms / 1000);
      const m = String(Math.floor(sec / 60)).padStart(2, '0');
      const s = String(sec % 60).padStart(2, '0');
      const msPart = String(Math.floor((ms % 1000) / 10)).padStart(2, '0');
      return `${m}:${s}.${msPart}`;
    }

    function getRandomInterval() {
      return (3 + Math.random() * 4) * 1000; // 3 to 7 seconds
    }

    function getRandomBPM() {
      return 60 + Math.floor(Math.random() * 41); // 60 to 100 BPM
    }

    function generateECGSample(t, bpm) {
      const beatDuration = 60000 / bpm;
      const phase = (t % beatDuration) / beatDuration;

      const p = Math.exp(-Math.pow((phase - 0.2) * 20, 2)) * 0.2;
      const qrs = Math.exp(-Math.pow((phase - 0.3) * 100, 2));
      const tWave = Math.exp(-Math.pow((phase - 0.5) * 15, 2)) * 0.35;
      return p + qrs + tWave;
    }

    function detectRPeak(prev, curr, next) {
      return curr > prev && curr > next && curr > 0.9;
    }

    function updateWaveform() {
      const now = performance.now();
      const t = getTime();
      const ecgVal = generateECGSample(t, bpm);
      waveform.push({ t, v: ecgVal });

      // R peak detection
      if (waveform.length > 2) {
        const len = waveform.length;
        const [a, b, c] = [waveform[len - 3], waveform[len - 2], waveform[len - 1]];
        if (detectRPeak(a.v, b.v, c.v)) {
          rPeaks.push({ t: b.t, bpm });
        }
      }

      waveform = waveform.filter(p => t - p.t <= canvasDuration);
      rPeaks = rPeaks.filter(p => t - p.t <= canvasDuration);
      throbs = throbs.filter(p => t - p <= canvasDuration);
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!viewVisible) return;

      const t = getTime();
      const w = canvas.width;
      const h = canvas.height;

      ctx.beginPath();
      ctx.moveTo(0, h / 2);
      for (let i = 0; i < waveform.length; i++) {
        const x = w * (waveform[i].t - (t - canvasDuration)) / canvasDuration;
        const y = h / 2 - waveform[i].v * 100;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = 'black';
      ctx.stroke();

      for (let p of rPeaks) {
        const x = w * (p.t - (t - canvasDuration)) / canvasDuration;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.strokeStyle = 'red';
        ctx.stroke();
      }

      for (let p of throbs) {
        const x = w * (p - (t - canvasDuration)) / canvasDuration;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.strokeStyle = 'green';
        ctx.stroke();
      }
    }

    function animate() {
      if (!isRecording || isPaused) return;
      const t = getTime();
      timerDisplay.textContent = formatTime(t);

      if (t - lastBPMChange > bpmChangeInterval) {
        bpm = getRandomBPM();
        lastBPMChange = t;
        bpmChangeInterval = getRandomInterval();
      }

      updateWaveform();
      drawCanvas();
      animationFrame = requestAnimationFrame(animate);
    }

    startBtn.onclick = () => {
      isRecording = true;
      isPaused = false;
      waveform = [];
      rPeaks = [];
      throbs = [];
      startTime = performance.now();
      pausedTime = 0;
      lastBPMChange = 0;
      bpm = getRandomBPM();
      bpmChangeInterval = getRandomInterval();

      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      markThrobBtn.disabled = false;
      resumeBtn.disabled = true;

      animate();
    };

    pauseBtn.onclick = () => {
      isPaused = true;
      pauseStart = performance.now();
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
      cancelAnimationFrame(animationFrame);
    };

    resumeBtn.onclick = () => {
      isPaused = false;
      pausedTime += performance.now() - pauseStart;
      resumeBtn.disabled = true;
      pauseBtn.disabled = false;
      animate();
    };

    stopBtn.onclick = () => {
      isRecording = false;
      cancelAnimationFrame(animationFrame);
      const name = prompt("Enter recording name:");
      if (name) {
        recordings.push({ name, rPeaks: [...rPeaks], throbs: [...throbs] });
        updateRecordingsList();
      }
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
      markThrobBtn.disabled = true;
      timerDisplay.textContent = "00:00.00";
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    markThrobBtn.onclick = () => {
      if (isRecording && !isPaused) {
        throbs.push(getTime());
      }
    };

    toggleView.onchange = () => {
      viewVisible = toggleView.checked;
      drawCanvas();
    };

    function updateRecordingsList() {
      recordingsDiv.innerHTML = '';
      recordings.forEach((rec, i) => {
        const div = document.createElement('div');
        div.className = 'recording-entry';
        const btn = document.createElement('button');
        btn.textContent = `Download CSV - ${rec.name}`;
        btn.onclick = () => downloadCSV(rec);
        div.appendChild(btn);
        recordingsDiv.appendChild(div);
      });
    }

    function downloadCSV(rec) {
      let csv = `Recording Name: ${rec.name}\n`;
      csv += `Total Throb Count: ${rec.throbs.length}\n`;
      csv += `Total Pulse Peak Count: ${rec.rPeaks.length}\n`;
      // Placeholder stats - You can add real stats here
      csv += `\nThrob Time (ms),Prior Pulse Peak Time (ms),Delta (ms),BPM at Peak\n`;

      for (let t of rec.throbs) {
        const prior = rec.rPeaks.filter(p => p.t <= t).pop();
        if (prior) {
          const delta = t - prior.t;
          csv += `${t.toFixed(2)},${prior.t.toFixed(2)},${delta.toFixed(2)},${prior.bpm}\n`;
        } else {
          csv += `${t.toFixed(2)},N/A,N/A,N/A\n`;
        }
      }

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${rec.name.replace(/\s+/g, '_')}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
