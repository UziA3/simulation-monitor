<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; margin-bottom: 10px; display: block; }
  button, label { margin: 5px; }
  .stats { margin-top: 10px; }
  #recordingsList { margin-top: 20px; }
  #recordingsList button { margin-left: 10px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<canvas id="canvas" width="800" height="200"></canvas><br>

<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<div class="controls">
  <button id="toggleAllBtn">Hide All Stats, Markings & Waveform</button>
</div>

<div class="stats" id="metricsDisplay"></div>

<div id="recordingsList">
  <h2>Saved Recordings</h2>
  <div id="recordingsContainer"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const toggleAllBtn = document.getElementById("toggleAllBtn");
  const recordingsContainer = document.getElementById("recordingsContainer");

  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;

  // Toggle flag for showing stats, markings & waveform
  let allVisible = true;

  // Saved recordings array
  const recordings = [];

  // Constants for waveform simulation
  const DISPLAY_DURATION = 20000; // 20 seconds window on canvas
  const SAMPLE_INTERVAL = 20; // 20 ms per sample
  const BASELINE = 100;
  const AMPLITUDE = 50;
  const FREQ = 1.2; // frequency in Hz (approx 72 bpm)

  // --- Simulation and Drawing ---

  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const noise = (Math.random() - 0.5) * 5;
      const value = BASELINE + AMPLITUDE * Math.sin(2 * Math.PI * FREQ * t) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  function draw() {
    simulatePulse();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!allVisible) {
      // Do not draw waveform, throbs or peaks
      if (isRecording && !isPaused) {
        animationId = requestAnimationFrame(draw);
      }
      return;
    }

    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    // Draw waveform line
    ctx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs (red circles)
    throbs.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValue(throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    });

    // Draw peaks (green circles)
    const peaks = findPeaks();
    peaks.forEach(peakTime => {
      if (peakTime < start || peakTime > now) return;
      const val = interpolatePulseValue(peakTime);
      if (val === null) return;
      const x = ((peakTime - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "green";
      ctx.fill();
    });

    if (isRecording && !isPaused) {
      animationId = requestAnimationFrame(draw);
    }
  }

  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  function findPeaks() {
    const peaks = [];
    const values = pulseWave.map(p => p.value);
    for (let i = 1; i < values.length - 1; i++) {
      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {
        peaks.push(pulseWave[i].time);
      }
    }
    return peaks;
  }

  // --- Temporal Synchrony Calculations ---

  function calculatePhase(t) {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;
    let prevPeak = null, nextPeak = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prevPeak = peaks[i];
        nextPeak = peaks[i + 1];
        break;
      }
    }
    if (prevPeak === null || nextPeak === null) return null;
    const phase = 2 * Math.PI * (t - prevPeak) / (nextPeak - prevPeak);
    return normalizeAngle(phase);
  }

  function normalizeAngle(angle) {
    let a = angle % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  function circularMean(angles) {
    if (angles.length === 0) return null;
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    let mean = Math.atan2(sumSin, sumCos);
    mean = normalizeAngle(mean);
    return mean;
  }

  function circularVariance(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    ) / n;
    return 1 - R;
  }

  function rayleighTest(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    );
    const z = (R * R) / n;
    return Math.exp(-z);
  }

  // Calculate PLV and related stats from throbs
  function calculatePLV() {
    throbs.forEach(throb => {
      throb.phase = calculatePhase(throb.time);
    });

    const validThrobs = throbs.filter(t => t.phase !== null);
    if (validThrobs.length === 0) {
      return { plv: 0, mean: null, variance: null, rayleigh: null };
    }

    const phases = validThrobs.map(t => t.phase);
    const mean = circularMean(phases);
    const variance = circularVariance(phases);
    const rayleigh = rayleighTest(phases);

    const sumReal = phases.reduce((a, p) => a + Math.cos(p), 0);
    const sumImag = phases.reduce((a, p) => a + Math.sin(p), 0);
    const plv = Math.sqrt(sumReal * sumReal + sumImag * sumImag) / phases.length;

    return { plv, mean, variance, rayleigh };
  }

  function calculateMedianPulseRate() {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;

    const intervals = [];
    for (let i = 1; i < peaks.length; i++) {
      intervals.push(peaks[i] - peaks[i - 1]);
    }
    intervals.sort((a, b) => a - b);

    const mid = Math.floor(intervals.length / 2);
    const medianInterval = intervals.length % 2 === 0
      ? (intervals[mid - 1] + intervals[mid]) / 2
      : intervals[mid];

    if (!medianInterval || medianInterval === 0) return null;
    return 60000 / medianInterval;
  }

  // --- Display Metrics ---

  function updateMetricsDisplay() {
    if (!allVisible) {
      metricsDisplay.innerHTML = "";
      return;
    }
    const stats = calculatePLV();
    const medianPulseRate = calculateMedianPulseRate();
    const totalPeaks = findPeaks().length;
    const totalThrobs = throbs.length;

    const lines = [];
    lines.push(`PLV: ${stats.plv.toFixed(4)}`);
    lines.push(`Mean Phase: ${stats.mean !== null ? stats.mean.toFixed(4) : "N/A"}`);
    lines.push(`Phase Variance: ${stats.variance !== null ? stats.variance.toFixed(4) : "N/A"}`);
    if (stats.rayleigh !== null) {
      lines.push(`Rayleigh p-value: ${stats.rayleigh < 0.0001 ? "<0.0001" : stats.rayleigh.toFixed(4)}`);
    } else {
      lines.push(`Rayleigh p-value: N/A`);
    }
    lines.push(`Median Pulse Rate (bpm): ${medianPulseRate !== null ? medianPulseRate.toFixed(2) : "N/A"}`);
    lines.push(`Total Peaks: ${totalPeaks}`);
    lines.push(`Total Throbs: ${totalThrobs}`);

    metricsDisplay.innerHTML = lines.map(line => `<div>${line}</div>`).join("");
  }

  // --- Timer Functions ---

  function updateTimer() {
    if (!recordingStartTime) return;
    let elapsed = performance.now() - recordingStartTime;
    if (isPaused) {
      elapsed = pauseTime - recordingStartTime;
    }
    const totalSeconds = Math.floor(elapsed / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    timerDisplay.textContent = `${minutes.toString().padStart(2,"0")}:${seconds.toString().padStart(2,"0")}`;
  }

  // --- Event Handlers ---

  startBtn.onclick = () => {
    if (isRecording) return;
    recordingStartTime = performance.now();
    pulseWave = [];
    throbs = [];
    isRecording = true;
    isPaused = false;
    updateMetricsDisplay();
    draw();
    timerInterval = setInterval(updateTimer, 200);
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    stopBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
  };

  pauseBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseTime = performance.now();
    clearInterval(timerInterval);
    if (animationId) cancelAnimationFrame(animationId);
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
  };

  resumeBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    // Adjust recordingStartTime to keep elapsed consistent
    const now = performance.now();
    const pausedDuration = now - pauseTime;
    recordingStartTime += pausedDuration;
    isPaused = false;
    updateTimer();
    timerInterval = setInterval(updateTimer, 200);
    draw();
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
  };

  stopBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    clearInterval(timerInterval);
    if (animationId) cancelAnimationFrame(animationId);
    updateMetricsDisplay();
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;

    // Save recording
    saveRecording();
    updateRecordingsList();
  };

  throbBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    throbs.push({ time: performance.now() });
    updateMetricsDisplay();
  };

  toggleAllBtn.onclick = () => {
    allVisible = !allVisible;
    if (allVisible) {
      toggleAllBtn.textContent = "Hide All Stats, Markings & Waveform";
    } else {
      toggleAllBtn.textContent = "Show All Stats, Markings & Waveform";
    }
    updateMetricsDisplay();
    draw();
  };

  // --- Saving and Exporting Recordings ---

  function saveRecording() {
    if (throbs.length === 0) return; // don't save empty
    const now = new Date();
    const timestampStr = now.toISOString().replace("T", " ").split(".")[0];
    const rec = {
      id: Date.now(),
      name: `Recording_${timestampStr}`,
      pulseWave: pulseWave.slice(),
      throbs: throbs.slice(),
      durationMs: performance.now() - recordingStartTime
    };
    recordings.push(rec);
  }

  function updateRecordingsList() {
    recordingsContainer.innerHTML = "";
    if (recordings.length === 0) {
      recordingsContainer.textContent = "No recordings saved yet.";
      return;
    }

    recordings.forEach(rec => {
      const div = document.createElement("div");
      div.style.marginBottom = "8px";

      const nameSpan = document.createElement("span");
      nameSpan.textContent = rec.name;
      nameSpan.style.fontWeight = "bold";

      const dlBtn = document.createElement("button");
      dlBtn.textContent = "Download CSV";
      dlBtn.onclick = () => {
        const csv = generateCSV(rec);
        downloadCSV(csv, rec.name + ".csv");
      };

      div.appendChild(nameSpan);
      div.appendChild(dlBtn);
      recordingsContainer.appendChild(div);
    });
  }

  // --- CSV Generation ---

  function formatTimeMs(timeMs) {
    return (timeMs / 1000).toFixed(2); // seconds with 2 decimals
  }

  function generateCSV(rec) {
    // Calculate stats
    const throbsWithPhase = rec.throbs.map(t => ({
      ...t,
      phase: calculatePhase(t.time)
    })).filter(t => t.phase !== null);

    const phases = throbsWithPhase.map(t => t.phase);

    // Recalculate stats on this recording's throbs:
    const meanPhase = circularMean(phases);
    const phaseVar = circularVariance(phases);
    const rayleighP = rayleighTest(phases);

    const n = phases.length;
    const sumReal = phases.reduce((a, p) => a + Math.cos(p), 0);
    const sumImag = phases.reduce((a, p) => a + Math.sin(p), 0);
    const plv = n === 0 ? 0 : Math.sqrt(sumReal * sumReal + sumImag * sumImag) / n;

    // Format header and rows
    let csv = `Throb #,Time (s),Phase (rad)\n`;
    throbsWithPhase.forEach((throb, i) => {
      csv += `${i + 1},${formatTimeMs(throb.time - rec.pulseWave[0].time)},${throb.phase.toFixed(4)}\n`;
    });

    csv += `\nOverall Statistics\n`;
    csv += `Total Throbs,${n}\n`;
    csv += `PLV,${plv.toFixed(4)}\n`;
    csv += `Mean Phase (rad),${meanPhase !== null ? meanPhase.toFixed(4) : "N/A"}\n`;
    csv += `Phase Variance,${phaseVar !== null ? phaseVar.toFixed(4) : "N/A"}\n`;
    csv += `Rayleigh p-value,${rayleighP !== null ? (rayleighP < 0.0001 ? "<0.0001" : rayleighP.toFixed(4)) : "N/A"}\n`;

    return csv;
  }

  function downloadCSV(csv, filename) {
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // --- Initialize ---

  updateRecordingsList();

})();
</script>

</body>
</html>
