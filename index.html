<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Migraine Throb Synchrony App</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin-bottom: 10px;
    }
    button {
      margin: 4px;
    }
    .recordings-list {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Migraine Throb Synchrony App</h1>
  <canvas id="ecgCanvas" width="1000" height="200"></canvas>
  <div>
    <button onclick="startRecording()">Start</button>
    <button onclick="pauseResumeRecording()">Pause/Resume</button>
    <button onclick="stopRecording()">Stop & Save</button>
    <button onclick="markThrob()">Mark Throb</button>
    <label><input type="checkbox" id="toggleDisplay" onchange="toggleWaveform()"> Show/Hide Waveform</label>
    <div id="timer">00:00.00</div>
  </div>
  <div class="recordings-list" id="recordingsList"></div>
  <script>
    const canvas = document.getElementById('ecgCanvas');
    const ctx = canvas.getContext('2d');
    const toggleDisplay = document.getElementById('toggleDisplay');
    const timerDisplay = document.getElementById('timer');

    let startTime, timerInterval, isPaused = false, pauseStart, pausedDuration = 0;
    let ecgData = [], rPeaks = [], throbs = [], bpm = 70, bpmChanges = [], phaseData = [];
    let lastBpmChange = 0, recording = false, canvasOffset = 0;
    let recordings = [];

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const ecgBuffer = 5000; // ms
    const PTT = 200; // ms pulse transit time offset for arterial pulse analysis

    function generateECGWave(t, bpm) {
      const beatInterval = 60000 / bpm;
      const timeInBeat = t % beatInterval;
      const phase = timeInBeat / beatInterval;
      let value = 0;
      value += Math.exp(-Math.pow((phase - 0.2) * 40, 2)) * 0.15; // P wave
      value += Math.exp(-Math.pow((phase - 0.3) * 200, 2)) * 1.5;  // R peak
      value -= Math.exp(-Math.pow((phase - 0.35) * 100, 2)) * 0.3; // S wave
      value += Math.exp(-Math.pow((phase - 0.5) * 60, 2)) * 0.5;   // T wave
      return value;
    }

    function updateTimer() {
      const now = performance.now();
      const elapsed = (now - startTime - pausedDuration) / 1000;
      const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const seconds = (elapsed % 60).toFixed(2).padStart(5, '0');
      timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    function scheduleNextBPMChange() {
      const delay = Math.random() * 4000 + 3000;
      setTimeout(() => {
        bpm = Math.floor(Math.random() * 41) + 60;
        lastBpmChange = performance.now();
        bpmChanges.push({ time: lastBpmChange - startTime, bpm });
        if (recording) scheduleNextBPMChange();
      }, delay);
    }

    function detectRPeaks() {
      rPeaks = [];
      const threshold = 0.5;  // Lowered threshold for peak detection
      for (let i = 1; i < ecgData.length - 1; i++) {
        const prev = ecgData[i - 1].value;
        const curr = ecgData[i].value;
        const next = ecgData[i + 1].value;
        if (curr > threshold && curr > prev && curr > next) {
          rPeaks.push({ time: ecgData[i].time, bpm: getBPMAt(ecgData[i].time) });
        }
      }
    }

    function getBPMAt(time) {
      let bpmVal = bpm;
      for (const change of bpmChanges) {
        if (time >= change.time) bpmVal = change.bpm;
        else break;
      }
      return bpmVal;
    }

    function drawECG() {
      if (!toggleDisplay.checked) return;
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      const currentTime = performance.now() - startTime - pausedDuration;
      const fromTime = currentTime - ecgBuffer;
      ctx.beginPath();
      ctx.moveTo(0, canvasHeight / 2);
      for (let i = 0; i < ecgData.length; i++) {
        const x = ((ecgData[i].time - fromTime) / ecgBuffer) * canvasWidth;
        const y = canvasHeight / 2 - ecgData[i].value * 80;
        if (x >= 0 && x <= canvasWidth) ctx.lineTo(x, y);
      }
      ctx.stroke();

      for (const peak of rPeaks) {
        const x = ((peak.time - fromTime) / ecgBuffer) * canvasWidth;
        if (x >= 0 && x <= canvasWidth) {
          ctx.beginPath();
          ctx.strokeStyle = 'red';
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.stroke();
        }
      }

      for (const throb of throbs) {
        const x = ((throb - fromTime) / ecgBuffer) * canvasWidth;
        if (x >= 0 && x <= canvasWidth) {
          ctx.beginPath();
          ctx.strokeStyle = 'green';
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = 'black';
    }

    function updateECG() {
      if (!recording || isPaused) return;
      const t = performance.now() - startTime - pausedDuration;
      const value = generateECGWave(t, bpm);
      ecgData.push({ time: t, value });
      if (ecgData.length > 10000) ecgData.shift();
      detectRPeaks();
      drawECG();
      updateTimer();
    }

    function startRecording() {
      recording = true;
      isPaused = false;
      pausedDuration = 0;
      throbs = [];
      ecgData = [];
      rPeaks = [];
      bpmChanges = [];
      phaseData = [];
      startTime = performance.now();
      bpmChanges.push({ time: 0, bpm });
      scheduleNextBPMChange();
      clearInterval(timerInterval);
      timerInterval = setInterval(updateECG, 20);
    }

    function pauseResumeRecording() {
      if (!recording) return;
      if (!isPaused) {
        isPaused = true;
        pauseStart = performance.now();
      } else {
        isPaused = false;
        pausedDuration += performance.now() - pauseStart;
      }
    }

    function stopRecording() {
      recording = false;
      clearInterval(timerInterval);
      const name = prompt("Enter recording name:");
      if (!name) return;
      const summary = computeStatistics();
      recordings.push({ name, summary });
      listRecordings();
    }

    function markThrob() {
      if (!recording || isPaused) return;
      const t = performance.now() - startTime - pausedDuration;
      throbs.push(t);
    }

    function computeStatistics() {
      phaseData = []; // Reset phaseData
      const data = throbs.map(throb => {
        const prior = rPeaks.filter(p => p.time <= throb).slice(-1)[0];
        const next = rPeaks.find(p => p.time > throb);
        const delta = prior ? throb - prior.time : null;
        const interval = prior && next ? next.time - prior.time : null;
        const phase = interval ? ((throb - prior.time) / interval) * 2 * Math.PI : null;
        if (phase != null) phaseData.push(phase);
        return {
          throbTime: throb,
          priorPeakTime: prior?.time ?? '',
          delta: delta ?? '',
          bpm: prior?.bpm ?? '',
          phase: phase ?? ''
        };
      });

      const R = calcRayleighR(phaseData);
      const p = calcRayleighP(R, phaseData.length);
      const PVL = R;
      const meanAngle = calcMeanAngle(phaseData);
      const deltaStd = std(data.map(d => d.delta).filter(d => d !== ''));

      return {
        data,
        totalThrobs: throbs.length,
        totalPeaks: rPeaks.length,
        meanBPM: (rPeaks.length / (ecgData[ecgData.length - 1].time / 60000)).toFixed(2),
        rayleighR: R.toFixed(4),
        rayleighP: p < 0.001 ? '<0.001' : p.toFixed(3),
        PVL: PVL.toFixed(4),
        deltaStd: deltaStd.toFixed(2),
        meanAngle: meanAngle.toFixed(4)
      };
    }

    function calcRayleighR(angles) {
      if (angles.length === 0) return 0;
      const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
      const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
      return Math.sqrt(sumSin * sumSin + sumCos * sumCos) / angles.length;
    }

    function calcRayleighP(R, n) {
      if (n === 0) return 1;
      const z = n * R * R;
      return Math.exp(-z) * (1 + (2 * z - z * z) / (4 * n) - (24 * z - 132 * z * z + 76 * z * z * z - 9 * z * z * z * z) / (288 * n * n));
    }

    function calcMeanAngle(angles) {
      if (angles.length === 0) return 0;
      const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
      const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
      return Math.atan2(sumSin / angles.length, sumCos / angles.length);
    }

    function std(values) {
      if (values.length === 0) return 0;
      const mean = values.reduce((a, b) => a + b) / values.length;
      return Math.sqrt(values.reduce((acc, v) => acc + (v - mean) ** 2, 0) / values.length);
    }

    function exportCSV(recording) {
      const { name, summary } = recording;
      const {
        data,
        totalThrobs,
        totalPeaks,
        meanBPM,
        rayleighR,
        rayleighP,
        PVL,
        deltaStd,
        meanAngle
      } = summary;

      let csv = `Recording Name,${name}\n`;
      csv += `Total Throb Count,${totalThrobs}\n`;
      csv += `Total R Peak Count,${totalPeaks}\n`;
      csv += `Mean BPM,${meanBPM}\n`;
      csv += `Rayleigh R,${rayleighR}\n`;
      csv += `Rayleigh p-value,${rayleighP}\n`;
      csv += `Phase Vector Length (PVL),${PVL}\n`;
      csv += `Std Dev of Delta (throb â€“ prior R),${deltaStd}\n`;
      csv += `Mean Vector Angle (radians),${meanAngle}\n`;
      csv += `Pulse Transit Time (PTT ms),${PTT}\n\n`;

      csv += `Throb Time (ms),Prior R Peak Time (ms),Delta (ms),BPM at prior R,Phase (radians)\n`;
      data.forEach(row => {
        csv += `${row.throbTime.toFixed(2)},${row.priorPeakTime.toFixed(2) || ''},${row.delta.toFixed(2) || ''},${row.bpm || ''},${row.phase.toFixed(4) || ''}\n`;
      });

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${name}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function listRecordings() {
      const listDiv = document.getElementById('recordingsList');
      listDiv.innerHTML = '';
      recordings.forEach((rec, i) => {
        const div = document.createElement('div');
        div.textContent = `${rec.name} - Throbs: ${rec.summary.totalThrobs}, Mean BPM: ${rec.summary.meanBPM}`;
        const btn = document.createElement('button');
        btn.textContent = 'Download CSV';
        btn.onclick = () => exportCSV(rec);
        div.appendChild(btn);
        listDiv.appendChild(div);
      });
    }

    function toggleWaveform() {
      if (!toggleDisplay.checked) ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    }
  </script>
</body>
</html>
