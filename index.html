<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony Web App</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1em;
    background: #f9f9f9;
    color: #222;
  }
  button {
    margin: 0.25em;
    padding: 0.5em 1em;
    font-size: 1em;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #777;
    background-color: #eee;
    transition: background-color 0.3s ease;
  }
  button:disabled {
    background-color: #ccc;
    cursor: default;
  }
  button:hover:not(:disabled) {
    background-color: #ddd;
  }
  #controls {
    margin-bottom: 1em;
  }
  #timer {
    font-size: 1.2em;
    margin-left: 1em;
    font-family: monospace;
  }
  canvas {
    border: 1px solid #ccc;
    background: white;
    display: block;
    margin-bottom: 1em;
    width: 100%;
    max-width: 800px;
    height: 150px;
  }
  #recordings-list {
    margin-top: 1em;
  }
  .recording-item {
    margin-bottom: 0.5em;
    padding: 0.25em 0.5em;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 800px;
  }
  .recording-name {
    font-weight: bold;
  }
  .download-btn {
    text-decoration: none;
    color: white;
    background: #007bff;
    padding: 0.3em 0.7em;
    border-radius: 4px;
  }
  .download-btn:hover {
    background: #0056b3;
  }
  label {
    font-weight: normal;
    margin-left: 1em;
    user-select: none;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony Web App</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
  <label><input type="checkbox" id="showWaveformToggle" checked /> Show Waveform</label>
  <span id="timer">00:00.00</span>
</div>

<canvas id="ecgCanvas" width="800" height="150"></canvas>

<div id="recordings-list"></div>

<script>
(() => {
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const showWaveformToggle = document.getElementById('showWaveformToggle');
  const timerEl = document.getElementById('timer');
  const recordingsList = document.getElementById('recordings-list');

  // Constants for ECG simulation
  const sampleInterval = 10; // ms between samples (100Hz)
  const displayDuration = 5000; // ms - show 5 seconds on canvas
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  // State variables
  let running = false;
  let paused = false;
  let startTime = 0;
  let pauseStartTime = 0;
  let elapsedPauseTime = 0;
  let elapsed = 0;

  let waveformSamples = []; // {time, value}
  let rPeaks = [];          // {time, bpm, value}
  let throbs = [];          // [time in ms]

  let currentBpm = 75;
  let bpmChangeTime = 0;
  let nextBpmChangeInterval = 0;

  let animationFrameId;
  let showWaveform = true;

  // ECG waveform components (approximate Gaussians)
  // Times relative to R peak (ms) and amplitudes
  const ecgComponents = [
    { time: -200, amp: 0.25, width: 40 },  // P wave
    { time: -50, amp: -0.15, width: 15 },  // Q wave
    { time: 0, amp: 1.0, width: 10 },      // R wave (peak)
    { time: 50, amp: -0.4, width: 20 },    // S wave
    { time: 150, amp: 0.3, width: 40 },    // T wave
  ];

  function gaussian(x, mu, sigma) {
    return Math.exp(-((x - mu) ** 2) / (2 * sigma ** 2));
  }

  // Simulate ECG sample at given absolute time (ms)
  function simulateEcgSample(time) {
    // Find current beat start time (R peak) and BPM at that time
    // BPM changes every 3-7 seconds, stored at bpmChangeTime with currentBpm
    // To find phase in cardiac cycle, find last R peak time before "time"
    if (rPeaks.length === 0) return 0;

    // Find last R peak before or equal to "time"
    let lastPeak = null;
    for (let i = rPeaks.length - 1; i >= 0; i--) {
      if (rPeaks[i].time <= time) {
        lastPeak = rPeaks[i];
        break;
      }
    }
    if (!lastPeak) return 0;

    // Calculate relative time from last R peak
    const dt = time - lastPeak.time;

    // Calculate beat duration in ms (60000/BPM)
    const beatDuration = 60000 / lastPeak.bpm;

    // If dt is beyond beat duration, simulate next beats (waveformSamples builds as we go)
    if (dt < 0 || dt > beatDuration) return 0;

    // Sum ECG components at relative dt
    let val = 0;
    for (const comp of ecgComponents) {
      val += comp.amp * gaussian(dt, comp.time, comp.width);
    }
    return val;
  }

  // Generate next R peak time and bpm after bpmChangeTime + nextBpmChangeInterval
  function randomInterval() {
    return 3000 + Math.random() * 4000; // 3-7 seconds
  }
  function randomBpm() {
    return Math.floor(60 + Math.random() * 41); // 60-100 BPM
  }

  // Generate R peaks ahead of time
  function generateRPeaksUntil(time) {
    if (rPeaks.length === 0) {
      // First peak at 0 ms
      rPeaks.push({ time: 0, bpm: currentBpm, value: 1.0 });
      bpmChangeTime = 0;
      nextBpmChangeInterval = randomInterval();
      currentBpm = randomBpm();
    }
    while (rPeaks[rPeaks.length - 1].time < time) {
      const lastPeak = rPeaks[rPeaks.length - 1];
      const beatDuration = 60000 / lastPeak.bpm;
      const nextTime = lastPeak.time + beatDuration;
      // Change BPM if nextTime > bpmChangeTime + nextBpmChangeInterval
      if (nextTime - bpmChangeTime > nextBpmChangeInterval) {
        bpmChangeTime += nextBpmChangeInterval;
        currentBpm = randomBpm();
        nextBpmChangeInterval = randomInterval();
      }
      rPeaks.push({ time: nextTime, bpm: currentBpm, value: 1.0 });
    }
  }

  // Update waveformSamples for elapsed time, simulate ECG samples every sampleInterval ms
  function updateWaveformSamples(elapsed) {
    const lastTime = waveformSamples.length > 0 ? waveformSamples[waveformSamples.length - 1].time : -sampleInterval;
    generateRPeaksUntil(elapsed + displayDuration); // generate R peaks for next displayDuration
    let t = lastTime + sampleInterval;
    while (t <= elapsed + displayDuration) {
      const val = simulateEcgSample(t);
      waveformSamples.push({ time: t, value: val });
      t += sampleInterval;
    }
  }

  // Draw ECG waveform, R peaks, and throb markers on canvas
  function drawWaveform() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (!showWaveform) return;

    // Time window on screen: [elapsed - displayDuration, elapsed]
    const windowStart = Math.max(0, elapsed - displayDuration);
    const windowEnd = elapsed;

    // Draw ECG waveform line
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.beginPath();

    let started = false;
    for (let i = 0; i < waveformSamples.length; i++) {
      const sample = waveformSamples[i];
      if (sample.time < windowStart) continue;
      if (sample.time > windowEnd) break;
      const x = ((sample.time - windowStart) / displayDuration) * canvasWidth;
      // ECG signal scaled and inverted to fit canvas (max amplitude ~1.3)
      const y = canvasHeight / 2 - sample.value * 50;
      if (!started) {
        ctx.moveTo(x, y);
        started = true;
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();

    // Draw R peaks as red vertical lines
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 1.5;
    for (const peak of rPeaks) {
      if (peak.time < windowStart) continue;
      if (peak.time > windowEnd) break;
      const x = ((peak.time - windowStart) / displayDuration) * canvasWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }

    // Draw throbs as green vertical lines
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 1.5;
    for (const throbTime of throbs) {
      if (throbTime < windowStart) continue;
      if (throbTime > windowEnd) break;
      const x = ((throbTime - windowStart) / displayDuration) * canvasWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvasHeight);
      ctx.stroke();
    }
  }

  // Circular statistics functions
  function vectorLength(angles) {
    if (angles.length === 0) return 0;
    let sumX = 0;
    let sumY = 0;
    for (const a of angles) {
      sumX += Math.cos(a);
      sumY += Math.sin(a);
    }
    return Math.sqrt(sumX * sumX + sumY * sumY) / angles.length;
  }

  function meanAngle(angles) {
    if (angles.length === 0) return 0;
    let sumX = 0;
    let sumY = 0;
    for (const a of angles) {
      sumX += Math.cos(a);
      sumY += Math.sin(a);
    }
    return Math.atan2(sumY, sumX);
  }

  // Rayleigh p-value approximation for sample size n and vector length R
  function rayleighPValue(R, n) {
    if (n === 0) return 1;
    const z = n * R * R;
    return Math.exp(-z) * (1 + (2 * z - z * z) / (4 * n) - (24 * z - 132 * z * z + 76 * z * z * z - 9 * z * z * z * z) / (288 * n * n));
  }

  function stdDev(arr) {
    if (arr.length === 0) return 0;
    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
    const variance = arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
    return Math.sqrt(variance);
  }

  // Timer update (mm:ss.ss)
  function updateTimer() {
    if (!running) return;
    let currentTime = performance.now();
    elapsed = currentTime - startTime - elapsedPauseTime;
    // Format mm:ss.ss with two decimals for hundredths
    const totalSeconds = elapsed / 1000;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    timerEl.textContent = 
      `${String(minutes).padStart(2, '0')}:` +
      `${seconds.toFixed(2).padStart(5, '0')}`;
  }

  // Main animation loop
  function animate() {
    if (!running || paused) {
      animationFrameId = requestAnimationFrame(animate);
      return;
    }
    updateTimer();
    updateWaveformSamples(elapsed);
    drawWaveform();
    animationFrameId = requestAnimationFrame(animate);
  }

  // Reset all data
  function reset() {
    waveformSamples = [];
    rPeaks = [];
    throbs = [];
    currentBpm = 75;
    bpmChangeTime = 0;
    nextBpmChangeInterval = 0;
    elapsedPauseTime = 0;
    elapsed = 0;
    startTime = 0;
    pauseStartTime = 0;
    timerEl.textContent = '00:00.00';
  }

  // Save recording and generate CSV
  function saveRecording() {
    if (rPeaks.length === 0) {
      alert('No data to save.');
      return;
    }
    let recName = prompt('Enter recording name:', `Recording ${recordingsList.children.length + 1}`);
    if (!recName) recName = `Recording ${recordingsList.children.length + 1}`;

    // Associate each throb with immediately preceding R peak (not nearest)
    // If no preceding peak, keep throb but mark as N/A for calculations
    const throbData = throbs.map(throbTime => {
      // Find preceding R peak
      const precedingPeaks = rPeaks.filter(rp => rp.time <= throbTime);
      if (precedingPeaks.length === 0) {
        // No preceding peak; return partial data with N/A fields
        return {
          throbTime,
          priorPeakTime: 'N/A',
          delta: 'N/A',
          bpm: 'N/A',
          phase: 'N/A',
          valid: false
        };
      }
      const priorPeak = precedingPeaks[precedingPeaks.length - 1];
      // Find next peak after priorPeak
      const followingPeaks = rPeaks.filter(rp => rp.time > priorPeak.time);
      const nextPeak = followingPeaks.length > 0 ? followingPeaks[0] : null;

      const delta = throbTime - priorPeak.time; // ms
      let phase = 0;
      if (nextPeak) {
        const interval = nextPeak.time - priorPeak.time;
        if (interval > 0) {
          phase = (delta / interval) * 2 * Math.PI;
        }
      }
      return {
        throbTime,
        priorPeakTime: priorPeak.time,
        delta,
        bpm: priorPeak.bpm,
        phase,
        valid: true
      };
    });

    // Filter only throbs with valid phases for circular stats
    const validThrobs = throbData.filter(d => d.valid);

    // Mean BPM across all R peaks
    const meanBpm = rPeaks.length > 0 ? rPeaks.reduce((a, r) => a + r.bpm, 0) / rPeaks.length : 0;

    // Circular statistics only on valid throbs
    const phases = validThrobs.map(d => d.phase);
    const R = vectorLength(phases);
    const n = phases.length;
    const pValueRaw = rayleighPValue(R, n);
    const pValue = pValueRaw < 0.001 ? '<0.001' : pValueRaw.toFixed(3);
    const PVL = R;
    const meanVecAngle = meanAngle(phases);
    const deltaStdDev = validThrobs.length > 0 ? stdDev(validThrobs.map(d => d.delta)) : 0;

    // CSV content generation
    let csv = '';
    csv += `Recording Name:,${recName}\n`;
    csv += `Total Throb Count:,${throbs.length}\n`; // Total number of throbs logged
    csv += `Total Pulse Peak Count:,${rPeaks.length}\n`;
    csv += `Mean Pulse Rate (BPM):,${meanBpm.toFixed(2)}\n`;
    csv += `Rayleigh R:,${R.toFixed(4)}\n`;
    csv += `Rayleigh p-value:,${pValue}\n`;
    csv += `PVL:,${PVL.toFixed(4)}\n`;
    csv += `Std Dev of Deltas (ms):,${deltaStdDev.toFixed(2)}\n`;
    csv += `Mean Vector Angle (rad):,${meanVecAngle.toFixed(4)}\n\n`;

    csv += 'Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)\n';
    throbData.forEach(d => {
      csv += `${typeof d.throbTime === 'number' ? d.throbTime.toFixed(2) : d.throbTime},${typeof d.priorPeakTime === 'number' ? d.priorPeakTime.toFixed(2) : d.priorPeakTime},${typeof d.delta === 'number' ? d.delta.toFixed(2) : d.delta},${d.bpm},${typeof d.phase === 'number' ? d.phase.toFixed(4) : d.phase}\n`;
    });

    // Create downloadable blob
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    // Add recording to list with download link
    const div = document.createElement('div');
    div.className = 'recording-item';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'recording-name';
    nameSpan.textContent = recName;
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = `${recName.replace(/\s+/g, '_')}.csv`;
    downloadLink.textContent = 'Download CSV';
    downloadLink.className = 'download-btn';

    div.appendChild(nameSpan);
    div.appendChild(downloadLink);
    recordingsList.appendChild(div);

    // Reset for next recording
    reset();
    updateButtonsState(false, false, false, false, false);
  }

  // Button state control
  function updateButtonsState(startEnabled, pauseEnabled, resumeEnabled, stopEnabled, markEnabled) {
    startBtn.disabled = !startEnabled;
    pauseBtn.disabled = !pauseEnabled;
    resumeBtn.disabled = !resumeEnabled;
    stopBtn.disabled = !stopEnabled;
    markThrobBtn.disabled = !markEnabled;
  }

  // Button handlers
  startBtn.onclick = () => {
    if (running) return;
    reset();
    running = true;
    paused = false;
    startTime = performance.now();
    elapsedPauseTime = 0;
    updateButtonsState(false, true, false, true, true);
    animate();
  };

  pauseBtn.onclick = () => {
    if (!running || paused) return;
    paused = true;
    pauseStartTime = performance.now();
    updateButtonsState(false, false, true, true, false);
  };

  resumeBtn.onclick = () => {
    if (!running || !paused) return;
    paused = false;
    elapsedPauseTime += performance.now() - pauseStartTime;
    pauseStartTime = 0;
    updateButtonsState(false, true, false, true, true);
  };

  stopBtn.onclick = () => {
    if (!running) return;
    running = false;
    paused = false;
    cancelAnimationFrame(animationFrameId);
    updateTimer();
    saveRecording();
  };

  markThrobBtn.onclick = () => {
    if (!running || paused) return;
    const now = elapsed;
    throbs.push(now);
  };

  showWaveformToggle.onchange = () => {
    showWaveform = showWaveformToggle.checked;
  };

  updateButtonsState(true, false, false, false, false);
})();
</script>
</body>
</html>
