<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor with CSV Export</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; display: block; margin-bottom: 10px; }
  button, input[type="text"] { margin: 5px; }
  .stats { margin-top: 10px; font-size: 14px; }
  .recordings-list { margin-top: 20px; border-top: 1px solid #999; padding-top: 10px; max-width: 600px;}
  .recording-item { margin-bottom: 8px; background: #f9f9f9; padding: 6px; border-radius: 4px; display: flex; align-items: center; }
  .recording-item input.name-input {
    flex-grow: 1;
    padding: 3px;
    margin-right: 10px;
    font-size: 14px;
  }
  .recording-item button {
    margin-left: 6px;
    font-size: 13px;
  }
  #extraStats {
    margin-top: 12px;
    font-weight: bold;
    font-size: 15px;
  }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<canvas id="canvas" width="800" height="200"></canvas>

<div>
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <button id="toggleAllBtn">Hide Waveform</button>
  <button id="downloadCSVBtn" disabled>Download CSV</button>
</div>

<div>Timer: <span id="timer">00:00</span></div>

<div class="stats" id="metricsDisplay"></div>

<!-- Overall mean pulse rate and peaks info -->
<div id="extraStats"></div>

<div class="recordings-list" id="recordingsList">
  <h3>Saved Recordings</h3>
  <div id="recordingsContainer">No recordings saved yet.</div>
</div>

<script>
(() => {
  // === Setup ===
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const toggleAllBtn = document.getElementById("toggleAllBtn");
  const downloadCSVBtn = document.getElementById("downloadCSVBtn");

  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const extraStatsDisplay = document.getElementById("extraStats");
  const recordingsContainer = document.getElementById("recordingsContainer");

  // === Variables ===
  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;
  let allVisible = true;

  // Random pulse rate between 60-100 bpm -> Hz = bpm/60
  let pulseBpm = 60;
  let baseFreq = pulseBpm / 60;

  const savedRecordings = [];
  let selectedRecordingIndex = null;

  const DISPLAY_DURATION = 20000; // 20 seconds for drawing waveform
  const SAMPLE_INTERVAL = 20; // ms

  const BASELINE = 120;
  const AMPLITUDE = 70;

  // --- Arterial waveform with two peaks per cycle ---
  // Normalized t [0,1) for pulse phase
  function arterialWaveform(t) {
    t = t % 1;
    if (t < 0.15) {
      return BASELINE + AMPLITUDE * (t / 0.15);
    } else if (t < 0.25) {
      return BASELINE + AMPLITUDE * (1 - (t - 0.15) / 0.1 * 0.8);
    } else if (t < 0.4) {
      return BASELINE + AMPLITUDE * (0.2 + 0.5 * Math.sin(((t - 0.25) / 0.15) * Math.PI));
    } else if (t < 0.7) {
      return BASELINE + AMPLITUDE * (0.2 * (1 - (t - 0.4) / 0.3));
    } else {
      return BASELINE;
    }
  }

  // --- Helpers ---
  function formatTimer(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const m = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
    const s = String(totalSeconds % 60).padStart(2, "0");
    return `${m}:${s}`;
  }

  // Interpolate pulseWave value at given time (linear interpolation)
  function interpolatePulseValueIn(wave, time) {
    if (!wave.length) return null;
    // Binary search for closest two points
    let left = 0, right = wave.length - 1;
    if (time < wave[0].time) return null;
    if (time > wave[right].time) return null;

    while (left < right - 1) {
      const mid = Math.floor((left + right) / 2);
      if (wave[mid].time > time) right = mid;
      else left = mid;
    }
    // Linear interp between left and right
    const p1 = wave[left];
    const p2 = wave[right];
    const dt = p2.time - p1.time;
    if (dt === 0) return p1.value;
    const frac = (time - p1.time) / dt;
    return p1.value + frac * (p2.value - p1.value);
  }

  // Find peaks (maxima) in the waveform using a window method (peak must be max in +- 50ms)
  function findPeaksIn(wave) {
    const peaks = [];
    const windowMs = 50;
    for (let i = 1; i < wave.length - 1; i++) {
      const p = wave[i];
      if (p.value > wave[i-1].value && p.value > wave[i+1].value) {
        // Check no higher point in window around p
        const tLow = p.time - windowMs;
        const tHigh = p.time + windowMs;
        let isPeak = true;
        for (let j = 0; j < wave.length; j++) {
          if (wave[j].time >= tLow && wave[j].time <= tHigh && wave[j].value > p.value) {
            isPeak = false;
            break;
          }
        }
        if (isPeak) peaks.push(p.time);
      }
    }
    return peaks;
  }

  // Calculate phase of each pulse peak in radians
  // Using detected peaks, phase = (peak_time % pulse_period) / pulse_period * 2pi
  function getPhasesFromPeaks(peaks, pulsePeriod) {
    return peaks.map(t => ((t % pulsePeriod) / pulsePeriod) * 2 * Math.PI);
  }

  // Calculate Mean Vector Length (PLV)
  function meanVectorLength(phases) {
    if (!phases.length) return 0;
    let x = 0, y = 0;
    for (const p of phases) {
      x += Math.cos(p);
      y += Math.sin(p);
    }
    x /= phases.length;
    y /= phases.length;
    return Math.sqrt(x*x + y*y);
  }

  // Calculate Rayleigh Test p-value for uniformity
  function rayleighP(phases) {
    if (!phases.length) return 1;
    const n = phases.length;
    const R = meanVectorLength(phases);
    const z = n * R * R;
    // Approximate p-value
    return Math.exp(-z) * (1 + (2*z - z*z)/(4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z)/(288*n*n));
  }

  // Calculate synchrony metrics for throbs relative to peaks
  // throbs are timestamps; peaks are timestamps of main peaks (first peaks)
  // For each throb, find closest peak before throb, compute phase difference
  // Return deltaThrobs array, mean vector length (PLV), Rayleigh p
  function calculateSynchrony(throbs, peaks, pulsePeriod) {
    if (throbs.length === 0 || peaks.length === 0) {
      return { deltaThrobs: [], plv: 0, rayleighPval: 1 };
    }
    // For each throb, find preceding peak
    const deltaThrobs = [];
    const phases = [];

    throbs.forEach(throbTime => {
      // Find last peak before throbTime
      let peakBefore = null;
      for (let i = peaks.length - 1; i >= 0; i--) {
        if (peaks[i] <= throbTime) {
          peakBefore = peaks[i];
          break;
        }
      }
      if (peakBefore === null) {
        // No preceding peak (throb before recording start), skip
        return;
      }
      // Delta time from peak in seconds
      const dt = (throbTime - peakBefore) / 1000;
      // Normalize to phase: delta phase = (dt / pulsePeriod) * 2pi
      const deltaPhase = (dt / pulsePeriod) * 2 * Math.PI;
      // Map deltaPhase into [-pi, pi]
      let dp = deltaPhase;
      while (dp > Math.PI) dp -= 2 * Math.PI;
      while (dp < -Math.PI) dp += 2 * Math.PI;
      deltaThrobs.push(dp);
      phases.push(dp);
    });

    const plv = meanVectorLength(phases);
    const pval = rayleighP(phases);
    return { deltaThrobs, plv, rayleighPval: pval };
  }

  // === Recording management ===
  function addRecording(name, pulseWaveData, throbsData, pulseBpmVal, statsObj) {
    savedRecordings.push({
      name,
      pulseWave: pulseWaveData.slice(),
      throbs: throbsData.slice(),
      pulseBpm: pulseBpmVal,
      stats: statsObj
    });
    renderRecordingsList();
  }

  function renderRecordingsList() {
    if (!savedRecordings.length) {
      recordingsContainer.textContent = "No recordings saved yet.";
      return;
    }
    recordingsContainer.innerHTML = "";
    savedRecordings.forEach((rec, i) => {
      const div = document.createElement("div");
      div.className = "recording-item";

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = rec.name || `Recording ${i+1}`;
      nameInput.className = "name-input";
      nameInput.addEventListener("change", () => {
        rec.name = nameInput.value;
      });

      const loadBtn = document.createElement("button");
      loadBtn.textContent = "Load";
      loadBtn.addEventListener("click", () => {
        selectedRecordingIndex = i;
        updateUIForLoadedRecording();
      });

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", () => {
        if (selectedRecordingIndex === i) selectedRecordingIndex = null;
        savedRecordings.splice(i, 1);
        renderRecordingsList();
        clearCanvasAndUI();
      });

      const downloadBtn = document.createElement("button");
      downloadBtn.textContent = "Download CSV";
      downloadBtn.addEventListener("click", () => {
        downloadCSVForRecording(i);
      });

      div.appendChild(nameInput);
      div.appendChild(loadBtn);
      div.appendChild(deleteBtn);
      div.appendChild(downloadBtn);
      recordingsContainer.appendChild(div);
    });
  }

  function updateUIForLoadedRecording() {
    if (selectedRecordingIndex === null) {
      extraStatsDisplay.textContent = "";
      metricsDisplay.textContent = "";
      downloadCSVBtn.disabled = true;
      return;
    }
    const rec = savedRecordings[selectedRecordingIndex];
    extraStatsDisplay.textContent = `Mean Pulse Rate: ${rec.pulseBpm.toFixed(1)} bpm | Number of Peaks: ${rec.stats.numPeaks}`;
    metricsDisplay.textContent = `PLV: ${rec.stats.plv.toFixed(3)} | Rayleigh p: ${rec.stats.rayleighPval.toExponential(2)}`;
    downloadCSVBtn.disabled = false;
  }

  function clearCanvasAndUI() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    extraStatsDisplay.textContent = "";
    metricsDisplay.textContent = "";
  }

  // === Draw waveform and throbs ===
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!allVisible) return;

    let waveToDraw, throbsToDraw;

    if (selectedRecordingIndex !== null) {
      const rec = savedRecordings[selectedRecordingIndex];
      waveToDraw = rec.pulseWave;
      throbsToDraw = rec.throbs;
    } else {
      waveToDraw = pulseWave;
      throbsToDraw = throbs;
    }
    if (!waveToDraw.length) return;

    const now = selectedRecordingIndex !== null
      ? waveToDraw[waveToDraw.length - 1].time
      : performance.now();

    const start = now - DISPLAY_DURATION;

    // Draw waveform line
    ctx.beginPath();
    waveToDraw.forEach((p, i) => {
      if (p.time < start) return;
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0 || waveToDraw[i - 1].time < start) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs
    throbsToDraw.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValueIn(waveToDraw, throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    });

    // Draw first peaks in green (only first peak of each pulse cycle)
    // We find peaks, then filter those corresponding to first peak in cycle (~0 to 0.15 pulse phase)
    const peaks = findPeaksIn(waveToDraw);
    const pulsePeriod = 60000 / pulseBpm; // ms period

    // We calculate phase of each peak and only keep those where phase < 0.15 normalized
    const filteredPeaks = peaks.filter(t => {
      const phase = ((t % pulsePeriod) / pulsePeriod);
      return phase < 0.15;
    });

    filteredPeaks.forEach(pt => {
      if (pt < start || pt > now) return;
      const val = interpolatePulseValueIn(waveToDraw, pt);
      if (val === null) return;
      const x = ((pt - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "green";
      ctx.fill();
    });
  }

  // === Simulation ===
  function simulatePulse() {
    if (!isRecording || isPaused) return;
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = (now - recordingStartTime) / 1000;
      const cycleTime = (baseFreq * t) % 1;
      const noise = (Math.random() - 0.5) * 3;
      const value = arterialWaveform(cycleTime) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    // Limit stored data to 5 minutes
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  // === Timer display update ===
  function updateTimer() {
    if (!recordingStartTime) {
      timerDisplay.textContent = "00:00";
      return;
    }
    const elapsed = isPaused ? pauseStartTime - recordingStartTime : performance.now() - recordingStartTime;
    timerDisplay.textContent = formatTimer(elapsed);
  }

  // === Throb button action ===
  function markThrob() {
    if (!isRecording) return;
    const now = performance.now();
    throbs.push({ time: now });
    updateStatsDisplay();
  }

  // === Calculate stats and update display ===
  function updateStatsDisplay() {
    if (!pulseWave.length) {
      metricsDisplay.textContent = "";
      extraStatsDisplay.textContent = "";
      return;
    }
    // Calculate peaks on current pulseWave
    const peaksAll = findPeaksIn(pulseWave);
    const pulsePeriod = 60000 / pulseBpm; // ms

    // Filter first peaks per pulse cycle (phase < 0.15)
    const firstPeaks = peaksAll.filter(t => {
      const phase = ((t % pulsePeriod) / pulsePeriod);
      return phase < 0.15;
    });

    // Calculate phases of first peaks (not necessarily used here but for clarity)
    const peakPhases = getPhasesFromPeaks(firstPeaks, pulsePeriod);

    // Calculate synchrony with throbs
    const synchrony = calculateSynchrony(throbs.map(t => t.time), firstPeaks, pulsePeriod);

    // Show PLV, Rayleigh p-value, number of peaks, pulse BPM
    metricsDisplay.textContent = `PLV: ${synchrony.plv.toFixed(3)} | Rayleigh p: ${synchrony.rayleighPval.toExponential(2)} | Number of Peaks: ${firstPeaks.length}`;

    extraStatsDisplay.textContent = `Mean Pulse Rate: ${pulseBpm.toFixed(1)} bpm`;

    // Enable CSV download if throbs present
    downloadCSVBtn.disabled = throbs.length === 0;
  }

  // === Export CSV ===
  function downloadCSVForRecording(index = null) {
    let pwave, throbsData, pulseRateVal, stats;
    if (index !== null) {
      const rec = savedRecordings[index];
      pwave = rec.pulseWave;
      throbsData = rec.throbs;
      pulseRateVal = rec.pulseBpm;
      stats = rec.stats;
    } else {
      pwave = pulseWave;
      throbsData = throbs;
      pulseRateVal = pulseBpm;
      // Compute stats on current data
      const peaksAll = findPeaksIn(pwave);
      const pulsePeriod = 60000 / pulseRateVal;
      const firstPeaks = peaksAll.filter(t => ((t % pulsePeriod) / pulsePeriod) < 0.15);
      const synchrony = calculateSynchrony(throbsData.map(t => t.time), firstPeaks, pulsePeriod);
      stats = {
        plv: synchrony.plv,
        rayleighPval: synchrony.rayleighPval,
        numPeaks: firstPeaks.length
      };
    }

    const pulsePeriod = 60000 / pulseRateVal;
    // Calculate first peaks again for CSV
    const peaksAll = findPeaksIn(pwave);
    const firstPeaks = peaksAll.filter(t => ((t % pulsePeriod) / pulsePeriod) < 0.15);

    // Calculate delta throb for each throb for CSV
    const deltaThrobsForCSV = [];
    throbsData.forEach(throb => {
      // Find preceding peak
      let peakBefore = null;
      for (let i = firstPeaks.length - 1; i >= 0; i--) {
        if (firstPeaks[i] <= throb.time) {
          peakBefore = firstPeaks[i];
          break;
        }
      }
      if (peakBefore === null) {
        deltaThrobsForCSV.push("");
        return;
      }
      // delta time in seconds
      const dt = (throb.time - peakBefore) / 1000;
      // delta phase in radians (-pi to pi)
      let dp = (dt / pulsePeriod) * 2 * Math.PI;
      while (dp > Math.PI) dp -= 2 * Math.PI;
      while (dp < -Math.PI) dp += 2 * Math.PI;
      deltaThrobsForCSV.push(dp.toFixed(4));
    });

    // Build CSV content
    let csvContent = "time(ms),value\n";
    pwave.forEach(p => {
      csvContent += `${Math.round(p.time)},${p.value.toFixed(2)}\n`;
    });

    csvContent += "\nThrobs (time ms),Delta Throb (radians)\n";
    throbsData.forEach((t, i) => {
      csvContent += `${Math.round(t.time)},${deltaThrobsForCSV[i]}\n`;
    });

    csvContent += `\nMean Pulse Rate (bpm),${pulseRateVal.toFixed(2)}\n`;
    csvContent += `Number of Peaks,${stats.numPeaks}\n`;
    csvContent += `PLV,${stats.plv.toFixed(4)}\n`;
    csvContent += `Rayleigh p-value,${stats.rayleighPval.toExponential(6)}\n`;

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = (index !== null ? savedRecordings[index].name : "recording") + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // === Button handlers ===
  let pauseStartTime = null;

  startBtn.onclick = () => {
    if (isRecording) return;
    // Reset data
    pulseWave = [];
    throbs = [];
    recordingStartTime = performance.now();
    lastSampleTime = recordingStartTime;
    isRecording = true;
    isPaused = false;

    // Random pulse bpm between 60 and 100
    pulseBpm = 60 + Math.random() * 40;
    baseFreq = pulseBpm / 60;

    // Enable/disable buttons
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    downloadCSVBtn.disabled = true;

    timerInterval = setInterval(() => {
      updateTimer();
      simulatePulse();
      updateStatsDisplay();
      draw();
    }, SAMPLE_INTERVAL);

  };

  pauseBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseStartTime = performance.now();
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
  };

  resumeBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    // Adjust recordingStartTime so timer continues correctly
    const pausedDuration = performance.now() - pauseStartTime;
    recordingStartTime += pausedDuration;
    lastSampleTime += pausedDuration;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
  };

  stopBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    clearInterval(timerInterval);
    updateTimer();
    updateStatsDisplay();
    draw();

    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    startBtn.disabled = false;
    downloadCSVBtn.disabled = throbs.length === 0;

    // Auto-save recording (prompt for name)
    let recName = prompt("Enter name for recording:", `Recording_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}`);
    if (recName === null || recName.trim() === "") recName = `Recording_${savedRecordings.length+1}`;
    // Calculate stats to save
    const peaksAll = findPeaksIn(pulseWave);
    const pulsePeriod = 60000 / pulseBpm;
    const firstPeaks = peaksAll.filter(t => ((t % pulsePeriod) / pulsePeriod) < 0.15);
    const synchrony = calculateSynchrony(throbs.map(t => t.time), firstPeaks, pulsePeriod);

    addRecording(recName, pulseWave, throbs, pulseBpm, {
      plv: synchrony.plv,
      rayleighPval: synchrony.rayleighPval,
      numPeaks: firstPeaks.length,
    });
    selectedRecordingIndex = savedRecordings.length - 1;
    updateUIForLoadedRecording();
  };

  throbBtn.onclick = () => {
    markThrob();
  };

  toggleAllBtn.onclick = () => {
    allVisible = !allVisible;
    toggleAllBtn.textContent = allVisible ? "Hide Waveform" : "Show Waveform";
    draw();
  };

  downloadCSVBtn.onclick = () => {
    if (selectedRecordingIndex !== null) {
      downloadCSVForRecording(selectedRecordingIndex);
    } else {
      downloadCSVForRecording();
    }
  };

  // Initial render of recordings list
  renderRecordingsList();

  // Initial empty draw
  clearCanvasAndUI();

})();
</script>

</body>
</html>
