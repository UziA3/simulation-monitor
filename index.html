<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #222;
  }
  h1 {
    text-align: center;
  }
  #controls {
    text-align: center;
    margin-bottom: 10px;
  }
  button {
    margin: 0 5px;
    padding: 8px 16px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover:not(:disabled) {
    background: #ddd;
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
  }
  #timer {
    font-size: 1.2rem;
    margin: 10px 0;
    text-align: center;
    font-weight: bold;
  }
  #canvasContainer {
    text-align: center;
    margin-bottom: 15px;
  }
  canvas {
    border: 1px solid #aaa;
    background: #fff;
  }
  #showWaveformLabel {
    display: block;
    text-align: center;
    margin-bottom: 15px;
  }
  #recordingsList {
    margin-top: 20px;
  }
  .recording-item {
    margin-bottom: 10px;
  }
  .recording-name {
    font-weight: bold;
    margin-right: 10px;
  }
  .download-btn {
    padding: 4px 10px;
    font-size: 0.9rem;
    border-radius: 4px;
    border: 1px solid #666;
    background: #eee;
    cursor: pointer;
    transition: background 0.3s;
  }
  .download-btn:hover {
    background: #ddd;
  }
</style>
</head>
<body>
<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markThrobBtn" disabled>Mark Throb</button>
</div>

<div id="timer">0.00s</div>

<label id="showWaveformLabel">
  <input type="checkbox" id="showWaveformToggle" checked /> Show Waveform
</label>

<div id="canvasContainer">
  <canvas id="ecgCanvas" width="800" height="200"></canvas>
</div>

<div id="recordingsList"></div>

<script>
(() => {
  const canvas = document.getElementById('ecgCanvas');
  const ctx = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const markThrobBtn = document.getElementById('markThrobBtn');
  const timerEl = document.getElementById('timer');
  const showWaveformToggle = document.getElementById('showWaveformToggle');
  const recordingsList = document.getElementById('recordingsList');

  const waveformDuration = 5000; // 5 seconds window shown on canvas
  const sampleRate = 250; // Hz (samples per second)
  const sampleInterval = 1000 / sampleRate; // ms per sample

  // ECG waveform model using sum of Gaussians for P, QRS, T
  // normalized to a single heartbeat cycle of length 1 (normalized time)
  function ecgWaveform(tNorm) {
    // P wave: small positive bump around 0.1
    const p = 0.1;
    const pWidth = 0.07;
    const pAmp = 0.15;
    const pWave = pAmp * Math.exp(-((tNorm - p) ** 2) / (2 * pWidth ** 2));

    // Q wave: small negative dip at 0.2
    const q = 0.2;
    const qWidth = 0.01;
    const qAmp = -0.25;
    const qWave = qAmp * Math.exp(-((tNorm - q) ** 2) / (2 * qWidth ** 2));

    // R wave: big positive peak at 0.22
    const r = 0.22;
    const rWidth = 0.015;
    const rAmp = 1.0;
    const rWave = rAmp * Math.exp(-((tNorm - r) ** 2) / (2 * rWidth ** 2));

    // S wave: negative dip at 0.26
    const s = 0.26;
    const sWidth = 0.01;
    const sAmp = -0.35;
    const sWave = sAmp * Math.exp(-((tNorm - s) ** 2) / (2 * sWidth ** 2));

    // T wave: broad positive bump at 0.4
    const t = 0.4;
    const tWidth = 0.1;
    const tAmp = 0.3;
    const tWave = tAmp * Math.exp(-((tNorm - t) ** 2) / (2 * tWidth ** 2));

    return pWave + qWave + rWave + sWave + tWave;
  }

  // Variables to track state
  let running = false;
  let paused = false;
  let startTime = 0;
  let elapsedPauseTime = 0;
  let pauseStartTime = 0;
  let elapsed = 0;
  let lastTimestamp = 0;
  let animationFrameId = 0;

  // Waveform and peaks data
  let waveformSamples = []; // {time(ms), value}
  let rPeaks = []; // {time(ms), value, bpm}

  // Throbs data
  let throbs = []; // timestamp in ms (relative to start)

  // BPM control
  let currentBpm = 75;
  let bpmChangeTime = 0;
  let nextBpmChangeInterval = randomInterval();

  // Show waveform toggle
  let showWaveform = true;

  // Helper functions
  function randomInterval() {
    return 3000 + Math.random() * 4000; // 3 to 7 seconds
  }

  function randomBpm() {
    return 60 + Math.floor(Math.random() * 41); // 60 to 100 BPM
  }

  // Convert BPM to ms per beat
  function bpmToMs(bpm) {
    return 60000 / bpm;
  }

  // Simulate ECG sample at given elapsed time in ms
  // We simulate periodic ECG based on current BPM and time since last BPM change
  function simulateEcgSample(elapsedMs) {
    // Calculate which beat interval we are in since last bpm change
    let elapsedSinceBpmChange = elapsedMs - bpmChangeTime;
    let beatInterval = bpmToMs(currentBpm);
    let beatPos = (elapsedSinceBpmChange % beatInterval) / beatInterval; // normalized [0,1)

    return ecgWaveform(beatPos);
  }

  // Detect R peaks by simple threshold and local max around expected peak time
  function detectRPeaks() {
    // Simple approach: find local max above 0.8 in waveformSamples, spaced at least 0.4s apart
    const minDistance = 400; // ms minimum distance between peaks (to avoid duplicates)
    let lastPeakTime = rPeaks.length > 0 ? rPeaks[rPeaks.length - 1].time : -Infinity;

    for (let i = 1; i < waveformSamples.length - 1; i++) {
      let s = waveformSamples[i];
      if (
        s.value > 0.8 &&
        s.value > waveformSamples[i - 1].value &&
        s.value > waveformSamples[i + 1].value &&
        s.time > lastPeakTime + minDistance
      ) {
        // Assign bpm for this peak (based on current bpm at this time)
        let bpmAtPeak = currentBpm;

        // Store R peak
        rPeaks.push({ time: s.time, value: s.value, bpm: bpmAtPeak });

        lastPeakTime = s.time;
      }
    }

    // Keep R peaks within rolling window + 1 sec buffer (for synchronization)
    rPeaks = rPeaks.filter(rp => rp.time >= elapsed - waveformDuration - 1000);
  }

  // Convert radians to degrees helper
  function radToDeg(rad) {
    return (rad * 180) / Math.PI;
  }

  // Circular statistics helpers for phases in radians
  function circularMean(angles) {
    const sumSin = angles.reduce((a, v) => a + Math.sin(v), 0);
    const sumCos = angles.reduce((a, v) => a + Math.cos(v), 0);
    return Math.atan2(sumSin / angles.length, sumCos / angles.length);
  }

  function circularVariance(angles) {
    const sumSin = angles.reduce((a, v) => a + Math.sin(v), 0);
    const sumCos = angles.reduce((a, v) => a + Math.cos(v), 0);
    const R = Math.sqrt((sumCos / angles.length) ** 2 + (sumSin / angles.length) ** 2);
    return 1 - R;
  }

  function circularStd(angles) {
    return Math.sqrt(-2 * Math.log(1 - circularVariance(angles)));
  }

  // Rayleigh test for non-uniformity of circular data
  // Returns { R: resultant vector length, p: p-value }
  function rayleighTest(angles) {
    const n = angles.length;
    if (n === 0) return { R: 0, p: 1 };

    const sumSin = angles.reduce((a, v) => a + Math.sin(v), 0);
    const sumCos = angles.reduce((a, v) => a + Math.cos(v), 0);
    const R = Math.sqrt(sumCos ** 2 + sumSin ** 2) / n;

    const z = n * R * R;
    // Approximate p-value for large n
    const p = Math.exp(-z) * (1 + (2 * z - z * z) / (4 * n) - (24 * z - 132 * z * z + 76 * z * z * z - 9 * z * z * z * z) / (288 * n * n));

    return { R, p };
  }

  // Calculate phase of throb relative to previous R peak [0, 2pi)
  function calculatePhase(throbTime) {
    // Find the immediately preceding R peak (strictly less than throbTime)
    let prevPeak = null;
    for (let i = rPeaks.length - 1; i >= 0; i--) {
      if (rPeaks[i].time < throbTime) {
        prevPeak = rPeaks[i];
        break;
      }
    }
    if (!prevPeak) return null;

    // Find the next R peak after prevPeak
    let nextPeak = null;
    for (let i = 0; i < rPeaks.length; i++) {
      if (rPeaks[i].time > prevPeak.time) {
        nextPeak = rPeaks[i];
        break;
      }
    }
    if (!nextPeak) return null;

    const interval = nextPeak.time - prevPeak.time;
    if (interval <= 0) return null;

    const delta = throbTime - prevPeak.time;

    // Phase normalized to 0-2pi
    return { phase: (delta / interval) * 2 * Math.PI, delta, prevPeak };
  }

  // Draw waveform and markers on canvas
  function drawWaveform() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!showWaveform) {
      // Show only timer, no waveform
      return;
    }

    // Draw baseline
    const midY = canvas.height / 2;
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, midY);
    ctx.lineTo(canvas.width, midY);
    ctx.stroke();

    // Draw ECG waveform line
    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;
    ctx.beginPath();

    // Map time range from elapsed-waveformDuration to elapsed (5 seconds)
    const tStart = elapsed - waveformDuration;
    const tEnd = elapsed;

    for (let i = 0; i < waveformSamples.length; i++) {
      const s = waveformSamples[i];
      if (s.time < tStart) continue;
      if (s.time > tEnd) break;

      const x = ((s.time - tStart) / waveformDuration) * canvas.width;
      const y = midY - s.value * 70; // scale amplitude
      if (i === 0 || waveformSamples[i - 1].time < tStart) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();

    // Draw R peaks (red vertical lines)
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    rPeaks.forEach(rp => {
      if (rp.time >= tStart && rp.time <= tEnd) {
        const x = ((rp.time - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, midY - 90);
        ctx.lineTo(x, midY + 90);
        ctx.stroke();
      }
    });

    // Draw throb markers (green vertical lines)
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 2;
    throbs.forEach(t => {
      if (t >= tStart && t <= tEnd) {
        const x = ((t - tStart) / waveformDuration) * canvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 10);
        ctx.lineTo(x, canvas.height - 10);
        ctx.stroke();
      }
    });
  }

  // Update timer display (seconds with 2 decimal places)
  function updateTimer() {
    timerEl.textContent = elapsed / 1000.toFixed(2) + 's';
    // Actually this displays e.g. "NaNs" because order, so fix below
  }
  function updateTimer() {
    timerEl.textContent = elapsed.toFixed(0) === "0" ? "0.00s" : (elapsed / 1000).toFixed(2) + 's';
  }

  // Update BPM every 3-7 seconds randomly
  function updateBpm(elapsedMs) {
    if (elapsedMs - bpmChangeTime > nextBpmChangeInterval) {
      bpmChangeTime = elapsedMs;
      currentBpm = randomBpm();
      nextBpmChangeInterval = randomInterval();
    }
  }

  // Start recording
  function startRecording() {
    running = true;
    paused = false;
    startTime = performance.now();
    elapsedPauseTime = 0;
    pauseStartTime = 0;
    elapsed = 0;
    lastTimestamp = 0;
    waveformSamples = [];
    rPeaks = [];
    throbs = [];
    currentBpm = randomBpm();
    bpmChangeTime = 0;
    nextBpmChangeInterval = randomInterval();

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    markThrobBtn.disabled = false;

    animationFrameId = requestAnimationFrame(animate);
  }

  // Pause recording
  function pauseRecording() {
    if (!running || paused) return;
    paused = true;
    pauseStartTime = performance.now();

    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    markThrobBtn.disabled = true;
  }

  // Resume recording
  function resumeRecording() {
    if (!running || !paused) return;
    paused = false;
    elapsedPauseTime += performance.now() - pauseStartTime;

    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    markThrobBtn.disabled = false;

    animationFrameId = requestAnimationFrame(animate);
  }

  // Stop recording and save
  function stopRecording() {
    running = false;
    paused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    markThrobBtn.disabled = true;

    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = 0;
    }

    saveRecording();
  }

  // Mark a throb timestamp
  function markThrob() {
    if (!running || paused) return;
    const now = elapsed;
    throbs.push(now);
    drawWaveform();
  }

  // Animation loop
  function animate(timestamp) {
    if (!running) return;

    if (lastTimestamp === 0) lastTimestamp = timestamp;
    const dt = timestamp - lastTimestamp;
    lastTimestamp = timestamp;

    if (!paused) {
      elapsed = performance.now() - startTime - elapsedPauseTime;

      updateBpm(elapsed);

      // Add new samples based on elapsed time
      let lastSampleTime = waveformSamples.length > 0 ? waveformSamples[waveformSamples.length - 1].time : 0;
      while (lastSampleTime + sampleInterval < elapsed) {
        lastSampleTime += sampleInterval;
        const val = simulateEcgSample(lastSampleTime);
        waveformSamples.push({ time: lastSampleTime, value: val });
      }

      // Keep samples within rolling window
      waveformSamples = waveformSamples.filter(s => s.time >= elapsed - waveformDuration);

      detectRPeaks();

      drawWaveform();

      updateTimer();
    }

    animationFrameId = requestAnimationFrame(animate);
  }

  // Save recording to CSV and add UI entry
  function saveRecording() {
    const recName = prompt('Enter recording name:', `Recording_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}`);
    if (!recName) return;

    // Compose CSV content
    // Columns: time(ms), waveform value, rPeak(1/0), throb(1/0)
    const tStart = elapsed - waveformDuration;
    const recSamples = waveformSamples.filter(s => s.time >= tStart);
    let csv = 'time_ms,value,rPeak,throb\n';

    recSamples.forEach(s => {
      const isR = rPeaks.some(rp => Math.abs(rp.time - s.time) < sampleInterval / 2) ? 1 : 0;
      const isThrob = throbs.some(t => Math.abs(t - s.time) < sampleInterval / 2) ? 1 : 0;
      csv += `${s.time.toFixed(2)},${s.value.toFixed(4)},${isR},${isThrob}\n`;
    });

    // Create Blob and URL
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    // Add to recordings list UI
    const div = document.createElement('div');
    div.className = 'recording-item';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'recording-name';
    nameSpan.textContent = recName;

    const downloadBtn = document.createElement('a');
    downloadBtn.className = 'download-btn';
    downloadBtn.href = url;
    downloadBtn.download = recName + '.csv';
    downloadBtn.textContent = 'Download CSV';

    div.appendChild(nameSpan);
    div.appendChild(downloadBtn);
    recordingsList.appendChild(div);

    alert('Recording saved!');
  }

  // Event listeners
  startBtn.addEventListener('click', startRecording);
  pauseBtn.addEventListener('click', pauseRecording);
  resumeBtn.addEventListener('click', resumeRecording);
  stopBtn.addEventListener('click', stopRecording);
  markThrobBtn.addEventListener('click', markThrob);
  showWaveformToggle.addEventListener('change', () => {
    showWaveform = showWaveformToggle.checked;
    drawWaveform();
  });
})();
</script>
</body>
</html>
