<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Migraine Throb Temporal Synchrony App</title>
<style>
  body { font-family: Arial; margin: 2rem auto; max-width: 900px; }
  canvas { border: 1px solid #ccc; display: block; margin-bottom: 1rem; }
  button, input { margin: 5px; }
  .recording { border: 1px solid #ddd; padding: 10px; margin-top: 10px; }
</style>
</head>
<body>
<h2>Migraine Throb Temporal Synchrony App</h2>
<canvas id="canvas" width="800" height="230"></canvas>
<div>
  <input type="text" id="recordingName" placeholder="Enter recording name" />
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="markBtn" disabled>Mark Throb</button>
  <button id="toggleBtn">Hide Waveform</button>
</div>
<h3>Recordings</h3>
<div id="recordingsList"><p>No recordings yet.</p></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn = document.getElementById("stopBtn");
const markBtn = document.getElementById("markBtn");
const toggleBtn = document.getElementById("toggleBtn");
const recNameInput = document.getElementById("recordingName");
const recordingsList = document.getElementById("recordingsList");

const MS_PER_MIN = 60000;
const VIEW_MS = 8000;

let isRecording = false;
let isPaused = false;
let showWave = true;

let timer = 0;
let startTime = 0;
let pauseTime = 0;
let lastFrameTime = 0;
let intervalId = null;

let throbs = [];
let peaks = [];

let phase = 0;
let currentBPM = 75;
let targetBPM = 75;
let bpmChangeStartTime = 0;
const bpmChangeDuration = 3000; // 3 seconds smooth bpm changes

let lastWaveVal = null;
let lastPeakDetected = false;

function randomBPM() {
  return 60 + Math.random() * 40;
}

// Arterial pulse waveform shape function (one cycle)
function arterialPulseShape(phase) {
  // phase from 0 to 2PI
  // simulate systolic peak then dicrotic notch
  // simple shape: sharp rise (first half sine), then slower fall + notch
  if (phase < Math.PI * 0.6) {
    return Math.sin((phase / (Math.PI * 0.6)) * Math.PI);
  } else {
    const fallPhase = (phase - Math.PI * 0.6) / (2 * Math.PI - Math.PI * 0.6);
    // simple dicrotic notch as small bump at ~70% of cycle
    if (fallPhase < 0.5) {
      return Math.cos(fallPhase * Math.PI) * 0.5;
    } else {
      return Math.cos(fallPhase * Math.PI) * 0.3;
    }
  }
}

// Format milliseconds to mm:ss.SSS
function formatTime(ms) {
  const m = Math.floor(ms / 60000);
  const s = Math.floor((ms % 60000) / 1000);
  const msR = ms % 1000;
  return `${m}:${s.toString().padStart(2, "0")}.${msR.toString().padStart(3, "0")}`;
}

function findPriorPeak(time) {
  // Find the most recent peak before or at given time
  for (let i = peaks.length - 1; i >= 0; i--) {
    if (peaks[i].time <= time) return peaks[i];
  }
  return null;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!showWave) {
    ctx.fillStyle = "black";
    ctx.font = "16px Arial";
    ctx.fillText(formatTime(timer), 10, 220);
    return;
  }

  const startTimeView = Math.max(0, timer - VIEW_MS);
  const pxPerMs = canvas.width / VIEW_MS;

  // Draw waveform
  ctx.strokeStyle = "#0080ff";
  ctx.lineWidth = 2;
  ctx.beginPath();

  for (let x = 0; x < canvas.width; x++) {
    const t = startTimeView + x / pxPerMs;
    const peak = findPriorPeak(t);
    if (!peak) {
      // no peak yet, baseline middle
      if (x === 0) ctx.moveTo(x, 115);
      else ctx.lineTo(x, 115);
      continue;
    }

    const interval = MS_PER_MIN / peak.bpm;
    let phaseLocal = ((t - peak.time) % interval) / interval * 2 * Math.PI;
    // keep phase positive
    if (phaseLocal < 0) phaseLocal += 2 * Math.PI;

    const y = 115 - arterialPulseShape(phaseLocal) * 80;
    if (x === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Draw peaks as vertical red lines
  ctx.strokeStyle = "red";
  ctx.lineWidth = 1;
  peaks.forEach(p => {
    if (p.time >= startTimeView && p.time <= timer) {
      const x = (p.time - startTimeView) * pxPerMs;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
  });

  // Draw throbs as vertical green lines
  ctx.strokeStyle = "green";
  ctx.lineWidth = 1;
  throbs.forEach(t => {
    if (t >= startTimeView && t <= timer) {
      const x = (t - startTimeView) * pxPerMs;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
  });

  // Draw timer text
  ctx.fillStyle = "black";
  ctx.font = "16px Arial";
  ctx.fillText(formatTime(timer), 10, 220);
}

// Rayleigh's R and p-value
function rayleighTest(phases) {
  if (phases.length === 0) return { R: 0, p: 1 };
  const sumCos = phases.reduce((a, p) => a + Math.cos(p), 0);
  const sumSin = phases.reduce((a, p) => a + Math.sin(p), 0);
  const R = Math.sqrt(sumCos * sumCos + sumSin * sumSin) / phases.length;
  const p = Math.exp(-phases.length * R * R);
  return { R, p };
}

// Phase Vector Length (PVL)
function phaseVectorLength(phases) {
  if (phases.length === 0) return 0;
  const sumCos = phases.reduce((a, p) => a + Math.cos(p), 0);
  const sumSin = phases.reduce((a, p) => a + Math.sin(p), 0);
  const pvl = Math.sqrt(sumCos * sumCos + sumSin * sumSin) / phases.length;
  return pvl;
}

function computeStats(name) {
  if (throbs.length === 0) return "";

  // Compute delta between each throb and *previous* peak
  const rows = throbs.map(t => {
    // find peak strictly before throb time
    const priorPeakIndex = peaks.findIndex(p => p.time > t) - 1;
    let priorPeak = null;
    if (priorPeakIndex >= 0) priorPeak = peaks[priorPeakIndex];
    if (!priorPeak) priorPeak = peaks[0]; // fallback first peak

    const bpm = priorPeak ? priorPeak.bpm : currentBPM;
    const delta = t - priorPeak.time;
    const interval = MS_PER_MIN / bpm;
    let phase = ((delta % interval) / interval) * 2 * Math.PI;
    if (phase < 0) phase += 2 * Math.PI;

    return { t, priorPeak: priorPeak.time, delta, bpm, phase };
  });

  const phases = rows.map(r => r.phase);
  const { R, p } = rayleighTest(phases);
  const pvl = phaseVectorLength(phases);

  // Mean pulse rate over recorded peaks
  const bpms = peaks.map(p => p.bpm);
  const meanBPM = bpms.reduce((a,b) => a+b,0) / bpms.length;

  // Build CSV text
  let csv = `Recording Name:,${name}\n`;
  csv += `Duration (ms),${timer}\n`;
  csv += `Total throbs,${throbs.length}\n`;
  csv += `Total peaks,${peaks.length}\n`;
  csv += `Mean BPM,${meanBPM.toFixed(2)}\n`;
  csv += `Rayleigh's R,${R.toFixed(4)}\n`;
  csv += `Rayleigh's p-value,${p.toExponential(4)}\n`;
  csv += `PVL,${pvl.toFixed(4)}\n\n`;

  csv += `ThrobTime(ms),PriorPeakTime(ms),Delta(ms),PulseBPM,Phase(rad)\n`;
  rows.forEach(r => {
    csv += `${r.t.toFixed(2)},${r.priorPeak.toFixed(2)},${r.delta.toFixed(2)},${r.bpm.toFixed(2)},${r.phase.toFixed(4)}\n`;
  });

  csv += `\nDelta between each throb and prior peak (ms):\n`;
  rows.forEach(r => {
    csv += `${r.delta.toFixed(2)}\n`;
  });

  return csv;
}

function saveRecording() {
  if (throbs.length === 0) {
    alert("No throbs recorded.");
    return;
  }
  const name = recNameInput.value.trim() || `Recording_${recordingsList.children.length + 1}`;
  const csv = computeStats(name);

  const recDiv = document.createElement("div");
  recDiv.className = "recording";

  const title = document.createElement("h4");
  title.textContent = name;
  recDiv.appendChild(title);

  const statsPre = document.createElement("pre");
  statsPre.textContent = csv;
  recDiv.appendChild(statsPre);

  // Download button for CSV
  const dlBtn = document.createElement("button");
  dlBtn.textContent = "Download CSV";
  dlBtn.onclick = () => {
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  recDiv.appendChild(dlBtn);

  recordingsList.appendChild(recDiv);

  // Reset for next recording
  throbs = [];
  peaks = [];
  timer = 0;
  recNameInput.value = "";
  draw();
}

function updateBPM(now) {
  const elapsed = now - bpmChangeStartTime;
  if (elapsed >= bpmChangeDuration) {
    bpmChangeStartTime = now;
    currentBPM = targetBPM;
    targetBPM = randomBPM();
  } else {
    // Smooth linear interpolation
    const fraction = elapsed / bpmChangeDuration;
    currentBPM = currentBPM + fraction * (targetBPM - currentBPM);
  }
}

function animate(timestamp) {
  if (!lastFrameTime) lastFrameTime = timestamp;
  const deltaTime = timestamp - lastFrameTime;

  if (isRecording && !isPaused) {
    timer += deltaTime;
    updateBPM(timestamp);

    // Update phase
    // phase += deltaTime * currentBPM / 60 * 2PI
    phase += (deltaTime / 1000) * (currentBPM / 60) * 2 * Math.PI;
    if (phase > 2 * Math.PI) phase -= 2 * Math.PI;

    // Calculate waveform value at current phase
    const waveVal = arterialPulseShape(phase);

    // Detect peak: peak is when waveform transitions from increasing to decreasing
    if (lastWaveVal !== null) {
      if (lastWaveVal < waveVal) lastPeakDetected = false;
      if (!lastPeakDetected && lastWaveVal > waveVal) {
        // local max at last frame
        const peakTime = timer - deltaTime; // approximate peak time at previous frame
        peaks.push({ time: peakTime, bpm: currentBPM });
        lastPeakDetected = true;
      }
    }
    lastWaveVal = waveVal;
  }

  draw();
  lastFrameTime = timestamp;
  if (isRecording) {
    requestAnimationFrame(animate);
  }
}

// Button handlers
startBtn.onclick = () => {
  if (isRecording) return;
  isRecording = true;
  isPaused = false;
  startBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  markBtn.disabled = false;
  toggleBtn.disabled = false;
  timer = 0;
  phase = 0;
  currentBPM = randomBPM();
  targetBPM = randomBPM();
  bpmChangeStartTime = performance.now();
  throbs = [];
  peaks = [];
  lastWaveVal = null;
  lastPeakDetected = false;
  lastFrameTime = 0;
  draw();
  requestAnimationFrame(animate);
};

pauseBtn.onclick = () => {
  if (!isRecording) return;
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
};

stopBtn.onclick = () => {
  if (!isRecording) return;
  isRecording = false;
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  stopBtn.disabled = true;
  markBtn.disabled = true;
  toggleBtn.disabled = true;
  pauseBtn.textContent = "Pause";
  saveRecording();
};

markBtn.onclick = () => {
  if (!isRecording || isPaused) return;
  throbs.push(timer);
};

toggleBtn.onclick = () => {
  showWave = !showWave;
  toggleBtn.textContent = showWave ? "Hide Waveform" : "Show Waveform";
  draw();
};

draw();

</script>
</body>
</html>
