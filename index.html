<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Migraine Throb Synchrony App</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin-bottom: 10px;
    }
    button {
      margin: 4px;
    }
    .recordings-list {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Migraine Throb Synchrony App</h1>
  <canvas id="ecgCanvas" width="1000" height="200"></canvas>
  <div>
    <button onclick="startRecording()">Start</button>
    <button onclick="pauseResumeRecording()">Pause/Resume</button>
    <button onclick="stopRecording()">Stop & Save</button>
    <button onclick="markThrob()">Mark Throb</button>
    <label><input type="checkbox" id="toggleDisplay" onchange="toggleWaveform()"> Show/Hide Waveform</label>
    <div id="timer">00:00.00</div>
  </div>
  <div class="recordings-list" id="recordingsList"></div>
  <script>
    const canvas = document.getElementById('ecgCanvas');
    const ctx = canvas.getContext('2d');
    const toggleDisplay = document.getElementById('toggleDisplay');
    const timerDisplay = document.getElementById('timer');

    let startTime, timerInterval, isPaused = false, pauseStart, pausedDuration = 0;
    let ecgData = [], rPeaks = [], throbs = [], bpm = 70, bpmChanges = [], phaseData = [];
    let lastBpmChange = 0, recording = false;
    let recordings = [];

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const ecgBuffer = 5000; // ms
    const PTT = 200; // ms pulse transit time for middle meningeal artery

    function generateECGWave(t, bpm) {
      const beatInterval = 60000 / bpm;
      const timeInBeat = t % beatInterval;
      const phase = timeInBeat / beatInterval;
      let value = 0;
      value += Math.exp(-Math.pow((phase - 0.2) * 40, 2)) * 0.15; // P wave
      value += Math.exp(-Math.pow((phase - 0.3) * 200, 2)) * 1.5;  // R peak
      value -= Math.exp(-Math.pow((phase - 0.35) * 100, 2)) * 0.3; // S wave
      value += Math.exp(-Math.pow((phase - 0.5) * 60, 2)) * 0.5;   // T wave
      return value;
    }

    function updateTimer() {
      const now = performance.now();
      const elapsed = (now - startTime - pausedDuration) / 1000;
      const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const seconds = (elapsed % 60).toFixed(2).padStart(5, '0');
      timerDisplay.textContent = `${minutes}:${seconds}`;
    }

    function scheduleNextBPMChange() {
      const delay = Math.random() * 4000 + 3000;
      setTimeout(() => {
        bpm = Math.floor(Math.random() * 41) + 60;
        lastBpmChange = performance.now();
        bpmChanges.push({ time: lastBpmChange - startTime, bpm });
        if (recording) scheduleNextBPMChange();
      }, delay);
    }

    function detectRPeaks() {
      rPeaks = [];
      const threshold = 0.8;
      for (let i = 1; i < ecgData.length - 1; i++) {
        const prev = ecgData[i - 1].value;
        const curr = ecgData[i].value;
        const next = ecgData[i + 1].value;
        if (curr > threshold && curr > prev && curr > next) {
          rPeaks.push({ time: ecgData[i].time, bpm: getBPMAt(ecgData[i].time) });
        }
      }
    }

    function getBPMAt(time) {
      let bpmVal = bpm;
      for (const change of bpmChanges) {
        if (time >= change.time) bpmVal = change.bpm;
        else break;
      }
      return bpmVal;
    }

    function drawECG() {
      if (!toggleDisplay.checked) return;
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      const currentTime = performance.now() - startTime - pausedDuration;
      const fromTime = currentTime - ecgBuffer;
      ctx.beginPath();
      ctx.moveTo(0, canvasHeight / 2);
      for (let i = 0; i < ecgData.length; i++) {
        const x = ((ecgData[i].time - fromTime) / ecgBuffer) * canvasWidth;
        const y = canvasHeight / 2 - ecgData[i].value * 80;
        if (x >= 0 && x <= canvasWidth) ctx.lineTo(x, y);
      }
      ctx.stroke();

      for (const peak of rPeaks) {
        const x = ((peak.time - fromTime) / ecgBuffer) * canvasWidth;
        if (x >= 0 && x <= canvasWidth) {
          ctx.beginPath();
          ctx.strokeStyle = 'red';
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.stroke();
        }
      }

      for (const throb of throbs) {
        const x = ((throb - fromTime) / ecgBuffer) * canvasWidth;
        if (x >= 0 && x <= canvasWidth) {
          ctx.beginPath();
          ctx.strokeStyle = 'green';
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.stroke();
        }
      }
      ctx.strokeStyle = 'black';
    }

    function updateECG() {
      if (!recording || isPaused) return;
      const t = performance.now() - startTime - pausedDuration;
      const value = generateECGWave(t, bpm);
      ecgData.push({ time: t, value });
      if (ecgData.length > 10000) ecgData.shift();
      detectRPeaks();
      drawECG();
      updateTimer();
    }

    function startRecording() {
      recording = true;
      isPaused = false;
      pausedDuration = 0;
      throbs = [];
      ecgData = [];
      rPeaks = [];
      bpmChanges = [];
      phaseData = [];
      startTime = performance.now();
      bpmChanges.push({ time: 0, bpm });
      scheduleNextBPMChange();
      clearInterval(timerInterval);
      timerInterval = setInterval(updateECG, 20);
    }

    function pauseResumeRecording() {
      if (!recording) return;
      if (!isPaused) {
        isPaused = true;
        pauseStart = performance.now();
      } else {
        isPaused = false;
        pausedDuration += performance.now() - pauseStart;
      }
    }

    function stopRecording() {
      recording = false;
      clearInterval(timerInterval);
      const name = prompt("Enter recording name:");
      if (!name) return;
      const summary = computeStatistics();
      recordings.push({ name, summary });
      listRecordings();
    }

    function markThrob() {
      if (!recording || isPaused) return;
      const t = performance.now() - startTime - pausedDuration;
      throbs.push(t);
    }

    function computeStatistics() {
      const data = throbs.map(throb => {
        // Adjust R peak time with PTT to simulate arterial arrival
        const prior = rPeaks.filter(p => p.time + PTT <= throb).slice(-1)[0];
        const next = rPeaks.find(p => p.time + PTT > throb);
        const delta = prior ? throb - (prior.time + PTT) : null;
        const interval = prior && next ? (next.time + PTT) - (prior.time + PTT) : null;
        const phase = interval ? ((throb - (prior.time + PTT)) / interval) * 2 * Math.PI : null;
        if (phase != null) phaseData.push(phase);
        return {
          throbTime: throb.toFixed(2),
          priorPeakTime: prior ? (prior.time + PTT).toFixed(2) : '',
          delta: delta != null ? delta.toFixed(2) : '',
          bpm: prior ? prior.bpm : '',
          phase: phase != null ? phase.toFixed(4) : ''
        };
      });

      const R = calcRayleighR(phaseData);
      const p = calcRayleighP(R, phaseData.length);
      const PVL = R;
      const meanAngle = calcMeanAngle(phaseData);
      const deltaStd = std(data.map(d => Number(d.delta)).filter(d => !isNaN(d)));

      return {
        data,
        totalThrobs: throbs.length,
        totalPeaks: rPeaks.length,
        meanBPM: (rPeaks.length / (ecgData[ecgData.length - 1].time / 60000)).toFixed(2),
        rayleighR: R.toFixed(4),
        rayleighP: p,
        PVL: PVL.toFixed(4),
        deltaStd: deltaStd.toFixed(2),
        meanAngle: meanAngle.toFixed(4)
      };
    }

    function listRecordings() {
      const list = document.getElementById('recordingsList');
      list.innerHTML = '';
      recordings.forEach((rec, i) => {
        const div = document.createElement('div');
        div.innerHTML = `${rec.name} <button onclick="downloadCSV(${i})">Download CSV</button>`;
        list.appendChild(div);
      });
    }

    function downloadCSV(index) {
      const rec = recordings[index];
      const summary = rec.summary;

      // Format Rayleigh p-value nicely
      let rayleighPFormatted = Number(summary.rayleighP);
      if (rayleighPFormatted < 0.001) rayleighPFormatted = "<0.001";
      else rayleighPFormatted = rayleighPFormatted.toFixed(3);

      // Header summary lines (commented out with #)
      const headerLines = [
        `# Recording Name: ${rec.name}`,
        `# Pulse Transit Time (ms): ${PTT}`,
        `# Total Throb Count: ${summary.totalThrobs}`,
        `# Total R Peak Count: ${summary.totalPeaks}`,
        `# Mean BPM: ${summary.meanBPM}`,
        `# Rayleigh R: ${summary.rayleighR}`,
        `# Rayleigh p-value: ${rayleighPFormatted}`,
        `# Phase Vector Length (PVL): ${summary.PVL}`,
        `# Std Dev of Delta (ms): ${summary.deltaStd}`,
        `# Mean Vector Angle (radians): ${summary.meanAngle}`,
        ''
      ];

      // Raw data header
      const dataHeader = ['Throb Time (ms)', 'Prior R Peak Time (ms)', 'Delta (ms)', 'BPM at prior R', 'Phase (radians)'];
      const rows = summary.data.map(d => [
        d.throbTime, d.priorPeakTime, d.delta, d.bpm, d.phase
      ]);

      // Build CSV content
      let csvContent = headerLines.join('\n') + dataHeader.join(',') + '\n';
      rows.forEach(row => {
        csvContent += row.join(',') + '\n';
      });

      // Download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${rec.name}_pulse_synchrony.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function std(arr) {
      const n = arr.length;
      const mean = arr.reduce((a, b) => a + b, 0) / n;
      return Math.sqrt(arr.map(x => (x - mean) ** 2).reduce((a, b) => a + b, 0) / n);
    }

    function calcRayleighR(phases) {
      if (phases.length === 0) return 0;
      let x = 0, y = 0;
      for (const p of phases) {
        x += Math.cos(p);
        y += Math.sin(p);
      }
      return Math.sqrt(x ** 2 + y ** 2) / phases.length;
    }

    function calcRayleighP(R, n) {
      return Math.exp(-n * R * R);
    }

    function calcMeanAngle(phases) {
      let x = 0, y = 0;
      for (const p of phases) {
        x += Math.cos(p);
        y += Math.sin(p);
      }
      return Math.atan2(y, x);
    }

    function toggleWaveform() {
      drawECG();
    }
  </script>
</body>
</html>
