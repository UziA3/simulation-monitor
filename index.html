<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f5f7fa;
    color: #333;
  }
  h1 {
    margin-bottom: 10px;
  }
  #controls button {
    margin: 5px 10px 5px 0;
    padding: 10px 15px;
    font-size: 14px;
  }
  #timer {
    font-size: 18px;
    font-weight: bold;
    margin: 10px 0 15px 0;
  }
  #waveformCanvas {
    border: 1px solid #ccc;
    background: white;
    display: block;
    margin-bottom: 15px;
  }
  #recordingsList {
    margin-top: 20px;
  }
  .recording-item {
    background: #fff;
    border: 1px solid #ddd;
    padding: 10px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .recording-name {
    font-weight: bold;
    font-size: 14px;
  }
  .recording-item button {
    padding: 5px 10px;
    font-size: 13px;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn" disabled>Hide Waveform</button>
</div>

<div id="timer">00:00.000</div>

<canvas id="waveformCanvas" width="800" height="150"></canvas>

<div id="recordingsList"><h2>Saved Recordings</h2><p>No recordings yet.</p></div>

<script>
// --- Global Variables ---
const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const throbBtn = document.getElementById('throbBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const timerDisplay = document.getElementById('timer');
const recordingsList = document.getElementById('recordingsList');

let recordingState = 'stopped'; // 'running', 'paused', 'stopped'
let showWaveform = true;

let startTime = 0;
let pauseTime = 0;
let elapsedPauseDuration = 0;

let bpm = 70;
let bpmChangeTimeout;
let bpmHistory = []; // {time, bpm}

let waveformData = []; // {time, value}
let pulsePeaks = []; // {time, bpm}
let throbs = []; // {timestamp}

let savedRecordings = [];

let animationFrameId;

// --- Time Utilities ---
function getCurrentTimestamp(){
  if(recordingState === 'running'){
    return performance.now() - startTime - elapsedPauseDuration;
  } else if(recordingState === 'paused'){
    return pauseTime - startTime - elapsedPauseDuration;
  }
  return 0;
}

function formatTime(ms){
  let totalSeconds = ms / 1000;
  let m = Math.floor(totalSeconds / 60);
  let s = Math.floor(totalSeconds % 60);
  let msPart = Math.floor(ms % 1000);
  return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${msPart.toString().padStart(3,'0')}`;
}

// --- BPM Management ---
function scheduleBPMChange(){
  const interval = 3000 + Math.random()*4000; // 3-7 sec
  bpmChangeTimeout = setTimeout(() => {
    bpm = 60 + Math.random()*40; // 60-100 BPM
    bpmHistory.push({time: getCurrentTimestamp(), bpm});
    scheduleBPMChange();
  }, interval);
}

// --- Waveform Generation ---
function generateWaveformPoint(t){
  // Arterial pulse modeled as sum of 3 Gaussians:
  // 1) Systolic peak (~200ms width)
  // 2) Dicrotic notch (~100ms delay, smaller peak)
  // 3) Dicrotic wave (~150ms delay, smaller peak)

  const bpmIndex = findCurrentBPMIndex(t);
  const currentBPM = bpmHistory[bpmIndex]?.bpm || bpm;

  const cycleDuration = 60000 / currentBPM;
  const tInCycle = t % cycleDuration;

  // Gaussian helper
  function gauss(x, mu, sigma, amplitude){
    return amplitude * Math.exp(-0.5 * ((x - mu)/sigma)**2);
  }

  // Peaks locations (ms)
  const systolicPos = 0.2 * cycleDuration;
  const notchPos = 0.5 * cycleDuration;
  const wavePos = 0.7 * cycleDuration;

  // Amplitudes roughly proportioned
  const val =
    gauss(tInCycle, systolicPos, 0.02*cycleDuration, 1.0) +
    gauss(tInCycle, notchPos, 0.015*cycleDuration, 0.4) +
    gauss(tInCycle, wavePos, 0.02*cycleDuration, 0.25);

  return val;
}

function findCurrentBPMIndex(t){
  for(let i=bpmHistory.length-1; i>=0; i--){
    if(t >= bpmHistory[i].time){
      return i;
    }
  }
  return 0;
}

// --- Peak Detection ---
function detectPulsePeaks(data){
  const peaks = [];
  // Detect systolic peak only: highest value near systolicPos in each cycle
  if(data.length === 0) return peaks;

  // Use bpmHistory timestamps and bpm to segment cycles
  let cycleStarts = [data[0].time];
  for(let i=1; i<bpmHistory.length; i++){
    cycleStarts.push(bpmHistory[i].time);
  }
  // Add last cycle start as waveform start to allow cycles after last bpm change
  cycleStarts.push(data[data.length-1].time + 1);

  // Detect peaks per cycle
  for(let c=0; c<cycleStarts.length-1; c++){
    const startT = cycleStarts[c];
    const endT = cycleStarts[c+1];

    // Filter points in cycle
    const cyclePoints = data.filter(p => p.time >= startT && p.time < endT);
    if(cyclePoints.length === 0) continue;

    // Find max within cycle near systolic peak window (20% of cycle duration)
    const bpmAtCycle = bpmHistory[Math.min(c, bpmHistory.length-1)].bpm;
    const cycleDuration = 60000 / bpmAtCycle;
    const systolicWindowStart = startT + 0.15 * cycleDuration;
    const systolicWindowEnd = startT + 0.25 * cycleDuration;

    // Filter points in systolic window
    const systolicPoints = cyclePoints.filter(p => p.time >= systolicWindowStart && p.time <= systolicWindowEnd);
    if(systolicPoints.length === 0) continue;

    // Find max val in systolic window
    let maxPoint = systolicPoints[0];
    for(let pt of systolicPoints){
      if(pt.value > maxPoint.value) maxPoint = pt;
    }
    peaks.push({time: maxPoint.time, bpm: bpmAtCycle});
  }
  return peaks;
}

// --- Drawing ---
function drawWaveform(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if(!showWaveform){
    // Just clear and show nothing
    return;
  }

  // Draw baseline
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height/2);
  ctx.lineTo(canvas.width, canvas.height/2);
  ctx.stroke();

  if(waveformData.length === 0) return;

  // Draw waveform line
  ctx.strokeStyle = '#0077cc';
  ctx.lineWidth = 2;
  ctx.beginPath();

  // Map times to X
  const now = getCurrentTimestamp();
  const windowSize = 10000; // 10 sec window
  const startTime = now - windowSize;

  for(let i=0; i<waveformData.length; i++){
    const pt = waveformData[i];
    if(pt.time < startTime) continue;
    const x = ((pt.time - startTime) / windowSize) * canvas.width;
    const y = canvas.height - pt.value * 80 - 30;
    if(i === 0 || waveformData[i-1].time < startTime){
      ctx.moveTo(x,y);
    } else {
      ctx.lineTo(x,y);
    }
  }
  ctx.stroke();

  // Draw pulse peaks (red lines)
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  for(let peak of pulsePeaks){
    if(peak.time < startTime) continue;
    const x = ((peak.time - startTime) / windowSize) * canvas.width;
    ctx.beginPath();
    ctx.moveTo(x, 10);
    ctx.lineTo(x, canvas.height - 10);
    ctx.stroke();
  }

  // Draw throb markers (green lines)
  ctx.strokeStyle = 'green';
  ctx.lineWidth = 2;
  for(let throb of throbs){
    if(throb.timestamp < startTime) continue;
    const x = ((throb.timestamp - startTime) / windowSize) * canvas.width;
    ctx.beginPath();
    ctx.moveTo(x, 10);
    ctx.lineTo(x, canvas.height - 10);
    ctx.stroke();
  }
}

// --- Circular statistics ---
function rayleighTest(phases){
  // phases array in radians [0,2pi)
  const n = phases.length;
  if(n === 0) return {R: 0, pValue: 1};

  let sumSin = 0;
  let sumCos = 0;
  for(let phase of phases){
    sumSin += Math.sin(phase);
    sumCos += Math.cos(phase);
  }
  const R = Math.sqrt(sumSin*sumSin + sumCos*sumCos) / n;

  // Rayleigh test p-value approximation
  const z = n * R * R;
  let pValue = Math.exp(-z) * (1 + (2*z - z*z)/(4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z)/(288*n*n));
  pValue = Math.min(Math.max(pValue, 0), 1);

  return {R, pValue};
}

function phaseVectorLength(phases){
  if(phases.length === 0) return 0;
  let sumSin = 0;
  let sumCos = 0;
  for(let phase of phases){
    sumSin += Math.sin(phase);
    sumCos += Math.cos(phase);
  }
  return Math.sqrt(sumSin*sumSin + sumCos*sumCos) / phases.length;
}

function stdDevDeltas(deltas){
  if(deltas.length === 0) return 0;
  const mean = deltas.reduce((a,b)=>a+b,0)/deltas.length;
  const variance = deltas.reduce((a,b)=>a+(b-mean)**2,0)/deltas.length;
  return Math.sqrt(variance);
}

function meanVectorAngle(phases){
  if(phases.length === 0) return 0;
  let sumSin = 0;
  let sumCos = 0;
  for(let phase of phases){
    sumSin += Math.sin(phase);
    sumCos += Math.cos(phase);
  }
  return Math.atan2(sumSin, sumCos);
}

// --- Data Analysis ---
function analyzeThrobs(throbs, peaks){
  // For each throb, find the immediately preceding pulse peak
  const results = [];

  for(let throb of throbs){
    // find pulse peak before throb
    let priorPeak = null;
    for(let i=peaks.length-1; i>=0; i--){
      if(peaks[i].time <= throb.timestamp){
        priorPeak = peaks[i];
        break;
      }
    }
    if(!priorPeak) continue;

    // Find next pulse peak after priorPeak to get phase
    let nextPeak = null;
    for(let i=0; i<peaks.length; i++){
      if(peaks[i].time > priorPeak.time){
        nextPeak = peaks[i];
        break;
      }
    }
    if(!nextPeak) continue;

    const delta = throb.timestamp - priorPeak.time;
    const cycleDuration = nextPeak.time - priorPeak.time;
    const phase = (delta / cycleDuration) * 2 * Math.PI;

    results.push({
      throbTime: throb.timestamp,
      priorPeakTime: priorPeak.time,
      delta,
      bpm: priorPeak.bpm,
      phase
    });
  }
  return results;
}

// --- CSV Export ---
function generateCSV(rec){
  let csv = `Recording Name:,${rec.name}\n`;
  csv += `Total Throb Count:,${rec.throbs.length}\n`;
  csv += `Total Pulse Peak Count:,${rec.pulsePeaks.length}\n`;
  csv += `Mean Pulse Rate (BPM):,${rec.meanBPM.toFixed(2)}\n`;

  // Rayleigh p-value formatting
  const pvalStr = rec.rayleighPValue < 0.001 ? '<0.001' : rec.rayleighPValue.toFixed(3);

  csv += `Rayleigh R:,${rec.rayleighR.toFixed(3)}\n`;
  csv += `Rayleigh p-value:,${pvalStr}\n`;
  csv += `PVL:,${rec.pvl.toFixed(3)}\n`;
  csv += `Std Dev Delta (ms):,${rec.stdDevDelta.toFixed(3)}\n`;
  csv += `Mean Vector Angle (radians):,${rec.meanVectorAngle.toFixed(3)}\n\n`;

  csv += `Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)\n`;
  for(let t of rec.throbs){
    csv += `${t.throbTime.toFixed(0)},${t.priorPeakTime.toFixed(0)},${t.delta.toFixed(0)},${t.bpm.toFixed(1)},${t.phase.toFixed(3)}\n`;
  }
  return csv;
}

function downloadCSV(filename, csv){
  const blob = new Blob([csv], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// --- Animation Loop ---
function animationLoop(){
  if(recordingState !== 'running') return;

  const now = getCurrentTimestamp();

  if(waveformData.length === 0 || now - waveformData[waveformData.length-1].time >= 10){
    const val = generateWaveformPoint(now);
    waveformData.push({time: now, value: val});
  }

  // Reduce window size to last 10 seconds (10000 ms) for less waveform clutter
  const windowSize = 10000;
  const startCutoff = now - windowSize;
  while(waveformData.length > 0 && waveformData[0].time < startCutoff){
    waveformData.shift();
  }

  pulsePeaks = detectPulsePeaks(waveformData);

  timerDisplay.textContent = formatTime(now);

  drawWaveform();

  animationFrameId = requestAnimationFrame(animationLoop);
}

// --- Button Handlers ---
startBtn.onclick = () => {
  if(recordingState === 'running') return;
  recordingState = 'running';
  startTime = performance.now();
  elapsedPauseDuration = 0;
  bpm = 70;
  bpmHistory = [{time: 0, bpm}];
  waveformData = [];
  pulsePeaks = [];
  throbs = [];

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  throbBtn.disabled = false;
  toggleWaveformBtn.disabled = false;
  toggleWaveformBtn.textContent = 'Hide Waveform';
  showWaveform = true;

  scheduleBPMChange();

  animationLoop();
};

pauseBtn.onclick = () => {
  if(recordingState !== 'running') return;
  recordingState = 'paused';
  pauseTime = performance.now();

  clearTimeout(bpmChangeTimeout);
  cancelAnimationFrame(animationFrameId);

  startBtn.disabled = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  stopBtn.disabled = false;
  throbBtn.disabled = true;
  toggleWaveformBtn.disabled = true;
};

resumeBtn.onclick = () => {
  if(recordingState !== 'paused') return;
  recordingState = 'running';
  const pauseDuration = performance.now() - pauseTime;
  elapsedPauseDuration += pauseDuration;

  scheduleBPMChange();

  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  throbBtn.disabled = false;
  toggleWaveformBtn.disabled = false;

  animationLoop();
};

stopBtn.onclick = () => {
  if(recordingState === 'stopped') return;
  recordingState = 'stopped';
  clearTimeout(bpmChangeTimeout);
  cancelAnimationFrame(animationFrameId);

  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  toggleWaveformBtn.disabled = true;

  if(throbs.length === 0){
    alert('No throbs recorded. Nothing to save.');
    return;
  }

  const analyzed = analyzeThrobs(throbs, pulsePeaks);
  if(analyzed.length === 0){
    alert('No valid throbs found relative to pulse peaks.');
    return;
  }

  const phases = analyzed.map(a => a.phase);
  const deltas = analyzed.map(a => a.delta);

  const rayleigh = rayleighTest(phases);
  const pvl = phaseVectorLength(phases);
  const stdDelta = stdDevDeltas(deltas);
  const meanAngle = meanVectorAngle(phases);

  // Correct mean BPM calculation (fixed)
  const meanBPM = bpmHistory.reduce((sum, entry) => sum + entry.bpm, 0) / bpmHistory.length;

  const recordingName = prompt('Enter a name for this recording:', `Recording_${savedRecordings.length+1}`);
  if(!recordingName) return;

  const rec = {
    name: recordingName,
    throbs: analyzed,
    pulsePeaks: pulsePeaks,
    meanBPM,
    rayleighR: rayleigh.R,
    rayleighPValue: rayleigh.pValue,
    pvl,
    stdDevDelta: stdDelta,
    meanVectorAngle: meanAngle
  };

  savedRecordings.push(rec);
  updateRecordingsList();
};

throbBtn.onclick = () => {
  if(recordingState !== 'running') return;
  const t = getCurrentTimestamp();
  throbs.push({timestamp: t});
};

toggleWaveformBtn.onclick = () => {
  showWaveform = !showWaveform;
  toggleWaveformBtn.textContent = showWaveform ? 'Hide Waveform' : 'Show Waveform';
  drawWaveform();
};

// --- Update Recordings List ---
function updateRecordingsList(){
  if(savedRecordings.length === 0){
    recordingsList.innerHTML = '<h2>Saved Recordings</h2><p>No recordings yet.</p>';
    return;
  }
  let html = '<h2>Saved Recordings</h2>';
  for(let i=0; i<savedRecordings.length; i++){
    const rec = savedRecordings[i];
    html += `<div class="recording-item" data-index="${i}">
      <div class="recording-name">${rec.name}</div>
      <button class="exportBtn">Export CSV</button>
    </div>`;
  }
  recordingsList.innerHTML = html;

  document.querySelectorAll('.exportBtn').forEach(btn => {
    btn.onclick = (e) => {
      const idx = e.target.parentElement.getAttribute('data-index');
      const rec = savedRecordings[idx];
      const csv = generateCSV(rec);
      downloadCSV(`${rec.name.replace(/\s+/g,'_')}.csv`, csv);
    };
  });
}
</script>

</body>
</html>
