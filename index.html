<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Temporal Synchrony Recorder</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: auto;
    padding: 20px;
  }
  canvas {
    border: 1px solid #ccc;
  }
  button {
    margin-right: 5px;
    margin-top: 10px;
  }
  input[type=text] {
    width: 250px;
  }
  .recording {
    border: 1px solid #ddd;
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 4px;
    background-color: #f9f9f9;
  }
</style>
</head>
<body>
  <h2>Migraine Throb Temporal Synchrony Recorder</h2>
  <canvas id="waveformCanvas" width="800" height="230"></canvas>

  <div>
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop & Save</button>
    <button id="markBtn" disabled>Mark Throb</button>
    <button id="toggleShowBtn">Hide Waveform</button>
  </div>

  <div>
    <label>
      Recording Name:
      <input type="text" id="recordingName" placeholder="Enter a name for this recording" />
    </label>
  </div>

  <h3>Recordings</h3>
  <div id="recordingsList">
    <p>No recordings yet.</p>
  </div>

<script>
(() => {
  // Constants
  const BPM_MIN = 60;
  const BPM_MAX = 100;
  const MS_PER_MIN = 60000;

  // Elements
  const canvas = document.getElementById("waveformCanvas");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const stopBtn = document.getElementById("stopBtn");
  const markBtn = document.getElementById("markBtn");
  const toggleShowBtn = document.getElementById("toggleShowBtn");
  const recordingNameInput = document.getElementById("recordingName");
  const recordingsListDiv = document.getElementById("recordingsList");

  // State variables
  let bpm = getRandomBPM();
  let isRecording = false;
  let isPaused = false;
  let showWaveform = true;
  let timer = 0; // ms elapsed in current recording
  let throbs = [];
  let pulsePeaks = [];
  let recordings = [];
  let intervalId = null;
  let startTime = null;
  let pauseStart = null;

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;
  const waveformHeight = 150;
  const timerHeight = 30;

  // Utility Functions
  function getRandomBPM() {
    return Math.floor(Math.random() * (BPM_MAX - BPM_MIN + 1)) + BPM_MIN;
  }

  function formatTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = ms % 1000;
    return `${pad(minutes, 2)}:${pad(seconds, 2)}.${pad(milliseconds, 3)}`;
  }
  function pad(n, z) {
    return ("00" + n).slice(-z);
  }

  // Rayleigh Test (for uniformity of phase differences)
  function rayleighTest(phases) {
    const n = phases.length;
    if (n === 0) return { pValue: 1, r: 0 };
    let sumSin = 0, sumCos = 0;
    for (const phase of phases) {
      sumSin += Math.sin(phase);
      sumCos += Math.cos(phase);
    }
    const R = Math.sqrt(sumSin * sumSin + sumCos * sumCos) / n;
    const Z = n * R * R;
    const pValue = Math.exp(-Z) * (1 + (2 * Z - Z * Z) / (4 * n) - (24 * Z - 132 * Z * Z + 76 * Z * Z * Z - 9 * Z * Z * Z * Z) / (288 * n * n));
    return { pValue: Math.min(1, pValue), r: R };
  }

  function phaseVectorLength(phases) {
    if (phases.length === 0) return 0;
    let sumSin = 0, sumCos = 0;
    for (const p of phases) {
      sumSin += Math.sin(p);
      sumCos += Math.cos(p);
    }
    return Math.sqrt(sumSin * sumSin + sumCos * sumCos) / phases.length;
  }

  function timeDiffToPhase(diffMs, bpm) {
    const period = MS_PER_MIN / bpm;
    return ((diffMs % period) / period) * 2 * Math.PI;
  }

  // Arterial pulse waveform function approximation:
  // We simulate a sharper systolic peak and slower diastolic decay with a skewed function.
  // This function takes a phase from 0 to 2π and returns a value from -1 to 1.
  function arterialPulseWave(phase) {
    // Use a skewed waveform: fast rise (0 to ~0.3π), slow decay (0.3π to 2π)
    // Model with a piecewise function:
    const riseEnd = 0.3 * 2 * Math.PI; // approx 0.6π

    if (phase < riseEnd) {
      // Rapid rise, modeled as half sine wave stretched
      return Math.sin((phase / riseEnd) * Math.PI);
    } else {
      // Slow decay, modeled as half cosine wave stretched + offset
      return Math.cos(((phase - riseEnd) / (2 * Math.PI - riseEnd)) * Math.PI) * 0.5;
    }
  }

  // Drawing function
  function draw() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    if (!showWaveform) {
      // Just draw timer
      ctx.font = "20px Arial";
      ctx.fillStyle = "black";
      ctx.fillText(formatTime(timer), 10, waveformHeight + timerHeight);
      return;
    }

    // Draw baseline
    ctx.strokeStyle = "#ddd";
    ctx.beginPath();
    ctx.moveTo(0, waveformHeight / 2);
    ctx.lineTo(canvasWidth, waveformHeight / 2);
    ctx.stroke();

    // Draw arterial pulse waveform
    ctx.strokeStyle = "#0080ff";
    ctx.lineWidth = 2;
    ctx.beginPath();

    const period = MS_PER_MIN / bpm;
    const windowDuration = Math.min(timer, 10000);
    const startTimeWindow = timer - windowDuration;
    const msPerPixel = 1000 / 80;
    const pixelsPerMs = 1 / msPerPixel;

    for (let x = 0; x < canvasWidth; x++) {
      const t = startTimeWindow + x * msPerPixel;
      const phase = ((t % period) / period) * 2 * Math.PI;
      const yValue = arterialPulseWave(phase);
      const y = waveformHeight / 2 - yValue * (waveformHeight / 3);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw pulse peaks (red lines)
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1.5;
    pulsePeaks.forEach((peak) => {
      if (peak < startTimeWindow || peak > timer) return;
      const x = (peak - startTimeWindow) * pixelsPerMs;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, waveformHeight);
      ctx.stroke();
    });

    // Draw throbs (green lines + circles)
    ctx.strokeStyle = "green";
    ctx.fillStyle = "green";
    ctx.lineWidth = 2;
    throbs.forEach((throb) => {
      if (throb < startTimeWindow || throb > timer) return;
      const x = (throb - startTimeWindow) * pixelsPerMs;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, waveformHeight);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, waveformHeight / 2, 6, 0, 2 * Math.PI);
      ctx.fill();
    });

    // Draw timer
    ctx.font = "20px Arial";
    ctx.fillStyle = "black";
    ctx.fillText(formatTime(timer), 10, waveformHeight + timerHeight);
  }

  // Update function (timer and pulses)
  function update() {
    if (!isRecording || isPaused) return;
    const elapsed = Date.now() - startTime;
    timer = elapsed;

    // Update pulse peaks
    const periodMs = MS_PER_MIN / bpm;
    while (pulsePeaks.length === 0 || pulsePeaks[pulsePeaks.length - 1] < timer) {
      const nextPeak = pulsePeaks.length === 0 ? 0 : pulsePeaks[pulsePeaks.length - 1] + periodMs;
      if (nextPeak <= timer) pulsePeaks.push(nextPeak);
      else break;
    }

    draw();
  }

  // Timer interval
  function startInterval() {
    if (intervalId) clearInterval(intervalId);
    intervalId = setInterval(update, 30);
  }
  function stopInterval() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  }

  // Button Handlers
  startBtn.onclick = () => {
    if (!isRecording) {
      if (!recordingNameInput.value.trim()) {
        alert("Please enter a recording name before starting.");
        return;
      }
      bpm = getRandomBPM();
      isRecording = true;
      isPaused = false;
      timer = 0;
      throbs = [];
      pulsePeaks = [];
      startTime = Date.now();
      pauseStart = null;
      markBtn.disabled = false;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      startBtn.disabled = true;
      recordingNameInput.disabled = true;
      startInterval();
      draw();
    }
  };

  pauseBtn.onclick = () => {
    if (!isRecording) return;
    if (!isPaused) {
      // Pause now
      isPaused = true;
      pauseStart = Date.now();
      pauseBtn.textContent = "Resume";
      stopInterval();
    } else {
      // Resume now
      isPaused = false;
      const pausedDuration = Date.now() - pauseStart;
      startTime += pausedDuration;
      pauseStart = null;
      pauseBtn.textContent = "Pause";
      startInterval();
    }
  };

  stopBtn.onclick = () => {
    if (!isRecording) return;
    stopInterval();
    isRecording = false;
    isPaused = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
    markBtn.disabled = true;
    recordingNameInput.disabled = false;

    if (timer < 1000) {
      alert("Recording too short, please record longer than 1 second.");
      return;
    }

    // Calculate temporal synchrony stats
    // Phase differences between throbs and closest pulse peak
    const phases = [];
    for (const throbTime of throbs) {
      // Find closest pulse peak time
      let closestPeak = null;
      let minDiff = Infinity;
      for (const peak of pulsePeaks) {
        const diff = Math.abs(peak - throbTime);
        if (diff < minDiff) {
          minDiff = diff;
          closestPeak = peak;
        }
      }
      if (closestPeak !== null) {
        phases.push(timeDiffToPhase(throbTime - closestPeak, bpm));
      }
    }
    const rayleigh = rayleighTest(phases);
    const pvl = phaseVectorLength(phases);

    // Save recording
    const recording = {
      id: Date.now(),
      name: recordingNameInput.value.trim(),
      bpm,
      duration: timer,
      throbs: throbs.slice(),
      pulsePeaks: pulsePeaks.slice(),
      rayleighPValue: rayleigh.pValue,
      rayleighR: rayleigh.r,
      pvl,
    };
    recordings.push(recording);
    updateRecordingsList();

    // Reset UI
    timer = 0;
    throbs = [];
    pulsePeaks = [];
    recordingNameInput.value = "";
    draw();
  };

  markBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    throbs.push(timer);
    draw();
  };

  toggleShowBtn.onclick = () => {
    showWaveform = !showWaveform;
    toggleShowBtn.textContent = showWaveform ? "Hide Waveform" : "Show Waveform";
    draw();
  };

  function updateRecordingsList() {
    if (recordings.length === 0) {
      recordingsListDiv.innerHTML = "<p>No recordings yet.</p>";
      return;
    }

    let html = "";
    recordings.forEach((rec, i) => {
      html += `<div class="recording">
        <strong>${rec.name}</strong> (BPM: ${rec.bpm}, Duration: ${formatTime(rec.duration)})<br/>
        Throbs: ${rec.throbs.length}, Peaks: ${rec.pulsePeaks.length}<br/>
        Rayleigh p-value: ${rec.rayleighPValue.toFixed(4)}, R: ${rec.rayleighR.toFixed(4)}<br/>
        PVL: ${rec.pvl.toFixed(4)}<br/>
        <button onclick="downloadCSV(${i})">Export CSV</button>
      </div>`;
    });
    recordingsListDiv.innerHTML = html;
  }

  window.downloadCSV = function(index) {
    const rec = recordings[index];
    if (!rec) return alert("Recording not found.");

    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "Recording Name,BPM,Duration(ms),Throb Count,Pulse Peak Count,Mean Pulse Rate (BPM),Rayleigh p-value,Rayleigh R,PVL\n";
    csvContent += `"${rec.name}",${rec.bpm},${rec.duration},${rec.throbs.length},${rec.pulsePeaks.length},${rec.bpm},${rec.rayleighPValue},${rec.rayleighR},${rec.pvl}\n\n`;

    csvContent += "Throb Times (ms)\n";
    rec.throbs.forEach(t => {
      csvContent += t + "\n";
    });
    csvContent += "\nPulse Peak Times (ms)\n";
    rec.pulsePeaks.forEach(t => {
      csvContent += t + "\n";
    });

    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", rec.name.replace(/\s+/g, "_") + "_recording.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Initial draw
  draw();
})();
</script>
</body>
</html>
