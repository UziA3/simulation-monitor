<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Migraine Throb Synchrony App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    canvas {
      border: 1px solid #000;
      display: block;
      margin-bottom: 10px;
    }
    #controls button {
      margin-right: 10px;
    }
    #recordings {
      margin-top: 20px;
    }
    .hidden {
      display: none;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding: 4px;
    }
  </style>
</head>
<body>
  <h1>Migraine Throb Synchrony App</h1>
  <canvas id="ecgCanvas" width="1000" height="200"></canvas>
  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="resumeBtn" disabled>Resume</button>
    <button id="stopBtn" disabled>Stop & Save</button>
    <button id="throbBtn" disabled>Mark Throb</button>
    <label><input type="checkbox" id="toggleView" checked> Show Waveform</label>
    <span id="timer">00:00.00</span>
  </div>
  <div id="recordings">
    <h3>Saved Recordings</h3>
    <ul id="recordingList"></ul>
  </div>

  <script>
    const canvas = document.getElementById('ecgCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const throbBtn = document.getElementById('throbBtn');
    const toggleView = document.getElementById('toggleView');
    const timerEl = document.getElementById('timer');
    const recordingList = document.getElementById('recordingList');

    let ecgData = [];
    let rPeaks = [];
    let throbs = [];
    let recording = false;
    let paused = false;
    let startTime = 0;
    let pauseTime = 0;
    let animationFrame;
    let bpm = 70;
    let nextBPMChange = 0;
    let lastDrawTime = 0;
    let savedRecordings = [];

    const waveformDuration = 5000; // 5 seconds

    function generateECGPoint(t, bpm) {
      const beatInterval = 60000 / bpm;
      const localT = t % beatInterval;
      const normalizedT = localT / beatInterval;

      let value = 0;
      value += Math.exp(-Math.pow((normalizedT - 0.1) * 50, 2)) * 0.1; // P wave
      value += Math.exp(-Math.pow((normalizedT - 0.25) * 150, 2)) * -1; // Q
      value += Math.exp(-Math.pow((normalizedT - 0.3) * 100, 2)) * 2; // R peak
      value += Math.exp(-Math.pow((normalizedT - 0.35) * 150, 2)) * -0.5; // S
      value += Math.exp(-Math.pow((normalizedT - 0.5) * 50, 2)) * 0.3; // T wave
      return value;
    }

    function drawECG() {
      const now = performance.now();
      const elapsed = now - startTime;

      if (!paused && recording) {
        ecgData.push({ t: elapsed, value: generateECGPoint(elapsed, bpm) });

        if (now >= nextBPMChange) {
          bpm = 60 + Math.floor(Math.random() * 41);
          nextBPMChange = now + (3000 + Math.random() * 4000);
        }
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (toggleView.checked) {
        ctx.beginPath();
        const visibleStart = elapsed - waveformDuration;
        let visible = ecgData.filter(p => p.t >= visibleStart);
        visible.forEach((p, i) => {
          const x = (p.t - visibleStart) / waveformDuration * canvas.width;
          const y = canvas.height / 2 - p.value * 80;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = 'black';
        ctx.stroke();

        // R peaks
        rPeaks.forEach(peak => {
          if (peak.t >= visibleStart) {
            const x = (peak.t - visibleStart) / waveformDuration * canvas.width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.strokeStyle = 'red';
            ctx.stroke();
          }
        });

        // Throbs
        throbs.forEach(throb => {
          if (throb >= visibleStart) {
            const x = (throb - visibleStart) / waveformDuration * canvas.width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.strokeStyle = 'green';
            ctx.stroke();
          }
        });
      }

      updateRPeaks();
      updateTimer(elapsed);
      animationFrame = requestAnimationFrame(drawECG);
    }

    function updateRPeaks() {
      const threshold = 1.5;
      if (ecgData.length < 3) return;
      const last = ecgData[ecgData.length - 2];
      const prev = ecgData[ecgData.length - 3];
      const current = ecgData[ecgData.length - 1];
      if (prev.value < last.value && current.value < last.value && last.value > threshold) {
        if (!rPeaks.some(p => Math.abs(p.t - last.t) < 250)) {
          rPeaks.push({ t: last.t, bpm });
        }
      }
    }

    function updateTimer(ms) {
      const sec = Math.floor(ms / 1000);
      const min = Math.floor(sec / 60);
      const s = (sec % 60).toString().padStart(2, '0');
      const m = min.toString().padStart(2, '0');
      const msPart = Math.floor(ms % 1000 / 10).toString().padStart(2, '0');
      timerEl.textContent = `${m}:${s}.${msPart}`;
    }

    function reset() {
      ecgData = [];
      rPeaks = [];
      throbs = [];
      cancelAnimationFrame(animationFrame);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      timerEl.textContent = '00:00.00';
    }

    function computeCSV(recordingName) {
      const totalThrobs = throbs.length;
      const totalPeaks = rPeaks.length;
      const meanBPM = rPeaks.reduce((a, b) => a + b.bpm, 0) / (rPeaks.length || 1);

      let rows = [], deltas = [], phases = [];

      throbs.forEach(t => {
        const prior = [...rPeaks].reverse().find(p => p.t <= t);
        const next = rPeaks.find(p => p.t > t);
        if (prior && next) {
          const delta = t - prior.t;
          const interval = next.t - prior.t;
          const phase = 2 * Math.PI * (delta / interval);
          deltas.push(delta);
          phases.push(phase);
          rows.push([t, prior.t, delta, prior.bpm, phase]);
        } else {
          rows.push([t, '', '', '', '']);
        }
      });

      const R = phases.length ? Math.hypot(...[
        phases.reduce((sum, p) => sum + Math.cos(p), 0),
        phases.reduce((sum, p) => sum + Math.sin(p), 0)
      ]) / phases.length : 0;
      const z = phases.length * R * R;
      const pVal = z < 50 ? Math.exp(-z).toFixed(3) : '<0.001';
      const meanAngle = Math.atan2(
        phases.reduce((sum, p) => sum + Math.sin(p), 0),
        phases.reduce((sum, p) => sum + Math.cos(p), 0)
      );
      const stdDev = deltas.length ? Math.sqrt(deltas.reduce((s, x) => s + (x - (deltas.reduce((a,b) => a+b)/deltas.length))**2, 0) / deltas.length) : 0;

      let csv = `Recording Name: ${recordingName}\nTotal Throb Count: ${totalThrobs}\nTotal Pulse Peak Count: ${totalPeaks}\nMean Pulse Rate (BPM): ${meanBPM.toFixed(1)}\nRayleigh R: ${R.toFixed(4)}\nRayleigh p-value: ${pVal}\nPVL: ${R.toFixed(4)}\nStd Dev of Delta (ms): ${stdDev.toFixed(2)}\nMean Vector Angle (rad): ${meanAngle.toFixed(4)}\n\n`;
      csv += 'Throb Time (ms),Prior Pulse Peak Time (ms),Delta (ms),BPM at Prior Peak,Phase (radians)\n';
      rows.forEach(row => {
        csv += row.join(',') + '\n';
      });
      return csv;
    }

    function downloadCSV(name, csv) {
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${name}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    startBtn.onclick = () => {
      reset();
      recording = true;
      paused = false;
      startTime = performance.now();
      nextBPMChange = startTime + 3000;
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      throbBtn.disabled = false;
      drawECG();
    };

    pauseBtn.onclick = () => {
      paused = true;
      pauseTime = performance.now();
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
    };

    resumeBtn.onclick = () => {
      const now = performance.now();
      const pauseDuration = now - pauseTime;
      startTime += pauseDuration;
      nextBPMChange += pauseDuration;
      paused = false;
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
    };

    stopBtn.onclick = () => {
      recording = false;
      cancelAnimationFrame(animationFrame);
      const name = prompt("Enter recording name:");
      if (name) {
        const csv = computeCSV(name);
        const li = document.createElement('li');
        li.textContent = name + ' ';
        const btn = document.createElement('button');
        btn.textContent = 'Download CSV';
        btn.onclick = () => downloadCSV(name, csv);
        li.appendChild(btn);
        recordingList.appendChild(li);
      }
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
      throbBtn.disabled = true;
    };

    throbBtn.onclick = () => {
      if (recording && !paused) {
        throbs.push(performance.now() - startTime);
      }
    };
  </script>
</body>
</html>
