<!-- Add this just below your existing canvas in the <body> -->
<canvas id="scatterCanvas" width="400" height="400" style="border:1px solid #ccc; margin-top:20px;"></canvas>
<div id="scatterStats" class="stats"></div>

<script>
(() => {
  // Existing vars and code here...

  const scatterCanvas = document.getElementById("scatterCanvas");
  const scatterCtx = scatterCanvas.getContext("2d");
  const scatterStatsDiv = document.getElementById("scatterStats");

  // ... all your existing code unchanged above ...

  // Helper: find nearest peak time to given throb time
  function findNearestPeak(throbTime, peaks) {
    if (peaks.length === 0) return null;
    let nearest = peaks[0];
    let minDiff = Math.abs(throbTime - nearest);
    for (let p of peaks) {
      let diff = Math.abs(throbTime - p);
      if (diff < minDiff) {
        nearest = p;
        minDiff = diff;
      }
    }
    return nearest;
  }

  // Calculate Pearson correlation coefficient (R)
  function pearsonCorrelation(x, y) {
    if (x.length !== y.length || x.length === 0) return null;
    const n = x.length;
    const meanX = x.reduce((a, b) => a + b, 0) / n;
    const meanY = y.reduce((a, b) => a + b, 0) / n;
    let numerator = 0;
    let denomX = 0;
    let denomY = 0;
    for (let i = 0; i < n; i++) {
      const dx = x[i] - meanX;
      const dy = y[i] - meanY;
      numerator += dx * dy;
      denomX += dx * dx;
      denomY += dy * dy;
    }
    if (denomX === 0 || denomY === 0) return null;
    return numerator / Math.sqrt(denomX * denomY);
  }

  // Draw scatter plot of throbs time vs nearest peak time (both relative to startTime)
  function drawScatterPlot(rec) {
    scatterCtx.clearRect(0, 0, scatterCanvas.width, scatterCanvas.height);

    if (!rec || rec.throbs.length === 0) {
      scatterStatsDiv.textContent = "No throbs to plot.";
      return;
    }

    const peaks = findPeaksIn(rec.pulseWave);
    if (peaks.length === 0) {
      scatterStatsDiv.textContent = "No pulse peaks found.";
      return;
    }

    // Build arrays of paired times (both relative to start)
    const throbsRel = rec.throbs.map(t => t.time - rec.startTime);
    const peaksRel = [];

    for (const throb of rec.throbs) {
      const nearestPeak = findNearestPeak(throb.time, peaks);
      peaksRel.push(nearestPeak - rec.startTime);
    }

    // Calculate stats
    const R = pearsonCorrelation(throbsRel, peaksRel);
    const R2 = R !== null ? R * R : null;

    // Plot axes
    const margin = 40;
    const width = scatterCanvas.width;
    const height = scatterCanvas.height;

    const allTimes = throbsRel.concat(peaksRel);
    const minTime = Math.min(...allTimes);
    const maxTime = Math.max(...allTimes);

    function xScale(t) {
      return margin + ((t - minTime) / (maxTime - minTime)) * (width - 2 * margin);
    }
    function yScale(t) {
      return height - margin - ((t - minTime) / (maxTime - minTime)) * (height - 2 * margin);
    }

    // Draw axes lines
    scatterCtx.strokeStyle = "#000";
    scatterCtx.lineWidth = 1;
    scatterCtx.beginPath();
    // X axis
    scatterCtx.moveTo(margin, height - margin);
    scatterCtx.lineTo(width - margin, height - margin);
    // Y axis
    scatterCtx.moveTo(margin, height - margin);
    scatterCtx.lineTo(margin, margin);
    scatterCtx.stroke();

    // Axis labels
    scatterCtx.fillStyle = "#000";
    scatterCtx.font = "14px Arial";
    scatterCtx.fillText("Throb Time (ms)", width / 2 - 40, height - 10);
    scatterCtx.save();
    scatterCtx.translate(15, height / 2 + 40);
    scatterCtx.rotate(-Math.PI / 2);
    scatterCtx.fillText("Nearest Peak Time (ms)", 0, 0);
    scatterCtx.restore();

    // Draw points
    scatterCtx.fillStyle = "red";
    for (let i = 0; i < throbsRel.length; i++) {
      const x = xScale(throbsRel[i]);
      const y = yScale(peaksRel[i]);
      scatterCtx.beginPath();
      scatterCtx.arc(x, y, 4, 0, 2 * Math.PI);
      scatterCtx.fill();
    }

    // Draw line y=x for reference (perfect synchrony)
    scatterCtx.strokeStyle = "blue";
    scatterCtx.lineWidth = 1;
    scatterCtx.beginPath();
    scatterCtx.moveTo(margin, height - margin);
    scatterCtx.lineTo(width - margin, margin);
    scatterCtx.stroke();

    // Display stats
    scatterStatsDiv.innerHTML = `<b>Scatter Plot Stats:</b><br> Pearson R: ${R !== null ? R.toFixed(4) : "N/A"}<br> R²: ${R2 !== null ? R2.toFixed(4) : "N/A"}`;
  }

  // Update displayStatsForRecording to call drawScatterPlot and include R, R² in CSV
  function displayStatsForRecording(index) {
    if (index === null || index < 0 || index >= savedRecordings.length) {
      metricsDisplay.textContent = "";
      scatterStatsDiv.textContent = "";
      return;
    }
    const rec = savedRecordings[index];
    const phases = rec.throbs.map(throb => calculatePhaseInRecording(throb.time, rec.pulseWave)).filter(p => p !== null);
    if (phases.length === 0) {
      metricsDisplay.textContent = "No throbs or insufficient data for stats.";
      scatterStatsDiv.textContent = "";
      return;
    }
    const meanPhase = circularMean(phases);
    const plv = phaseLockingValue(phases);
    const rayleighP = rayleighTest(phases);

    metricsDisplay.innerHTML = `<b>Overall Stats for "${rec.name || "Recording"}":</b><br>` +
      `Mean Phase (rad): ${meanPhase.toFixed(4)}<br>` +
      `Phase Locking Value (PLV): ${plv.toFixed(4)}<br>` +
      `Rayleigh p-value: ${formatPValue(rayleighP)}`;

    drawScatterPlot(rec);
  }

  // Extend generateCSV to include Pearson R and R² after overall stats
  function generateCSV(rec) {
    const lines = [];
    lines.push("Throb Index,Throb Time (ms),Throb Time (s),Phase (rad),Pulse Value");
    const pulseWaveRec = rec.pulseWave;
    const throbsRec = rec.throbs;

    throbsRec.forEach((throb, idx) => {
      const tMs = throb.time - rec.startTime;
      const tS = tMs / 1000;
      const phase = calculatePhaseInRecording(throb.time, pulseWaveRec);
      const val = interpolatePulseValueIn(pulseWaveRec, throb.time);
      lines.push([
        idx + 1,
        formatMs(tMs),
        tS.toFixed(3),
        phase !== null ? phase.toFixed(3) : "",
        val !== null ? val.toFixed(3) : ""
      ].join(","));
    });

    // Calculate phases for stats
    const phases = throbsRec.map(throb => calculatePhaseInRecording(throb.time, pulseWaveRec)).filter(p => p !== null);

    const meanPhase = circularMean(phases);
    const plv = phaseLockingValue(phases);
    const rayleighP = rayleighTest(phases);

    // Calculate Pearson R and R² for scatter plot
    const peaks = findPeaksIn(pulseWaveRec);
    const throbsRel = throbsRec.map(t => t.time);
    const peaksRel = throbsRel.map(t => findNearestPeak(t, peaks));

    // Filter out any null nearest peak
    const validPairs = throbsRel.map((t, i) => {
      if (peaksRel[i] !== null) return [t - rec.startTime, peaksRel[i] - rec.startTime];
      return null;
    }).filter(x => x !== null);

    const xVals = validPairs.map(p => p[0]);
    const yVals = validPairs.map(p => p[1]);
    const R = pearsonCorrelation(xVals, yVals);
    const R2 = R !== null ? R * R : null;

    lines.push("");
    lines.push(`Mean Phase (rad),${meanPhase.toFixed(4)}`);
    lines.push(`PLV,${plv.toFixed(4)}`);
    lines.push(`Rayleigh p-value,${formatPValue(rayleighP)}`);
    lines.push(`Pearson R,${R !== null ? R.toFixed(4) : ""}`);
    lines.push(`R²,${R2 !== null ? R2.toFixed(4) : ""}`);

    return lines.join("\n");
  }

  // Your existing event handlers, initializations, etc...

})();
</script>
