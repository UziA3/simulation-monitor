<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Migraine Throb Sync App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem auto;
      max-width: 900px;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
      margin-bottom: 1rem;
    }
    button, input {
      margin: 5px;
    }
    .recording {
      border: 1px solid #ddd;
      padding: 10px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h2>Migraine Throb Temporal Synchrony App</h2>
  <canvas id="canvas" width="800" height="230"></canvas>
  <div>
    <input type="text" id="recordingName" placeholder="Enter recording name" />
    <button id="startBtn">Start</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="stopBtn" disabled>Stop & Save</button>
    <button id="markBtn" disabled>Mark Throb</button>
    <button id="toggleBtn">Hide Waveform</button>
  </div>

  <h3>Recordings</h3>
  <div id="recordingsList"><p>No recordings yet.</p></div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stopBtn = document.getElementById("stopBtn");
    const markBtn = document.getElementById("markBtn");
    const toggleBtn = document.getElementById("toggleBtn");
    const recordingNameInput = document.getElementById("recordingName");
    const recordingsList = document.getElementById("recordingsList");

    const MS_PER_MIN = 60000;
    const canvasHeight = 200;

    let isRecording = false, isPaused = false, showWaveform = true;
    let timer = 0;
    let startTime = null;
    let pauseStart = null;
    let intervalId = null;

    let throbs = [];
    let pulsePeaks = [];
    let pulseSchedule = [];
    let currentBPM = 75;
    let nextBPMChange = 0;

    const recordings = [];

    function getRandomBPM() {
      return 60 + Math.random() * 40;
    }

    function schedulePulsePeaks(duration) {
      const schedule = [];
      let t = 0;
      while (t < duration) {
        const bpm = getRandomBPM();
        const period = MS_PER_MIN / bpm;
        const changeDuration = 3000 + Math.random() * 4000;
        const changeEnd = t + changeDuration;

        while (t < changeEnd && t < duration) {
          schedule.push({ time: t, bpm });
          t += period;
        }
      }
      return schedule;
    }

    function updatePulsePeaks() {
      const lastTime = timer;
      const newPeaks = [];

      while (pulseSchedule.length && pulseSchedule[0].time <= lastTime) {
        const peak = pulseSchedule.shift();
        pulsePeaks.push(peak.time);
        newPeaks.push(peak.time);
      }
    }

    function arterialPulseShape(phase) {
      const riseEnd = 0.3 * 2 * Math.PI;
      return phase < riseEnd
        ? Math.sin((phase / riseEnd) * Math.PI)
        : Math.cos(((phase - riseEnd) / (2 * Math.PI - riseEnd)) * Math.PI) * 0.5;
    }

    function drawWaveform() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!showWaveform) {
        ctx.fillStyle = "black";
        ctx.fillText(formatTime(timer), 10, 220);
        return;
      }

      ctx.beginPath();
      ctx.strokeStyle = "#0080ff";
      const viewMs = 8000;
      const startTimeView = Math.max(0, timer - viewMs);
      const pixelsPerMs = canvas.width / viewMs;

      for (let x = 0; x < canvas.width; x++) {
        const t = startTimeView + x / pixelsPerMs;
        const bpmHere = getBPMAtTime(t);
        const period = MS_PER_MIN / bpmHere;
        const phase = ((t % period) / period) * 2 * Math.PI;
        const y = canvasHeight / 2 - arterialPulseShape(phase) * 60;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      pulsePeaks.forEach(p => {
        if (p >= startTimeView && p <= timer) {
          const x = (p - startTimeView) * pixelsPerMs;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.strokeStyle = "red";
          ctx.stroke();
        }
      });

      throbs.forEach(t => {
        if (t >= startTimeView && t <= timer) {
          const x = (t - startTimeView) * pixelsPerMs;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvasHeight);
          ctx.strokeStyle = "green";
          ctx.stroke();
        }
      });

      ctx.fillStyle = "black";
      ctx.fillText(formatTime(timer), 10, 220);
    }

    function formatTime(ms) {
      const s = Math.floor(ms / 1000);
      const min = Math.floor(s / 60);
      const sec = s % 60;
      const msR = ms % 1000;
      return `${min}:${sec.toString().padStart(2, '0')}.${msR.toString().padStart(3, '0')}`;
    }

    function updateTimer() {
      if (!isPaused) {
        timer = Date.now() - startTime;
        updatePulsePeaks();
        drawWaveform();
      }
    }

    function getBPMAtTime(time) {
      let bpm = currentBPM;
      for (const entry of pulsePeaks) {
        if (entry > time) break;
        bpm = entry.bpm || bpm;
      }
      return bpm;
    }

    function computeStats(name) {
      const results = [];
      const phases = [];
      const deltas = [];

      throbs.forEach(throb => {
        const priorPeak = pulsePeaks.filter(p => p <= throb).pop();
        if (priorPeak != null) {
          const delta = throb - priorPeak;
          const bpmAtPeak = getBPMAtTime(priorPeak);
          const period = MS_PER_MIN / bpmAtPeak;
          const phase = ((delta % period) / period) * 2 * Math.PI;
          results.push([throb, priorPeak, delta, phase]);
          deltas.push(delta);
          phases.push(phase);
        }
      });

      const R = phases.length
        ? Math.sqrt(
            phases.reduce((sum, a) => sum + Math.cos(a), 0) ** 2 +
            phases.reduce((sum, a) => sum + Math.sin(a), 0) ** 2
          ) / phases.length
        : 0;

      const Z = phases.length * R * R;
      const pVal = Math.exp(-Z);
      const meanBPM = (pulsePeaks.length / (timer / 60000)).toFixed(2);

      let csv = `Recording: ${name}\nTotal Peaks: ${pulsePeaks.length}\nMean Pulse Rate: ${meanBPM} BPM\nRayleigh R: ${R.toFixed(4)}\nRayleigh p-value: ${pVal.toExponential(4)}\n\nThrob Time (ms), Prior Peak (ms), Delta (ms), Phase (rad)\n`;
      results.forEach(r => {
        csv += `${r[0].toFixed(2)},${r[1].toFixed(2)},${r[2].toFixed(2)},${r[3].toFixed(4)}\n`;
      });
      return csv;
    }

    function saveRecording() {
      const name = recordingNameInput.value.trim();
      if (!name) return alert("Please enter a name");

      const csv = computeStats(name);
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${name.replace(/\s+/g, "_")}_recording.csv`;
      a.click();
      URL.revokeObjectURL(url);

      recordings.push(name);
      updateRecordingList();
    }

    function updateRecordingList() {
      recordingsList.innerHTML = recordings
        .map(name => `<div class="recording">${name}</div>`)
        .join("");
    }

    // BUTTONS
    startBtn.onclick = () => {
      if (!recordingNameInput.value.trim()) return alert("Enter a name");
      isRecording = true;
      isPaused = false;
      timer = 0;
      throbs = [];
      pulsePeaks = [];
      pulseSchedule = schedulePulsePeaks(600000); // simulate 10 minutes ahead
      startTime = Date.now();
      intervalId = setInterval(updateTimer, 30);
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      markBtn.disabled = false;
      recordingNameInput.disabled = true;
    };

    pauseBtn.onclick = () => {
      if (isPaused) {
        startTime += Date.now() - pauseStart;
        intervalId = setInterval(updateTimer, 30);
        pauseBtn.textContent = "Pause";
        isPaused = false;
      } else {
        clearInterval(intervalId);
        pauseStart = Date.now();
        pauseBtn.textContent = "Resume";
        isPaused = true;
      }
    };

    stopBtn.onclick = () => {
      clearInterval(intervalId);
      isRecording = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;
      markBtn.disabled = true;
      startBtn.disabled = false;
      recordingNameInput.disabled = false;
      pauseBtn.textContent = "Pause";
      saveRecording();
    };

    markBtn.onclick = () => {
      if (!isPaused) throbs.push(timer);
    };

    toggleBtn.onclick = () => {
      showWaveform = !showWaveform;
      toggleBtn.textContent = showWaveform ? "Hide Waveform" : "Show Waveform";
      drawWaveform();
    };
  </script>
</body>
</html>
