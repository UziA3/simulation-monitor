<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pulse Throb Monitor</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { border: 1px solid #ccc; margin-bottom: 10px; }
    button, label { margin: 5px; }
    .stats { margin-top: 10px; }
  </style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<canvas id="canvas" width="800" height="200"></canvas><br>

<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<div class="controls">
  <button id="toggleMetricsBtn">Hide Live Metrics</button><br>

  <label><input type="checkbox" id="showThrobMarkers" checked> Show Throb Markers</label>
  <label><input type="checkbox" id="showPeakMarkers" checked> Show Peak Markers</label>
</div>

<div class="stats" id="metricsDisplay">
  <!-- Live metrics shown here -->
</div>

<ul id="recordingsList"></ul>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const toggleMetricsBtn = document.getElementById("toggleMetricsBtn");
  const showThrobMarkers = document.getElementById("showThrobMarkers");
  const showPeakMarkers = document.getElementById("showPeakMarkers");

  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId;
  let lastSampleTime = 0;

  // Controls whether live metrics are visible
  let metricsVisible = true;

  // Constants
  const DISPLAY_DURATION = 20000; // 20 seconds display window
  const SAMPLE_INTERVAL = 20; // ms per sample
  const WAVE_BASELINE = 100;
  const WAVE_AMPLITUDE = 50;
  const WAVE_FREQ = 1.2 + Math.random() * 0.5;

  // --- Simulation of pulse waveform ---
  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const value = WAVE_BASELINE + WAVE_AMPLITUDE * Math.sin(2 * Math.PI * WAVE_FREQ * t);
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    // Keep samples within some reasonable memory limit (e.g. last 5 min)
    const maxMemoryDuration = 5 * 60 * 1000;
    const cutoff = performance.now() - maxMemoryDuration;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  // --- Draw the waveform and markers ---
  function draw() {
    simulatePulse();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    // Draw waveform line
    ctx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs as red dots if visible
    if (metricsVisible && showThrobMarkers.checked) {
      throbs.forEach(throb => {
        if (throb.time < start || throb.time > now) return;
        const val = interpolatePulseValue(throb.time);
        if (val === null) return;
        const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
        const y = canvas.height - val;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();
      });
    }

    // Draw detected peaks as green dots if visible
    if (metricsVisible && showPeakMarkers.checked) {
      const peaks = findPeaks();
      peaks.forEach(peakTime => {
        if (peakTime < start || peakTime > now) return;
        const val = interpolatePulseValue(peakTime);
        if (val === null) return;
        const x = ((peakTime - start) / DISPLAY_DURATION) * canvas.width;
        const y = canvas.height - val;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = "green";
        ctx.fill();
      });
    }

    if (isRecording && !isPaused) {
      animationId = requestAnimationFrame(draw);
    }
  }

  // --- Interpolate pulse value at given time ---
  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  // --- Find peaks across full pulseWave array ---
  function findPeaks() {
    const peaks = [];
    const window = 2; // neighbors on each side for peak detection
    for (let i = window; i < pulseWave.length - window; i++) {
      const cur = pulseWave[i].value;
      let isPeak = true;
      for (let j = 1; j <= window; j++) {
        if (cur <= pulseWave[i - j].value || cur <= pulseWave[i + j].value) {
          isPeak = false;
          break;
        }
      }
      if (isPeak) peaks.push(pulseWave[i].time);
    }
    return peaks;
  }

  // --- Calculate phase of a timepoint relative to surrounding peaks ---
  function calculatePhase(t) {
    const peaks = findPeaks();
    let prev = null, next = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prev = peaks[i];
        next = peaks[i + 1];
        break;
      }
    }
    if (prev === null || next === null) return null;
    return 2 * Math.PI * (t - prev) / (next - prev);
  }

  // --- Circular mean ---
  function circularMean(angles) {
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    return Math.atan2(sumSin, sumCos);
  }

  // --- Circular variance ---
  function circularVariance(angles) {
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    ) / n;
    return 1 - R;
  }

  // --- Rayleigh test p-value ---
  function rayleighTest(angles) {
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    );
    const z = (R * R) / n;
    return Math.exp(-z);
  }

  // --- Calculate PLV and other stats for throbs with valid phase ---
  function calculatePLV() {
    const valid = throbs.filter(t => t.phase !== null);
    if (valid.length === 0) return { plv: 0, mean: null, variance: null, rayleigh: null };
    const phases = valid.map(t => t.phase);
    const mean = circularMean(phases);
    const variance = circularVariance(phases);
    const rayleigh = rayleighTest(phases);
    const sumReal = phases.reduce((a, p) => a + Math.cos(p), 0);
    const sumImag = phases.reduce((a, p) => a + Math.sin(p), 0);
    const plv = Math.sqrt(sumReal ** 2 + sumImag ** 2) / valid.length;
    return { plv, mean, variance, rayleigh };
  }

  // --- Calculate median pulse rate (bpm) from peaks ---
  function calculateMedianPulseRate() {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;
    const intervals = [];
    for (let i = 1; i < peaks.length; i++) {
      intervals.push(peaks[i] - peaks[i - 1]);
    }
    intervals.sort((a,b) => a - b);
    const mid = Math.floor(intervals.length / 2);
    const medianInterval = intervals.length % 2 === 0
      ? (intervals[mid -1] + intervals[mid]) / 2
      : intervals[mid];
    if (!medianInterval || medianInterval === 0) return null;
    return 60000 / medianInterval; // bpm
  }

  // --- Update metrics display ---
  function updateMetricsDisplay() {
    if (!metricsVisible) {
      metricsDisplay.innerHTML = "";
      return;
    }
    const stats = calculatePLV();
    const medianPulseRate = calculateMedianPulseRate();
    const totalPeaks = findPeaks().length;
    const totalThrobs = throbs.length;

    const lines = [];
    lines.push(`PLV: ${stats.plv.toFixed(4)}`);
    lines.push(`Mean Phase: ${stats.mean !== null ? stats.mean.toFixed(4) : "N/A"}`);
    lines.push(`Phase Variance: ${stats.variance !== null ? stats.variance.toFixed(4) : "N/A"}`);
    lines.push(`Rayleigh p-value: ${stats.rayleigh !== null ? stats.rayleigh.toExponential(4) : "N/A"}`);
    lines.push(`Total Peaks: ${totalPeaks}`);
    lines.push(`Total Throbs: ${totalThrobs}`);
    lines.push(`Median Pulse Rate (bpm): ${medianPulseRate !== null ? medianPulseRate.toFixed(1) : "N/A"}`);

    metricsDisplay.innerHTML = lines.join("<br>");
  }

  // --- Update timer display ---
  function updateTimer() {
    const elapsed = performance.now() - recordingStartTime;
    const mins = Math.floor(elapsed / 60000);
    const secs = Math.floor((elapsed % 60000) / 1000);
    timerDisplay.textContent = `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  }

  // --- Button handlers ---
  startBtn.onclick = () => {
    pulseWave = [];
    throbs = [];
    recordingStartTime = performance.now();
    isRecording = true;
    isPaused = false;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;

    updateMetricsDisplay();
    updateTimer();
    timerInterval = setInterval(() => {
      updateTimer();
      updateMetricsDisplay();
    }, 500);
    draw();
  };

  pauseBtn.onclick = () => {
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
    cancelAnimationFrame(animationId);
    clearInterval(timerInterval);
  };

  resumeBtn.onclick = () => {
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
    timerInterval = setInterval(() => {
      updateTimer();
      updateMetricsDisplay();
    }, 500);
    draw();
  };

  stopBtn.onclick = () => {
    isRecording = false;
    isPaused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;

    cancelAnimationFrame(animationId);
    clearInterval(timerInterval);
    updateMetricsDisplay();

    exportCSV();
  };

  throbBtn.onclick = () => {
    const now = performance.now();
    const phase = calculatePhase(now);
    throbs.push({ time: now, phase });
    updateMetricsDisplay();
  };

  // Toggle showing/hiding all live metrics text
  toggleMetricsBtn.onclick = () => {
    metricsVisible = !metricsVisible;
    toggleMetricsBtn.textContent = metricsVisible ? "Hide Live Metrics" : "Show Live Metrics";
    updateMetricsDisplay();
    if (metricsVisible && isRecording && !isPaused) {
      draw();
    } else {
      cancelAnimationFrame(animationId);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  };

  // Redraw on marker checkbox changes (if metrics visible)
  showThrobMarkers.onchange = () => {
    if (metricsVisible && isRecording && !isPaused) draw();
  };

  showPeakMarkers.onchange = () => {
    if (metricsVisible && isRecording && !isPaused) draw();
  };

  // --- Export data as CSV ---
  function exportCSV() {
    const peaks = findPeaks();

    // Ensure all throbs have phase (calculate if missing)
    throbs.forEach(t => {
      if (t.phase === null || t.phase === undefined) {
        t.phase = calculatePhase(t.time);
      }
    });

    let csv = "Timestamp(ms),Value,ThrobFlag\n";
    pulseWave.forEach(p => {
      const throbFlag = throbs.some(t => Math.abs(t.time - p.time) < SAMPLE_INTERVAL) ? 1 : 0;
      csv += `${p.time.toFixed(0)},${p.value.toFixed(2)},${throbFlag}\n`;
    });

    // Add full stats summary regardless of display state
    const stats = calculatePLV();
    const medianPulseRate = calculateMedianPulseRate();

    csv += `\nSummary Stats\n`;
    csv += `Total Peaks,${peaks.length}\n`;
    csv += `Total Throbs,${throbs.length}\n`;
    csv += `Median Pulse Rate (bpm),${medianPulseRate !== null ? medianPulseRate.toFixed(2) : "N/A"}\n`;
    csv += `PLV,${stats.plv.toFixed(4)}\n`;
    csv += `Mean Phase,${stats.mean !== null ? stats.mean.toFixed(4) : "N/A"}\n`;
    csv += `Phase Variance,${stats.variance !== null ? stats.variance.toFixed(4) : "N/A"}\n`;
    csv += `Rayleigh p-value,${stats.rayleigh !== null ? stats.rayleigh.toExponential(4) : "N/A"}\n`;

    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `pulse_throb_${Date.now()}.csv`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  }
})();
</script>

</body>
</html>
