<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #fafafa;
    color: #333;
  }
  h1 {
    text-align: center;
    margin-bottom: 10px;
  }
  #controls {
    text-align: center;
    margin-bottom: 10px;
  }
  button {
    margin: 0 5px 10px;
    padding: 8px 14px;
    font-size: 14px;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #666;
    background: #fff;
    transition: background-color 0.3s ease;
  }
  button:hover:not(:disabled) {
    background: #eef;
  }
  button:disabled {
    cursor: not-allowed;
    color: #999;
    border-color: #ccc;
  }
  #timer {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
  }
  #canvasContainer {
    text-align: center;
    margin-bottom: 20px;
  }
  canvas {
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 6px;
    max-width: 100%;
  }
  #recordingsList {
    max-width: 700px;
    margin: 0 auto;
    padding: 10px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
  }
  #recordingsList h2 {
    margin-top: 0;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
    color: #222;
  }
  .recording-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid #eee;
    font-size: 14px;
    color: #444;
  }
  .recording-item:last-child {
    border-bottom: none;
  }
  .recording-name {
    flex-grow: 1;
    margin-right: 10px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .recording-item button {
    padding: 5px 10px;
    font-size: 13px;
    background: #0078d7;
    border-color: #005fa3;
    color: white;
  }
  .recording-item button:hover:not(:disabled) {
    background: #005fa3;
  }
</style>
</head>
<body>

<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop &amp; Save</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn" disabled>Hide Waveform</button>
</div>

<div id="timer">00:00.000</div>

<div id="canvasContainer">
  <canvas id="waveformCanvas" width="700" height="200"></canvas>
</div>

<div id="recordingsList">
  <h2>Saved Recordings</h2>
  <p>No recordings yet.</p>
</div>

<script>
const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const stopBtn = document.getElementById('stopBtn');
const throbBtn = document.getElementById('throbBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const recordingsList = document.getElementById('recordingsList');
const timerDisplay = document.getElementById('timer');

let recordingState = 'stopped'; // 'running', 'paused', 'stopped'
let startTime = null;
let pauseStart = null;
let elapsedPause = 0;
let animationFrameId = null;

let bpm = 75; // initial BPM
let bpmHistory = [];
let bpmChangeTimeout = null;

let showWaveform = true;

let waveformData = []; // {time(ms), value}
let pulsePeaks = [];   // array of peak times (ms)

let throbs = [];       // {timestamp(ms)}

let savedRecordings = [];

function formatTime(ms) {
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  const millis = ms % 1000;
  return `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}.${millis.toString().padStart(3,'0')}`;
}

function getCurrentTimestamp() {
  if(recordingState === 'running'){
    return Date.now() - startTime - elapsedPause;
  }
  else if(recordingState === 'paused'){
    return pauseStart - startTime - elapsedPause;
  }
  return 0;
}

// --- Improved realistic arterial pulse waveform generator ---
// We model a pulse waveform using a sum of 3 Gaussian-like bumps per cycle:
// 1) main systolic peak (highest)
// 2) dicrotic notch (dip after main peak)
// 3) dicrotic wave (secondary smaller peak)
// Parameters based on typical arterial pulse morphology

function arterialPulseWaveform(t, bpm){
  // t in ms within the current pulse cycle [0, cycleLength)
  const cycleLength = 60000 / bpm;
  const x = t / cycleLength; // normalized cycle time [0,1]

  // Main systolic peak around 0.15 normalized time
  const mainPeak = Math.exp(-Math.pow((x - 0.15)/0.05, 2) / 2) * 1.0;

  // Dicrotic notch (dip) around 0.3 normalized time
  const dicroticNotch = -0.4 * Math.exp(-Math.pow((x - 0.3)/0.02, 2) / 2);

  // Dicrotic wave (secondary smaller peak) around 0.45 normalized time
  const dicroticWave = 0.3 * Math.exp(-Math.pow((x - 0.45)/0.04, 2) / 2);

  // Baseline (diastolic level)
  const baseline = 0;

  // Sum components for full waveform
  return baseline + mainPeak + dicroticNotch + dicroticWave;
}

// --- Generate waveform data point ---
function generateWaveformPoint(timeMs){
  // Determine current BPM segment
  // Find most recent BPM change before timeMs
  let segment = bpmHistory[0];
  for(let i=bpmHistory.length-1; i>=0; i--){
    if(bpmHistory[i].time <= timeMs){
      segment = bpmHistory[i];
      break;
    }
  }

  const bpmValue = segment.bpm;
  const cycleLength = 60000 / bpmValue;
  const timeInCycle = (timeMs - segment.time) % cycleLength;

  // Calculate waveform value for arterial pulse
  return arterialPulseWaveform(timeInCycle, bpmValue);
}

// --- Peak detection over waveform data ---
// We find local maxima above a threshold and pick the highest peak per cycle

function detectPulsePeaks(data){
  const peaks = [];
  const threshold = 0.5; // only count peaks higher than this

  for(let i=1; i<data.length-1; i++){
    if(data[i].value > threshold && data[i].value > data[i-1].value && data[i].value >= data[i+1].value){
      peaks.push(data[i].time);
    }
  }
  return peaks;
}

// --- Analyze throbs relative to pulse peaks ---
function analyzeThrobs(throbTimes, peaks){
  if(peaks.length === 0) return [];

  const results = [];

  for(let throb of throbTimes){
    // Find immediately preceding pulse peak
    let prevPeak = null;
    for(let i=peaks.length-1; i>=0; i--){
      if(peaks[i] <= throb.timestamp){
        prevPeak = peaks[i];
        break;
      }
    }
    if(prevPeak === null) continue;

    // Find BPM at that peak
    let bpmAtPeak = bpmHistory[0].bpm;
    for(let i=bpmHistory.length-1; i>=0; i--){
      if(bpmHistory[i].time <= prevPeak){
        bpmAtPeak = bpmHistory[i].bpm;
        break;
      }
    }

    // Calculate delta (throb - peak)
    const delta = throb.timestamp - prevPeak;

    // Calculate phase in radians normalized to cycle length
    const cycleLength = 60000 / bpmAtPeak;
    const phase = (delta % cycleLength) / cycleLength * 2 * Math.PI;

    results.push({
      throbTime: throb.timestamp,
      priorPulsePeak: prevPeak,
      delta,
      bpmAtPeak,
      phase
    });
  }
  return results;
}

// --- Circular statistics ---
// Rayleigh test R and p-value based on phases array in radians

function rayleighTest(phases){
  if(phases.length === 0) return {R: 0, pValue: 1};
  let sumSin = 0;
  let sumCos = 0;
  for(let ph of phases){
    sumSin += Math.sin(ph);
    sumCos += Math.cos(ph);
  }
  const n = phases.length;
  const R = Math.sqrt(sumSin*sumSin + sumCos*sumCos) / n;
  const z = n * R * R;

  // Approximate p-value (for large n)
  const pValue = Math.exp(-z) * (1 + (2*z - z*z) / (4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z)/(288*n*n));
  return {R, pValue};
}

// Phase Vector Length (PVL) - same as mean resultant length
function phaseVectorLength(phases){
  if(phases.length === 0) return 0;
  let sumSin = 0;
  let sumCos = 0;
  for(let ph of phases){
    sumSin += Math.sin(ph);
    sumCos += Math.cos(ph);
  }
  const n = phases.length;
  return Math.sqrt(sumSin*sumSin + sumCos*sumCos) / n;
}

// Standard deviation of deltas
function stdDevDeltas(deltas){
  if(deltas.length === 0) return 0;
  const mean = deltas.reduce((a,b)=>a+b,0) / deltas.length;
  const variance = deltas.reduce((a,b)=>a + (b - mean)**2, 0) / deltas.length;
  return Math.sqrt(variance);
}

// Mean vector angle
function meanVectorAngle(phases){
  if(phases.length === 0) return 0;
  let sumSin = 0;
  let sumCos = 0;
  for(let ph of phases){
    sumSin += Math.sin(ph);
    sumCos += Math.cos(ph);
  }
  return Math.atan2(sumSin, sumCos);
}

// --- CSV generation ---
function generateCSV(rec){
  // Format p-value with requested style
  let rayleighPFormatted = rec.rayleighPValue < 0.001 ? '<0.001' : rec.rayleighPValue.toFixed(3);

  let header = `Recording Name:,${rec.name}
Total Throb Count:,${rec.throbs.length}
Total Pulse Peak Count:,${rec.pulsePeaks.length}
Mean Pulse Rate (BPM):,${rec.meanBPM.toFixed(1)}
Rayleigh R:,${rec.rayleighR.toFixed(3)}
Rayleigh p-value:,${rayleighPFormatted}
PVL:,${rec.pvl.toFixed(3)}
Std Dev of Deltas (ms):,${rec.stdDevDelta.toFixed(1)}
Mean Vector Angle (radians):,${rec.meanVectorAngle.toFixed(3)}

Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)
`;

  let rows = rec.throbs.map(t =>
    `${t.throbTime},${t.priorPulsePeak},${t.delta},${t.bpmAtPeak},${t.phase.toFixed(4)}`
  ).join('\n');

  return header + rows;
}

function downloadCSV(filename, text){
  const blob = new Blob([text], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 0);
}

// --- Canvas drawing ---
function clearCanvas(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function drawWaveform(){
  clearCanvas();
  if(!showWaveform) return;

  ctx.lineWidth = 2;
  ctx.strokeStyle = '#0078d7'; // blue waveform

  ctx.beginPath();
  const len = waveformData.length;
  if(len < 2) return;

  const timeSpan = waveformData[len-1].time - waveformData[0].time;
  if(timeSpan === 0) return;

  const pixelsPerMs = canvas.width / timeSpan;

  for(let i=0; i<len; i++){
    const x = (waveformData[i].time - waveformData[0].time) * pixelsPerMs;
    // Scale waveform amplitude to canvas height
    const y = canvas.height/2 - waveformData[i].value * (canvas.height/2 - 20);
    if(i === 0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // Draw pulse peaks as red vertical lines
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1.5;
  for(let peak of pulsePeaks){
    if(peak < waveformData[0].time || peak > waveformData[waveformData.length-1].time) continue;
    const x = (peak - waveformData[0].time) * pixelsPerMs;
    ctx.beginPath();
    ctx.moveTo(x, 10);
    ctx.lineTo(x, canvas.height - 10);
    ctx.stroke();
  }

  // Draw throbs as green vertical lines
  ctx.strokeStyle = 'green';
  ctx.lineWidth = 1.5;
  for(let throb of throbs){
    if(throb.timestamp < waveformData[0].time || throb.timestamp > waveformData[waveformData.length-1].time) continue;
    const x = (throb.timestamp - waveformData[0].time) * pixelsPerMs;
    ctx.beginPath();
    ctx.moveTo(x, 10);
    ctx.lineTo(x, canvas.height - 10);
    ctx.stroke();
  }
}

// --- BPM management ---

function scheduleNextBPMChange(){
  if(recordingState !== 'running') return;

  const interval = 3000 + Math.random() * 4000; // 3-7 seconds
  bpmChangeTimeout = setTimeout(() => {
    bpm = 60 + Math.random() * 40; // 60-100 BPM
    bpmHistory.push({time: getCurrentTimestamp(), bpm: bpm});
    scheduleNextBPMChange();
  }, interval);
}

// --- Animation loop ---
function animationLoop(){
  if(recordingState !== 'running') return;

  const now = getCurrentTimestamp();

  // Generate waveform point every ~10ms (100Hz)
  if(waveformData.length === 0 || now - waveformData[waveformData.length-1].time >= 10){
    const val = generateWaveformPoint(now);
    waveformData.push({time: now, value: val});
  }

  // Keep last ~30 seconds of data only for performance
  const windowSize = 30000;
  const startCutoff = now - windowSize;
  while(waveformData.length > 0 && waveformData[0].time < startCutoff){
    waveformData.shift();
  }

  // Update detected peaks on current waveform window
  pulsePeaks = detectPulsePeaks(waveformData);

  // Update timer
  timerDisplay.textContent = formatTime(now);

  // Draw waveform & markers
  drawWaveform();

  animationFrameId = requestAnimationFrame(animationLoop);
}

// --- Button handlers ---
startBtn.onclick = () => {
  if(recordingState === 'running') return;

  recordingState = 'running';
  startTime = Date.now();
  elapsedPause = 0;
  waveformData = [];
  pulsePeaks = [];
  throbs = [];
  bpmHistory = [{time: 0, bpm}];

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  throbBtn.disabled = false;
  toggleWaveformBtn.disabled = false;
  toggleWaveformBtn.textContent = 'Hide Waveform';

  scheduleNextBPMChange();

  animationLoop();
};

pauseBtn.onclick = () => {
  if(recordingState !== 'running') return;
  recordingState = 'paused';
  pauseStart = Date.now();
  clearTimeout(bpmChangeTimeout);

  startBtn.disabled = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = false;
  stopBtn.disabled = false;
  throbBtn.disabled = true;
};

resumeBtn.onclick = () => {
  if(recordingState !== 'paused') return;
  recordingState = 'running';
  const now = Date.now();
  elapsedPause += now - pauseStart;
  pauseStart = null;

  scheduleNextBPMChange();

  startBtn.disabled = true;
  pauseBtn.disabled = false;
  resumeBtn.disabled = true;
  stopBtn.disabled = false;
  throbBtn.disabled = false;

  animationLoop();
};

stopBtn.onclick = () => {
  if(recordingState === 'stopped') return;
  recordingState = 'stopped';
  clearTimeout(bpmChangeTimeout);
  cancelAnimationFrame(animationFrameId);

  startBtn.disabled = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  toggleWaveformBtn.disabled = true;

  // Analyze data for saving
  if(throbs.length === 0){
    alert('No throbs recorded. Nothing to save.');
    return;
  }

  // Analyze throbs relative to pulse peaks
  const analyzed = analyzeThrobs(throbs, pulsePeaks);
  if(analyzed.length === 0){
    alert('No valid throbs found relative to pulse peaks.');
    return;
  }

  const phases = analyzed.map(a => a.phase);
  const deltas = analyzed.map(a => a.delta);

  const rayleigh = rayleighTest(phases);
  const pvl = phaseVectorLength(phases);
  const stdDelta = stdDevDeltas(deltas);
  const meanAngle = meanVectorAngle(phases);

  const meanBPM = bpmHistory.reduce((a,b)=>a.bpm+a,bpmHistory[0].bpm)/bpmHistory.length;

  const recordingName = prompt('Enter a name for this recording:', `Recording_${savedRecordings.length+1}`);
  if(!recordingName) return;

  const rec = {
    name: recordingName,
    throbs: analyzed,
    pulsePeaks: pulsePeaks,
    meanBPM,
    rayleighR: rayleigh.R,
    rayleighPValue: rayleigh.pValue,
    pvl,
    stdDevDelta: stdDelta,
    meanVectorAngle: meanAngle
  };

  savedRecordings.push(rec);
  updateRecordingsList();
};

throbBtn.onclick = () => {
  if(recordingState !== 'running') return;
  const t = getCurrentTimestamp();
  throbs.push({timestamp: t});
};

toggleWaveformBtn.onclick = () => {
  showWaveform = !showWaveform;
  toggleWaveformBtn.textContent = showWaveform ? 'Hide Waveform' : 'Show Waveform';
  drawWaveform();
};

// --- Saved recordings UI ---

function updateRecordingsList(){
  recordingsList.innerHTML = '<h2>Saved Recordings</h2>';
  if(savedRecordings.length === 0){
    recordingsList.innerHTML += '<p>No recordings yet.</p>';
    return;
  }

  for(let i=0; i<savedRecordings.length; i++){
    const rec = savedRecordings[i];
    const div = document.createElement('div');
    div.className = 'recording-item';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'recording-name';
    nameSpan.textContent = rec.name;

    const btn = document.createElement('button');
    btn.textContent = 'Download CSV';
    btn.onclick = () => {
      const csv = generateCSV(rec);
      downloadCSV(`${rec.name.replace(/\s+/g,'_')}.csv`, csv);
    };

    div.appendChild(nameSpan);
    div.appendChild(btn);

    recordingsList.appendChild(div);
  }
}

</script>

</body>
</html>
