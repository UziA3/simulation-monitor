<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Migraine Throb Synchrony</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; }
  #controls button { margin-right: 10px; }
  #waveformCanvas { border: 1px solid #ccc; background: #fff; }
  .recording-item { margin: 8px 0; }
  .recording-name { font-weight: bold; display: inline-block; width: 200px; }
  button.exportBtn { margin-left: 10px; }
  #timer { font-size: 1.2em; margin: 10px 0; }
</style>
</head>
<body>

<h1>Migraine Throb Synchrony</h1>

<div id="controls">
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop & Save</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <button id="toggleWaveformBtn">Hide Waveform</button>
</div>

<div id="timer">00:00.000</div>
<canvas id="waveformCanvas" width="800" height="200"></canvas>

<div id="recordingsList"><h2>Saved Recordings</h2><p>No recordings yet.</p></div>

<script>
const canvas = document.getElementById('waveformCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const throbBtn = document.getElementById('throbBtn');
const toggleWaveformBtn = document.getElementById('toggleWaveformBtn');
const timerDisplay = document.getElementById('timer');
const recordingsList = document.getElementById('recordingsList');

let recordingState = 'stopped'; // 'running', 'paused'
let startTime = 0;
let elapsedPauseTime = 0;
let pauseStart = 0;
let showWaveform = true;

let throbs = [];
let pulsePeaks = [];
let bpmHistory = [];

let bpm = 70;
let lastBpmChange = 0;
let bpmChangeInterval = randomInt(3000,7000);

let savedRecordings = [];

function randomInt(min,max){ return Math.floor(Math.random()*(max-min+1)) + min; }

function getCurrentTimestamp(){
  if(recordingState === 'running'){
    return performance.now() - startTime - elapsedPauseTime;
  } else if(recordingState === 'paused'){
    return pauseStart - startTime - elapsedPauseTime;
  } else return 0;
}

function updateTimer(){
  let ms = getCurrentTimestamp();
  if(ms < 0) ms = 0;
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  const milliseconds = Math.floor(ms % 1000);
  timerDisplay.textContent = 
    `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(milliseconds).padStart(3,'0')}`;
}

function clearCanvas(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

// --- ECG-like waveform generation ---
// We model each beat as follows:
// - Baseline at 100 (y-axis)
// - P wave: small bump before main spike
// - QRS complex: sharp spike (R-wave) at center of beat
// - T wave: broader bump after spike
// We'll simulate one beat over the time per beat (beatDuration),
// with the waveform drawn as sum of gaussian bumps.

function generateECGWaveform(timeSinceLastPeak, beatDuration){
  // Normalize time in [0,1] per beat
  const t = timeSinceLastPeak / beatDuration;

  // Positions of features in normalized time (typical ECG positions)
  const pPos = 0.15;
  const qrsPos = 0.4;
  const tPos = 0.7;

  // Gaussian function
  function gauss(x, mu, sigma, height){
    return height * Math.exp(-Math.pow(x-mu,2) / (2*sigma*sigma));
  }

  // Amplitudes and widths of features (y-axis, smaller number means sharper)
  const baseline = 100;
  const pAmp = 8;
  const pWidth = 0.03;
  const qrsAmp = 40;
  const qrsWidth = 0.015;
  const tAmp = 12;
  const tWidth = 0.07;

  // Calculate waveform value
  const pWave = gauss(t, pPos, pWidth, pAmp);
  const qrsWave = gauss(t, qrsPos, qrsWidth, qrsAmp);
  const tWave = gauss(t, tPos, tWidth, tAmp);

  // ECG is baseline plus sum of these waves (QRS inverted as sharp downward spike)
  return baseline + pWave - qrsWave + tWave;
}

// --- BPM change management ---
function updateBPM(timestamp){
  if(timestamp - lastBpmChange > bpmChangeInterval){
    bpm = randomInt(60,100);
    lastBpmChange = timestamp;
    bpmChangeInterval = randomInt(3000,7000);
    bpmHistory.push({time: timestamp, bpm});
  }
}

// --- Generate pulse peaks times for storing ---
function generateNextPeak(previousPeakTime, currentBpm){
  return previousPeakTime + (60000 / currentBpm);
}

let animationId;
let previousPeakTime = 0;
let peakIndex = 0;

// For waveform drawing over 10 seconds max
const displayDuration = 10000;

function animationLoop(timestamp=0){
  if(recordingState !== 'running'){
    updateTimer();
    animationId = requestAnimationFrame(animationLoop);
    return;
  }
  if(!startTime) startTime = timestamp;

  const currentTime = getCurrentTimestamp();

  updateTimer();
  updateBPM(currentTime);

  // Generate peaks for new time frame
  while(previousPeakTime < currentTime + displayDuration){
    previousPeakTime = generateNextPeak(previousPeakTime, bpm);
    pulsePeaks.push({time: previousPeakTime, bpm});
  }

  drawWaveform();

  animationId = requestAnimationFrame(animationLoop);
}

function drawWaveform(){
  clearCanvas();
  if(!showWaveform) return;

  // Draw baseline
  ctx.strokeStyle = '#ccc';
  ctx.beginPath();
  ctx.moveTo(0, 100);
  ctx.lineTo(canvas.width, 100);
  ctx.stroke();

  const currentTime = getCurrentTimestamp();

  // Draw ECG waveform over last 10 seconds
  const startTimeWindow = currentTime - displayDuration;
  if(startTimeWindow < 0) return;

  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.beginPath();

  // Sample waveform at each pixel
  for(let x=0; x<=canvas.width; x++){
    const time = startTimeWindow + (x / canvas.width) * displayDuration;

    // Find last peak before time
    let peakBefore = null;
    for(let i = pulsePeaks.length - 1; i >= 0; i--){
      if(pulsePeaks[i].time <= time){
        peakBefore = pulsePeaks[i];
        break;
      }
    }
    if(!peakBefore){
      // Before first peak: baseline
      var y = 100;
    } else {
      // Calculate time since last peak
      const timeSincePeak = time - peakBefore.time;
      const beatDuration = 60000 / peakBefore.bpm;

      y = generateECGWaveform(timeSincePeak, beatDuration);
    }

    if(x === 0){
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();

  // Draw pulse peaks (R-wave) as red lines
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 1;
  pulsePeaks.forEach(peak => {
    if(peak.time >= startTimeWindow && peak.time <= currentTime){
      const x = ((peak.time - startTimeWindow) / displayDuration) * canvas.width;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
  });

  // Draw throb markers as green lines
  ctx.strokeStyle = 'green';
  ctx.lineWidth = 1;
  throbs.forEach(throb => {
    if(throb.timestamp >= startTimeWindow && throb.timestamp <= currentTime){
      const x = ((throb.timestamp - startTimeWindow) / displayDuration) * canvas.width;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
  });
}

function startRecording(){
  recordingState = 'running';
  startTime = performance.now();
  elapsedPauseTime = 0;
  pauseStart = 0;
  throbs = [];
  pulsePeaks = [];
  bpmHistory = [{time: 0, bpm}];
  previousPeakTime = 0;
  startBtn.disabled = true;
  pauseBtn.disabled = false;
  stopBtn.disabled = false;
  throbBtn.disabled = false;
  toggleWaveformBtn.disabled = false;
  timerDisplay.textContent = "00:00.000";
  drawWaveform();
  animationLoop();
}

function pauseRecording(){
  if(recordingState === 'running'){
    recordingState = 'paused';
    pauseStart = performance.now();
    pauseBtn.textContent = 'Resume';
  } else if(recordingState === 'paused'){
    recordingState = 'running';
    elapsedPauseTime += performance.now() - pauseStart;
    pauseBtn.textContent = 'Pause';
    animationLoop();
  }
}

function stopRecording(){
  recordingState = 'stopped';
  startBtn.disabled = false;
  pauseBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  pauseBtn.textContent = 'Pause';

  // Prompt for recording name
  let recName = prompt("Enter recording name:", `Recording_${savedRecordings.length+1}`);
  if(!recName) recName = `Recording_${savedRecordings.length+1}`;

  // Analyze throbs and pulse peaks
  const analyzedData = analyzeThrobs(throbs, pulsePeaks);

  // Compute synchrony metrics
  const stats = computeSynchronyStats(analyzedData);

  // Compute mean pulse rate
  const meanBpm = bpmHistory.length > 0 ? 
    (bpmHistory.reduce((a,v)=>a+v.bpm,0)/bpmHistory.length).toFixed(2) : 'N/A';

  // Prepare CSV
  const csv = generateCSV(recName, analyzedData, stats, meanBpm);

  savedRecordings.push({name: recName, csv});
  updateRecordingsList();
}

function markThrob(){
  if(recordingState !== 'running') return;
  const timestamp = getCurrentTimestamp();
  throbs.push({timestamp});
}

function updateRecordingsList(){
  if(savedRecordings.length === 0){
    recordingsList.innerHTML = "<h2>Saved Recordings</h2><p>No recordings yet.</p>";
    return;
  }
  let html = '<h2>Saved Recordings</h2>';
  savedRecordings.forEach((rec,i) => {
    html += `<div class="recording-item">
      <span class="recording-name">${rec.name}</span>
      <button class="exportBtn" data-index="${i}">Download CSV</button>
    </div>`;
  });
  recordingsList.innerHTML = html;

  // Add event listeners to export buttons
  const exportButtons = document.querySelectorAll('.exportBtn');
  exportButtons.forEach(btn => {
    btn.onclick = () => {
      const i = parseInt(btn.dataset.index);
      downloadCSV(savedRecordings[i].csv, savedRecordings[i].name + '.csv');
    };
  });
}

function downloadCSV(csvText, filename){
  const blob = new Blob([csvText], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// --- Analyze throbs: for each throb, find immediately preceding pulse peak, compute delta and phase ---
function analyzeThrobs(throbs, pulsePeaks){
  const analyzed = [];

  // Sort peaks by time just in case
  const sortedPeaks = pulsePeaks.slice().sort((a,b) => a.time - b.time);

  throbs.forEach(throb => {
    // Find immediately preceding pulse peak
    let priorPeak = null;
    for(let i=sortedPeaks.length-1; i>=0; i--){
      if(sortedPeaks[i].time <= throb.timestamp){
        priorPeak = sortedPeaks[i];
        break;
      }
    }
    if(!priorPeak){
      // No prior peak, skip this throb
      // BUT per instruction: include ALL throbs, so if no prior peak skip phase/delta but still add with nulls
      analyzed.push({
        throbTime: throb.timestamp.toFixed(1),
        priorPeakTime: '',
        delta: '',
        bpmAtPeak: '',
        phase: ''
      });
      return;
    }

    // Find next peak after priorPeak to calculate phase interval
    let nextPeak = null;
    for(let i=0; i<sortedPeaks.length; i++){
      if(sortedPeaks[i].time > priorPeak.time){
        nextPeak = sortedPeaks[i];
        break;
      }
    }
    // If no next peak, phase calculation not possible, phase = ''
    let delta = throb.timestamp - priorPeak.time;
    let phase = '';
    if(nextPeak){
      const interval = nextPeak.time - priorPeak.time;
      phase = (delta / interval) * 2 * Math.PI;
    }

    analyzed.push({
      throbTime: throb.timestamp.toFixed(1),
      priorPeakTime: priorPeak.time.toFixed(1),
      delta: delta.toFixed(1),
      bpmAtPeak: priorPeak.bpm,
      phase: phase === '' ? '' : phase.toFixed(3)
    });
  });
  return analyzed;
}

// --- Compute circular stats and synchrony metrics ---
function computeSynchronyStats(analyzedData){
  // Filter out throbs without phase
  const phaseData = analyzedData
    .map(d => d.phase)
    .filter(p => p !== '')
    .map(p => parseFloat(p));

  if(phaseData.length === 0){
    return {
      rayleighR: 0,
      rayleighP: 'N/A',
      pvl: 0,
      phaseMean: 'N/A',
      phaseStdDev: 'N/A'
    };
  }

  const n = phaseData.length;
  let sumSin = 0;
  let sumCos = 0;

  phaseData.forEach(p => {
    sumSin += Math.sin(p);
    sumCos += Math.cos(p);
  });

  const meanSin = sumSin / n;
  const meanCos = sumCos / n;

  const R = Math.sqrt(meanSin*meanSin + meanCos*meanCos);
  const meanAngle = Math.atan2(meanSin, meanCos);

  // Rayleigh test p-value approximation
  const z = n * R * R;
  let pVal = Math.exp(-z) * (1 + (2*z - z*z) / (4*n) - (24*z - 132*z*z + 76*z*z*z - 9*z*z*z*z) / (288*n*n));
  if(pVal < 0.001) pVal = '<0.001';
  else pVal = pVal.toFixed(3);

  // Phase vector length is R
  // Phase std dev approx sqrt(-2*ln(R))
  const phaseStdDev = Math.sqrt(-2*Math.log(R));

  return {
    rayleighR: R.toFixed(3),
    rayleighP: pVal,
    pvl: R.toFixed(3),
    phaseMean: meanAngle.toFixed(3),
    phaseStdDev: phaseStdDev.toFixed(3)
  };
}

function generateCSV(recName, analyzedData, stats, meanBpm){
  let csv = '';
  csv += `Recording Name,${recName}\n`;
  csv += `Total Throb Count,${analyzedData.length}\n`;
  csv += `Total Pulse Peak Count,${pulsePeaks.length}\n`;
  csv += `Mean Pulse Rate (BPM),${meanBpm}\n`;
  csv += `Rayleigh R,${stats.rayleighR}\n`;
  csv += `Rayleigh p-value,${stats.rayleighP}\n`;
  csv += `PVL,${stats.pvl}\n`;
  csv += `Mean Vector Angle (radians),${stats.phaseMean}\n`;
  csv += `Phase Std Dev (radians),${stats.phaseStdDev}\n`;
  csv += '\n';
  csv += 'Throb Time (ms),Prior Pulse Peak (ms),Delta (ms),BPM at Peak,Phase (radians)\n';

  analyzedData.forEach(d => {
    csv += `${d.throbTime},${d.priorPeakTime},${d.delta},${d.bpmAtPeak},${d.phase}\n`;
  });

  return csv;
}

// --- Event Listeners ---
startBtn.addEventListener('click', () => startRecording());
pauseBtn.addEventListener('click', () => pauseRecording());
stopBtn.addEventListener('click', () => stopRecording());
throbBtn.addEventListener('click', () => markThrob());
toggleWaveformBtn.addEventListener('click', () => {
  showWaveform = !showWaveform;
  toggleWaveformBtn.textContent = showWaveform ? 'Hide Waveform' : 'Show Waveform';
  drawWaveform();
});

// Initial setup
clearCanvas();
updateRecordingsList();

</script>

</body>
</html>
