<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; margin-bottom: 10px; display: block; }
  button, label { margin: 5px; }
  .stats { margin-top: 10px; }
  #recordingsList { margin-top: 40px; border-top: 1px solid #ddd; padding-top: 10px; }
  #recordingsList div { margin-bottom: 10px; }
  .recording-item { border: 1px solid #ccc; padding: 8px; border-radius: 5px; background: #f9f9f9; }
  .recording-header { font-weight: bold; margin-bottom: 5px; }
  .throb-times { font-family: monospace; font-size: 0.9em; margin-top: 6px; margin-bottom: 6px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<canvas id="canvas" width="800" height="200"></canvas>

<button id="startBtn">Start</button>
<button id="pauseBtn" disabled>Pause</button>
<button id="resumeBtn" disabled>Resume</button>
<button id="stopBtn" disabled>Stop</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<div class="controls">
  <button id="toggleAllBtn">Hide All Stats & Markings</button>
</div>

<div class="stats" id="metricsDisplay"></div>

<h2>Saved Recordings</h2>
<div id="recordingsList"></div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const toggleAllBtn = document.getElementById("toggleAllBtn");
  const recordingsList = document.getElementById("recordingsList");

  // Data for current recording
  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;

  // All saved recordings
  const recordings = [];

  // Flag for display
  let allVisible = true;

  // Constants
  const DISPLAY_DURATION = 20000;
  const SAMPLE_INTERVAL = 20;
  const BASELINE = 100;
  const AMPLITUDE = 50;
  const FREQ = 1.2;

  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const noise = (Math.random() - 0.5) * 5;
      const value = BASELINE + AMPLITUDE * Math.sin(2 * Math.PI * FREQ * t) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  function draw() {
    simulatePulse();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!allVisible) {
      if (isRecording && !isPaused) {
        animationId = requestAnimationFrame(draw);
      }
      return;
    }

    const now = performance.now();
    const start = now - DISPLAY_DURATION;

    ctx.beginPath();
    pulseWave.forEach((p, i) => {
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();

    throbs.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValue(throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    });

    const peaks = findPeaks();
    peaks.forEach(peakTime => {
      if (peakTime < start || peakTime > now) return;
      const val = interpolatePulseValue(peakTime);
      if (val === null) return;
      const x = ((peakTime - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "green";
      ctx.fill();
    });

    if (isRecording && !isPaused) {
      animationId = requestAnimationFrame(draw);
    }
  }

  function interpolatePulseValue(t) {
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null;
  }

  function findPeaks() {
    const peaks = [];
    const values = pulseWave.map(p => p.value);
    for (let i = 1; i < values.length - 1; i++) {
      if (values[i] > values[i - 1] && values[i] > values[i + 1]) {
        peaks.push(pulseWave[i].time);
      }
    }
    return peaks;
  }

  function calculatePhase(t) {
    const peaks = findPeaks();
    if (peaks.length < 2) return null;

    let prevPeak = null, nextPeak = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= t && peaks[i + 1] > t) {
        prevPeak = peaks[i];
        nextPeak = peaks[i + 1];
        break;
      }
    }

    if (prevPeak === null || nextPeak === null) return null;

    const phase = 2 * Math.PI * (t - prevPeak) / (nextPeak - prevPeak);
    return normalizeAngle(phase);
  }

  function normalizeAngle(angle) {
    let a = angle % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  function circularMean(angles) {
    if (angles.length === 0) return null;
    const sumSin = angles.reduce((acc, a) => acc + Math.sin(a), 0);
    const sumCos = angles.reduce((acc, a) => acc + Math.cos(a), 0);
    let mean = Math.atan2(sumSin, sumCos);
    mean = normalizeAngle(mean);
    return mean;
  }

  function circularVariance(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    ) / n;
    return 1 - R;
  }

  function rayleighTest(angles) {
    if (angles.length === 0) return null;
    const n = angles.length;
    const R = Math.sqrt(
      Math.pow(angles.reduce((acc, a) => acc + Math.cos(a), 0), 2) +
      Math.pow(angles.reduce((acc, a) => acc + Math.sin(a), 0), 2)
    );
    const z = (R * R) / n;
    return Math.exp(-z);
  }

  function calculatePLV() {
    throbs.forEach(throb => {
      throb.phase = calculatePhase(throb.time);
      throb.pulseValue = interpolatePulseValue(throb.time);
    });

    const validPhases = throbs.map(t => t.phase).filter(p => p !== null);
    if (validPhases.length === 0) {
      return {
        plv: 0,
        meanPhaseRad: null,
        meanPhaseDeg: null,
        variance: null,
        rayleighP: null,
        vectorStrength: 0,
        numThrobs: 0
      };
    }

    const n = validPhases.length;
    const sumCos = validPhases.reduce((a, p) => a + Math.cos(p), 0);
    const sumSin = validPhases.reduce((a, p) => a + Math.sin(p), 0);

    const R = Math.sqrt(sumCos * sumCos + sumSin * sumSin);
    const plv = R / n;
    const vectorStrength = plv; // Same as PLV, named for clarity
    const meanPhaseRad = Math.atan2(sumSin, sumCos);
    const meanPhaseRadNormalized = normalizeAngle(meanPhaseRad);
    const meanPhaseDeg = (meanPhaseRadNormalized * 180 / Math.PI).toFixed(2);
    const variance = 1 - (R / n);
    const rayleighP = Math.exp(-(R * R) / n);

    return {
      plv,
      meanPhaseRad: meanPhaseRadNormalized,
      meanPhaseDeg,
      variance,
      rayleighP,
      vectorStrength,
      numThrobs: n
    };
  }

  function formatRayleighP(p) {
    if (p === null) return 'N/A';
    if (p < 0.0001) return '<0.0001';
    return p.toFixed(4);
  }

  function formatTime(ms) {
    // Format ms with 2 decimals for easier reading
    return ms.toFixed(2);
  }

  function formatElapsedTime(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
    return `${minutes}:${seconds}`;
  }

  function updateTimer() {
    if (!recordingStartTime) {
      timerDisplay.textContent = "00:00";
      return;
    }
    const elapsed = performance.now() - recordingStartTime;
    timerDisplay.textContent = formatElapsedTime(elapsed);
  }

  function updateMetricsDisplay() {
    if (throbs.length === 0) {
      metricsDisplay.textContent = "No throbs marked yet.";
      return;
    }
    const stats = calculatePLV();
    metricsDisplay.innerHTML = `
      <strong>Phase Locking Value (PLV):</strong> ${stats.plv.toFixed(4)}<br />
      <strong>Circular Variance:</strong> ${stats.variance.toFixed(4)}<br />
      <strong>Rayleigh p-value:</strong> ${formatRayleighP(stats.rayleighP)}<br />
      <strong>Mean Phase Angle:</strong> ${stats.meanPhaseDeg}Â°<br />
      <strong>Vector Strength:</strong> ${stats.vectorStrength.toFixed(4)}<br />
      <strong>Number of Throbs:</strong> ${stats.numThrobs}
    `;
  }

  function createCSVContent(recording) {
    const { throbs, stats } = recording;
    let csv = 'Throb Index,Throb Time (ms),Pulse Value,Phase (radians),Phase (degrees)\n';

    throbs.forEach((throb, i) => {
      const tRelative = throb.time - recording.startTime;
      const phaseDeg = throb.phase === null ? '' : (throb.phase * 180 / Math.PI).toFixed(2);
      csv += `${i + 1},${formatTime(tRelative)},${throb.pulseValue ? throb.pulseValue.toFixed(2) : ''},${throb.phase !== null ? throb.phase.toFixed(4) : ''},${phaseDeg}\n`;
    });

    csv += '\n';
    csv += 'Summary Statistics,,,\n';
    csv += `PLV,${stats.plv.toFixed(4)}\n`;
    csv += `Circular Variance,${stats.variance.toFixed(4)}\n`;
    csv += `Rayleigh p-value,${formatRayleighP(stats.rayleighP)}\n`;
    csv += `Mean Phase Angle (degrees),${stats.meanPhaseDeg}\n`;
    csv += `Vector Strength,${stats.vectorStrength.toFixed(4)}\n`;
    csv += `Number of Throbs,${stats.numThrobs}\n`;

    return csv;
  }

  function downloadCSV(recording) {
    const csvContent = createCSVContent(recording);
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `recording_${new Date(recording.startTime).toISOString().replace(/[:.]/g, '-')}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function addRecordingToList(recording, index) {
    const div = document.createElement('div');
    div.classList.add('recording-item');

    const startDate = new Date(recording.startTime);
    const startTimeStr = startDate.toLocaleString();

    const stats = recording.stats;

    div.innerHTML = `
      <div class="recording-header">Recording #${index + 1} - Started: ${startTimeStr}</div>
      <div><strong>Throb times (ms relative to start):</strong></div>
      <div class="throb-times">${recording.throbs.map(t => formatTime(t.time - recording.startTime)).join(', ') || 'No throbs marked'}</div>
      <div>
        <strong>Summary statistics:</strong><br />
        PLV: ${stats.plv.toFixed(4)}<br />
        Circular Variance: ${stats.variance.toFixed(4)}<br />
        Rayleigh p-value: ${formatRayleighP(stats.rayleighP)}<br />
        Mean Phase Angle: ${stats.meanPhaseDeg}Â°<br />
        Vector Strength: ${stats.vectorStrength.toFixed(4)}<br />
        Number of Throbs: ${stats.numThrobs}
      </div>
      <button data-index="${index}" class="downloadBtn">Download CSV</button>
    `;

    recordingsList.appendChild(div);
  }

  function refreshRecordingsList() {
    recordingsList.innerHTML = '';
    recordings.forEach((rec, idx) => {
      addRecordingToList(rec, idx);
    });

    // Attach listeners for download buttons
    document.querySelectorAll('.downloadBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = Number(btn.getAttribute('data-index'));
        downloadCSV(recordings[idx]);
      });
    });
  }

  startBtn.addEventListener("click", () => {
    if (isRecording) return;
    recordingStartTime = performance.now();
    throbs = [];
    pulseWave = [];
    isRecording = true;
    isPaused = false;

    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;

    updateTimer();
    timerInterval = setInterval(updateTimer, 250);
    updateMetricsDisplay();
    draw();
  });

  pauseBtn.addEventListener("click", () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
    cancelAnimationFrame(animationId);
    clearInterval(timerInterval);
  });

  resumeBtn.addEventListener("click", () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
    updateTimer();
    timerInterval = setInterval(updateTimer, 250);
    draw();
  });

  stopBtn.addEventListener("click", () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;

    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;

    clearInterval(timerInterval);
    cancelAnimationFrame(animationId);

    const stats = calculatePLV();
    // Save current recording
    recordings.push({
      startTime: recordingStartTime,
      throbs: throbs.map(t => ({...t})),
      stats
    });
    updateMetricsDisplay();
    refreshRecordingsList();
  });

  throbBtn.addEventListener("click", () => {
    if (!isRecording || isPaused) return;
    const now = performance.now();
    throbs.push({ time: now, phase: null, pulseValue: null });
    updateMetricsDisplay();
  });

  toggleAllBtn.addEventListener("click", () => {
    allVisible = !allVisible;
    toggleAllBtn.textContent = allVisible ? 'Hide All Stats & Markings' : 'Show All Stats & Markings';
  });

})();
</script>

</body>
</html>
