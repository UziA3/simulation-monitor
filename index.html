<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pulse Throb Monitor</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  canvas { border: 1px solid #ccc; display: block; margin-bottom: 10px; }
  button, input[type="text"] { margin: 5px; }
  .stats { margin-top: 10px; font-size: 14px; }
  .recordings-list { margin-top: 20px; border-top: 1px solid #999; padding-top: 10px; }
  .recording-item { margin-bottom: 8px; }
  .recording-item input.name-input {
    width: 180px;
    padding: 3px;
  }
  .recording-item button {
    margin-left: 8px;
  }
  #extraStats {
    margin-top: 12px;
    font-weight: bold;
    font-size: 15px;
  }
</style>
</head>
<body>

<h1>Pulse Throb Monitor (Simulated)</h1>

<canvas id="canvas" width="800" height="200"></canvas>

<div>
  <button id="startBtn">Start</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <button id="toggleAllBtn">Hide All Stats, Markings & Waveform</button>
</div>

<div>Timer: <span id="timer">00:00</span></div>

<div class="stats" id="metricsDisplay"></div>

<!-- New div for mean pulse rate and delta time -->
<div id="extraStats"></div>

<div class="recordings-list" id="recordingsList">
  <h3>Saved Recordings</h3>
  <div id="recordingsContainer">No recordings saved yet.</div>
</div>

<script>
(() => {
  // === Setup ===
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resumeBtn = document.getElementById("resumeBtn");
  const stopBtn = document.getElementById("stopBtn");
  const throbBtn = document.getElementById("throbBtn");
  const toggleAllBtn = document.getElementById("toggleAllBtn");

  const timerDisplay = document.getElementById("timer");
  const metricsDisplay = document.getElementById("metricsDisplay");
  const extraStatsDisplay = document.getElementById("extraStats");
  const recordingsContainer = document.getElementById("recordingsContainer");

  // === Variables ===
  let pulseWave = [];
  let throbs = [];
  let recordingStartTime = null;
  let isRecording = false;
  let isPaused = false;
  let timerInterval = null;
  let animationId = null;
  let lastSampleTime = 0;
  let allVisible = true;

  const savedRecordings = [];
  let selectedRecordingIndex = null;

  const DISPLAY_DURATION = 20000; // 20s
  const SAMPLE_INTERVAL = 20; // ms

  // Baseline and amplitude used for vertical positioning
  const BASELINE = 120;
  const AMPLITUDE = 70;

  // --- New: simulate more realistic arterial waveform ---
  // Function to simulate one arterial pulse shape with systolic peak and dicrotic notch
  // t goes from 0 to 1 representing one pulse cycle (normalized)
  function arterialWaveform(t) {
    // Systolic peak at ~0.2
    // Dicrotic notch around 0.45
    // Decay until next pulse (1.0)

    if (t < 0) return BASELINE;
    t = t % 1; // cycle

    if (t < 0.2) {
      // Rapid rise to systolic peak
      return BASELINE + AMPLITUDE * (5 * t);
    } else if (t < 0.3) {
      // Slight drop after peak
      return BASELINE + AMPLITUDE * (1 - 3 * (t - 0.2));
    } else if (t < 0.45) {
      // Dicrotic notch dip
      return BASELINE + AMPLITUDE * (0.7 - 4 * (t - 0.3));
    } else if (t < 0.7) {
      // Slow return to baseline
      return BASELINE + AMPLITUDE * (0.3 + 2 * (t - 0.45));
    } else {
      // Diastolic plateau near baseline
      return BASELINE;
    }
  }

  // Base pulse frequency ~ 1.2Hz (72 bpm)
  const BASE_FREQ = 1.2;

  // === Utilities ===
  function formatTimer(ms) {
    const totalSeconds = Math.floor(ms / 1000);
    const m = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
    const s = String(totalSeconds % 60).padStart(2, "0");
    return `${m}:${s}`;
  }

  function normalizeAngle(angle) {
    let a = angle % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  // === Data simulation ===
  function simulatePulse() {
    const now = performance.now();
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
      const t = now / 1000;
      const cycleTime = (BASE_FREQ * t) % 1;
      const noise = (Math.random() - 0.5) * 4; // less noise for clarity
      const value = arterialWaveform(cycleTime) + noise;
      pulseWave.push({ time: now, value });
      lastSampleTime = now;
    }

    // Keep only last 5 minutes of data for memory safety
    const cutoff = performance.now() - 5 * 60 * 1000;
    pulseWave = pulseWave.filter(p => p.time >= cutoff);
  }

  // === Drawing ===
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!allVisible) return;

    let waveToDraw, throbsToDraw;

    if (selectedRecordingIndex !== null) {
      const rec = savedRecordings[selectedRecordingIndex];
      waveToDraw = rec.pulseWave;
      throbsToDraw = rec.throbs;
    } else {
      waveToDraw = pulseWave;
      throbsToDraw = throbs;
    }

    if (!waveToDraw.length) return;

    const now = selectedRecordingIndex !== null
      ? waveToDraw[waveToDraw.length - 1].time
      : performance.now();
    const start = now - DISPLAY_DURATION;

    // Draw waveform in blue
    ctx.beginPath();
    waveToDraw.forEach((p, i) => {
      if (p.time < start) return;
      const x = ((p.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0 || waveToDraw[i - 1].time < start) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs as red circles
    throbsToDraw.forEach(throb => {
      if (throb.time < start || throb.time > now) return;
      const val = interpolatePulseValueIn(waveToDraw, throb.time);
      if (val === null) return;
      const x = ((throb.time - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "red";
      ctx.fill();
    });

    // Draw peaks in green
    const peaks = findPeaksIn(waveToDraw);
    peaks.forEach(peakTime => {
      if (peakTime < start || peakTime > now) return;
      const val = interpolatePulseValueIn(waveToDraw, peakTime);
      if (val === null) return;
      const x = ((peakTime - start) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - val;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, 2 * Math.PI);
      ctx.fillStyle = "green";
      ctx.fill();
    });
  }

  // Helper to interpolate pulse value at any time from data
  function interpolatePulseValueIn(data, time) {
    if (!data.length) return null;
    for (let i = 0; i < data.length - 1; i++) {
      if (data[i].time <= time && time <= data[i + 1].time) {
        const t1 = data[i].time, t2 = data[i + 1].time;
        const v1 = data[i].value, v2 = data[i + 1].value;
        const ratio = (time - t1) / (t2 - t1);
        return v1 + ratio * (v2 - v1);
      }
    }
    return null;
  }

  // Find peaks by local maxima with a minimum prominence
  // Returns array of times
  function findPeaksIn(data) {
    const peaks = [];
    for (let i = 1; i < data.length - 1; i++) {
      if (data[i].value > data[i - 1].value && data[i].value > data[i + 1].value) {
        // Additional: only take peaks > baseline + amplitude/3
        if (data[i].value > BASELINE + AMPLITUDE / 3) {
          peaks.push(data[i].time);
        }
      }
    }
    return peaks;
  }

  // === Timer display ===
  function updateTimer() {
    if (!isRecording || isPaused) return;
    const elapsed = performance.now() - recordingStartTime;
    timerDisplay.textContent = formatTimer(elapsed);
  }

  // === Metrics display ===
  function updateMetrics() {
    let waveToUse, throbsToUse;

    if (selectedRecordingIndex !== null) {
      const rec = savedRecordings[selectedRecordingIndex];
      waveToUse = rec.pulseWave;
      throbsToUse = rec.throbs;
    } else {
      waveToUse = pulseWave;
      throbsToUse = throbs;
    }

    // Show number of data points and throbs
    metricsDisplay.textContent =
      `Data Points: ${waveToUse.length} | Marked Throbs: ${throbsToUse.length}`;

    // Calculate mean pulse rate from peak detection in last 20s
    const now = performance.now();
    const start = now - DISPLAY_DURATION;
    const peaks = findPeaksIn(waveToUse.filter(p => p.time >= start));

    let meanPulseRate = "N/A";
    if (peaks.length > 1) {
      // Calculate average interval in seconds
      let intervals = [];
      for (let i = 1; i < peaks.length; i++) {
        intervals.push((peaks[i] - peaks[i - 1]) / 1000);
      }
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      meanPulseRate = (60 / avgInterval).toFixed(1) + " bpm";
    }

    // Calculate delta time since last throb (if any)
    let deltaSinceLastThrob = "N/A";
    if (throbsToUse.length > 0) {
      const lastThrob = throbsToUse[throbsToUse.length - 1].time;
      deltaSinceLastThrob = ((now - lastThrob) / 1000).toFixed(2) + " s";
    }

    extraStatsDisplay.innerHTML = `
      Mean Pulse Rate (last 20s): <span style="color:green">${meanPulseRate}</span><br/>
      Time Since Last Throb: <span style="color:red">${deltaSinceLastThrob}</span>
    `;
  }

  // === Recording management ===
  function saveRecording(name) {
    if (!name.trim()) {
      alert("Please enter a recording name.");
      return false;
    }
    // Save current pulseWave and throbs copy
    savedRecordings.push({
      name,
      pulseWave: pulseWave.slice(),
      throbs: throbs.slice(),
    });
    renderRecordingsList();
    return true;
  }

  function deleteRecording(index) {
    savedRecordings.splice(index, 1);
    if (selectedRecordingIndex === index) selectedRecordingIndex = null;
    renderRecordingsList();
  }

  function renameRecording(index, newName) {
    if (!newName.trim()) {
      alert("Recording name cannot be empty.");
      return false;
    }
    savedRecordings[index].name = newName;
    renderRecordingsList();
    return true;
  }

  function selectRecording(index) {
    if (index === selectedRecordingIndex) {
      selectedRecordingIndex = null;
    } else {
      selectedRecordingIndex = index;
    }
  }

  function renderRecordingsList() {
    if (savedRecordings.length === 0) {
      recordingsContainer.textContent = "No recordings saved yet.";
      extraStatsDisplay.textContent = "";
      return;
    }
    recordingsContainer.innerHTML = "";
    savedRecordings.forEach((rec, i) => {
      const div = document.createElement("div");
      div.className = "recording-item";
      const selected = (i === selectedRecordingIndex);
      div.style.background = selected ? "#e0f7fa" : "transparent";

      // Name input
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = rec.name;
      nameInput.className = "name-input";
      nameInput.title = "Click to edit name, press Enter to save";
      nameInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          if (renameRecording(i, nameInput.value)) {
            nameInput.blur();
          }
        }
      });
      nameInput.addEventListener("click", e => e.stopPropagation());

      // Select on click of div
      div.addEventListener("click", () => {
        selectRecording(i);
        renderRecordingsList();
        updateMetrics();
        updateTimer();
      });

      // Delete button
      const delBtn = document.createElement("button");
      delBtn.textContent = "Delete";
      delBtn.addEventListener("click", e => {
        e.stopPropagation();
        if (confirm(`Delete recording "${rec.name}"?`)) {
          deleteRecording(i);
          updateMetrics();
          updateTimer();
        }
      });

      div.appendChild(nameInput);
      div.appendChild(delBtn);
      recordingsContainer.appendChild(div);
    });
  }

  // === Control Handlers ===

  startBtn.addEventListener("click", () => {
    if (isRecording) return;
    pulseWave = [];
    throbs = [];
    recordingStartTime = performance.now();
    isRecording = true;
    isPaused = false;
    timerDisplay.textContent = "00:00";
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    selectedRecordingIndex = null;
  });

  pauseBtn.addEventListener("click", () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
  });

  resumeBtn.addEventListener("click", () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
    lastSampleTime = performance.now();
  });

  stopBtn.addEventListener("click", () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;

    // Prompt to save
    const name = prompt("Enter a name to save this recording (Cancel to discard):");
    if (name && name.trim()) {
      if (saveRecording(name.trim())) {
        alert("Recording saved.");
      }
    } else {
      alert("Recording discarded.");
    }
  });

  throbBtn.addEventListener("click", () => {
    if (!isRecording || isPaused) return;
    const now = performance.now();
    throbs.push({ time: now });
  });

  toggleAllBtn.addEventListener("click", () => {
    allVisible = !allVisible;
    toggleAllBtn.textContent = allVisible
      ? "Hide All Stats, Markings & Waveform"
      : "Show All Stats, Markings & Waveform";
    if (!allVisible) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  });

  // === Main loop ===
  function loop() {
    if (isRecording && !isPaused) {
      simulatePulse();
      updateTimer();
    }
    draw();
    updateMetrics();
    animationId = requestAnimationFrame(loop);
  }

  // Start animation loop on page load (stops drawing only if no recording and toggle off)
  loop();

  // Render recordings on load (empty)
  renderRecordingsList();
})();
</script>

</body>
</html>
